{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/img/avatar.jpg","path":"img/avatar.jpg","modified":1,"renderable":0},{"_id":"source/img/icon_wechat.jpg","path":"img/icon_wechat.jpg","modified":1,"renderable":0},{"_id":"source/img/favicon.ico","path":"img/favicon.ico","modified":1,"renderable":0},{"_id":"source/img/tag-bg.jpg","path":"img/tag-bg.jpg","modified":1,"renderable":0},{"_id":"source/img/home-bg-o.jpg","path":"img/home-bg-o.jpg","modified":1,"renderable":0},{"_id":"themes/huxblog/source/css/font-awesome.min.css","path":"css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/huxblog/source/css/hux-blog.css","path":"css/hux-blog.css","modified":1,"renderable":1},{"_id":"themes/huxblog/source/css/hux-blog.min.css","path":"css/hux-blog.min.css","modified":1,"renderable":1},{"_id":"themes/huxblog/source/css/syntax.styl","path":"css/syntax.styl","modified":1,"renderable":1},{"_id":"themes/huxblog/source/fonts/fontawesome-webfont.eot","path":"fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/huxblog/source/fonts/fontawesome-webfont.woff","path":"fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":1,"renderable":1},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":1,"renderable":1},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":1,"renderable":1},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":1,"renderable":1},{"_id":"themes/huxblog/source/js/hux-blog.js","path":"js/hux-blog.js","modified":1,"renderable":1},{"_id":"themes/huxblog/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":1,"renderable":1},{"_id":"themes/huxblog/source/js/hux-blog.min.js","path":"js/hux-blog.min.js","modified":1,"renderable":1},{"_id":"themes/huxblog/source/js/jquery.nav.js","path":"js/jquery.nav.js","modified":1,"renderable":1},{"_id":"themes/huxblog/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":1,"renderable":1},{"_id":"themes/huxblog/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":1,"renderable":1},{"_id":"themes/huxblog/source/fonts/fontawesome-webfont.ttf","path":"fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":1,"renderable":1},{"_id":"themes/huxblog/source/js/bootstrap.js","path":"js/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/huxblog/source/js/jquery.min.js","path":"js/jquery.min.js","modified":1,"renderable":1},{"_id":"source/img/contact-bg.jpg","path":"img/contact-bg.jpg","modified":1,"renderable":0},{"_id":"themes/huxblog/source/css/bootstrap.css","path":"css/bootstrap.css","modified":1,"renderable":1},{"_id":"source/img/404-bg.jpg","path":"img/404-bg.jpg","modified":1,"renderable":0},{"_id":"source/img/home-bg.jpg","path":"img/home-bg.jpg","modified":1,"renderable":0},{"_id":"themes/huxblog/source/js/jquery.js","path":"js/jquery.js","modified":1,"renderable":1},{"_id":"source/img/about-bg.jpg","path":"img/about-bg.jpg","modified":1,"renderable":0}],"Cache":[{"_id":"source/404.md","hash":"83c2c6d587beaa967a976e5969d60fa97fcdbe55","modified":1466216495244},{"_id":"source/CNAME","hash":"3278c9d7d4882edeeac323f4c59d874c13a7fbc3","modified":1466216495244},{"_id":"themes/huxblog/LICENSE","hash":"2b209f06bebeb2a8c2b7e187e436f3e1e1fbc8a7","modified":1466216495296},{"_id":"themes/huxblog/layout/archive.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1466216495296},{"_id":"source/_posts/AndroidStudio_VS_eclipse.md","hash":"c112c2506f7ade75d234f2769f0257c760e71194","modified":1469708126696},{"_id":"source/_posts/AndroidStudio_shortcut_key.md","hash":"d94e6649e2636fdacf35c80ce08264294f1171ca","modified":1469708126732},{"_id":"source/_posts/AndroidStudySource.md","hash":"399e88dd85d8455c454549ae65717e27d20d4476","modified":1469708126820},{"_id":"source/_posts/Logger_analyse.md","hash":"c4a48d3355a90a476f57a38a7947c3e0aa5258c4","modified":1469758948994},{"_id":"source/_posts/Markdown_user_guide.md","hash":"803e8200a9bcccd3c9b6a57d326b3b28be1ab160","modified":1469708126868},{"_id":"source/_posts/To_Commemorate_The_First_Anniversary_Of_Graduation.md","hash":"3555f98fed660eae2069657cdaaee8a88a9cfc71","modified":1469708126880},{"_id":"source/_posts/UML_learning_note.md","hash":"86287bc492613a469b0569668c2f3d73acfa4df2","modified":1469708126960},{"_id":"source/_posts/annotation_learning.md","hash":"601412647d9ec279e65736f451463eb91c1417a3","modified":1470149990191},{"_id":"source/_posts/envsetup_common_command.md","hash":"0973900e7ad09e626f67bcce7c70b8ed012faf74","modified":1469708126980},{"_id":"source/_posts/yunnan_in_my_heart.md","hash":"d1742095a18d36844f3fac93fede9935e7b8696e","modified":1469708126984},{"_id":"source/img/avatar.jpg","hash":"44988594e1a6bcdc2ba5e5a13a641b854f1959b1","modified":1469708127028},{"_id":"source/img/icon_wechat.jpg","hash":"06159dc41c093fae4709ad6b21a095e380f9fee3","modified":1468325583722},{"_id":"source/tags/index.md","hash":"0bc541f4c6a0f21bec67b6717ee86226f0eddf39","modified":1466216495296},{"_id":"themes/huxblog/languages_to_be_added/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1466216495296},{"_id":"themes/huxblog/languages_to_be_added/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1466216495296},{"_id":"themes/huxblog/languages_to_be_added/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1466216495296},{"_id":"themes/huxblog/languages_to_be_added/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1466216495296},{"_id":"themes/huxblog/languages_to_be_added/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1466216495296},{"_id":"themes/huxblog/languages_to_be_added/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1466216495296},{"_id":"themes/huxblog/languages_to_be_added/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1466216495296},{"_id":"themes/huxblog/languages_to_be_added/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1466216495296},{"_id":"themes/huxblog/languages_to_be_added/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1466216495296},{"_id":"themes/huxblog/layout/404.ejs","hash":"a4d73541a53e56b7dd46249c6d27cb59f4d97422","modified":1466216495296},{"_id":"themes/huxblog/layout/about.ejs","hash":"7f56c71383ef6c156b56d79b3984e07cc466606a","modified":1466216495296},{"_id":"themes/huxblog/layout/index.ejs","hash":"e25cbd9e381fa473198b8edfbd735048926d3812","modified":1466216495296},{"_id":"themes/huxblog/layout/keynote.ejs","hash":"6b419e6816aa1b6fd2dd5fd368f66ea58ff86f3f","modified":1466218107872},{"_id":"themes/huxblog/layout/layout.ejs","hash":"25d79ea00e68582384f0179c89107269d23a28aa","modified":1466218128752},{"_id":"themes/huxblog/layout/page.ejs","hash":"f3046c2edce3be1d038269f8e7319b07c3a482f9","modified":1466216008828},{"_id":"themes/huxblog/layout/post.ejs","hash":"4dcec357e2f02492fafb3a1cfd2c3e0b09aa2551","modified":1466218145928},{"_id":"themes/huxblog/layout/tags.ejs","hash":"a51bf2828af20939d702de1fdae067439a1153c0","modified":1466216495296},{"_id":"source/img/favicon.ico","hash":"5228c9322413d7f677d67685502b9efdfdc3b953","modified":1466216495292},{"_id":"source/img/tag-bg.jpg","hash":"8844274a812ae19e8f2a3b7e4e465342e63eb852","modified":1466216495296},{"_id":"source/_posts/AndroidStudio_shortcut_key/01-highlight.gif","hash":"37549fd11fc845ff645d944c89d1851a903c9d07","modified":1469708126732},{"_id":"source/_posts/AndroidStudio_shortcut_key/05-quickdefinition.gif","hash":"f957bb5ffd41f83d1dd5dbb0bca615239cd9e132","modified":1469708126744},{"_id":"source/_posts/AndroidStudio_shortcut_key/06-codefolding.gif","hash":"1a0e34fca50e49b84c3da96fab2748b4212350e6","modified":1469708126744},{"_id":"source/_posts/AndroidStudio_shortcut_key/08-findaction.gif","hash":"dc22d7155601cba04a32d760c26d19570211145e","modified":1469708126744},{"_id":"source/_posts/AndroidStudio_shortcut_key/09-movelines.gif","hash":"b49af57e70b4a4f86172da75e797a5fc6c202892","modified":1469708126744},{"_id":"source/_posts/AndroidStudio_shortcut_key/10-deleteline.gif","hash":"be20980597f6cf38356fc8313902dda3bc4176de","modified":1469708126744},{"_id":"source/_posts/AndroidStudio_shortcut_key/11-duplicate_lines.gif","hash":"34fcaa4e84dca6da0c23bd9b5ccbd850bde040a0","modified":1469708126744},{"_id":"source/_posts/AndroidStudio_shortcut_key/12-expand_shrink_selection.gif","hash":"0c21407236f89283af4f9255cb4de5bbcf0490a0","modified":1469708126760},{"_id":"source/_posts/AndroidStudio_shortcut_key/13-surround_with.gif","hash":"fa49968f10f4fcc509dc8c470d008b5723069fe2","modified":1469708126760},{"_id":"source/_posts/AndroidStudio_shortcut_key/14-recents.gif","hash":"58ee2d99743fcd34cab010c699d7274f1004dafe","modified":1469708126764},{"_id":"source/_posts/AndroidStudio_shortcut_key/15-movemethods.gif","hash":"469b3a9f284770e034d6226969739881fc74afec","modified":1469708126764},{"_id":"source/_posts/AndroidStudio_shortcut_key/16-completestatement.gif","hash":"a7242a57ebe112b455e855f31c29193002f7ce03","modified":1469708126764},{"_id":"source/_posts/AndroidStudio_shortcut_key/17-navigate-previous-changes.gif","hash":"fa0a177b3593df9198ba97914276137a5ce397e7","modified":1469708126764},{"_id":"source/_posts/AndroidStudio_shortcut_key/18-joinlines.gif","hash":"7d8b08bac9789385a5a2bf4a328073ceb67b7bde","modified":1469708126764},{"_id":"source/_posts/AndroidStudio_shortcut_key/21-togglebreakpoints.gif","hash":"54ede77b801de23d19b8f9c9df9f612048898408","modified":1469708126772},{"_id":"source/_posts/AndroidStudio_shortcut_key/24-temporarybreakpoints.gif","hash":"ed0f0fd21f89e0787521b0c25c27fb4cd0caf4a1","modified":1469708126780},{"_id":"source/_posts/AndroidStudio_shortcut_key/15-live_templates.gif","hash":"7f2f804937fd6c452c56f72187d1dc40aa30e74e","modified":1469708126764},{"_id":"source/_posts/AndroidStudio_shortcut_key/32-multiselection.gif","hash":"1806b83d743a4af60c67dcdaa99cc990955526d6","modified":1469708126792},{"_id":"source/_posts/AndroidStudio_shortcut_key/33-postfixcompletion.gif","hash":"9c866ec339a1ebe31a6339abd6b48f2f62ec0b7f","modified":1469708126792},{"_id":"source/_posts/AndroidStudio_shortcut_key/37-vcspopup.gif","hash":"328c55f8b36a8610a0f1e0b7861391d7af45732a","modified":1469708126796},{"_id":"source/_posts/AndroidStudio_shortcut_key/39-navigatetoparent.gif","hash":"7e00455793140948441327aca8a27ab1fbc25c71","modified":1469708126796},{"_id":"source/_posts/AndroidStudio_shortcut_key/41-lasttoolwindow.gif","hash":"622c978f289f0b8c2916976c1108e1f7e81d2fc6","modified":1469708126800},{"_id":"source/_posts/AndroidStudio_shortcut_key/44-parameterinfo.gif","hash":"c1d6214e7ac75d6a7671f008925d0bb9e8dcdb1e","modified":1469708126804},{"_id":"source/_posts/AndroidStudio_shortcut_key/45-codecompletionentertab.gif","hash":"b364aaac2429dd58720d832053f7db4cfc470dec","modified":1469708126804},{"_id":"source/_posts/AndroidStudio_shortcut_key/47-contextinfo.gif","hash":"d587a809652100395df75136231ede55fcedc429","modified":1469708126804},{"_id":"source/_posts/AndroidStudio_shortcut_key/48-refactorthis.png","hash":"fb90d1f4118c437c3650e6c9c5f6740b17070de8","modified":1469708126808},{"_id":"source/_posts/AndroidStudio_shortcut_key/54-inline.gif","hash":"1aecd2c078b2eac2c17d59084e32d693ef3fc45a","modified":1469708126812},{"_id":"source/_posts/AndroidStudio_shortcut_key/55-rename.gif","hash":"34ef7726d642a33cd37c7afc9b22c50d34acd049","modified":1469708126812},{"_id":"source/_posts/AndroidStudio_shortcut_key/studio-debug-settings-icon.png","hash":"e968ecfabfd1a20bbedd0833875aa263f51a1af9","modified":1469708126812},{"_id":"source/_posts/AndroidStudio_shortcut_key/summary1.png","hash":"d34c48716ea4d67409b92913e66920087388c509","modified":1469708126812},{"_id":"source/_posts/AndroidStudio_shortcut_key/summary_2.png","hash":"7ca9dc1ead58b11e871df5f1c04beeb3bc5da689","modified":1469708126812},{"_id":"source/_posts/Markdown_user_guide/guide-to-markdown-web-writing.png","hash":"a9ccaf67b2c85d547ecd304887d998dd473da935","modified":1468326679398},{"_id":"source/_posts/UML_learning_note/shili4.png","hash":"6a20f2b3a265a96abe51d6d0204c02b83368771a","modified":1469708126968},{"_id":"source/_posts/UML_learning_note/shili5.png","hash":"35a5ec431753a6c392d27eddaaf3cba76edf03e6","modified":1469708126976},{"_id":"source/_posts/UML_learning_note/shili6.jpg","hash":"b091abf4c3b0db5824d9ac70f8bc382e773abe21","modified":1469708126976},{"_id":"source/img/home-bg-o.jpg","hash":"990f6f9dd0ecb5348bfcc47305553d58c0d8f326","modified":1469708127036},{"_id":"themes/huxblog/layout/_partial/footer.ejs","hash":"5efbaea66b7d1774d822f79a161d76ad21d23b38","modified":1469708127052},{"_id":"themes/huxblog/layout/_partial/head.ejs","hash":"ff9ab730a69195fbf50979fcf899b02a912a3473","modified":1469708127052},{"_id":"themes/huxblog/layout/_partial/nav.ejs","hash":"4c905166c960852e9b9a3c9d5c680091e37b481f","modified":1466216495296},{"_id":"themes/huxblog/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1466216495296},{"_id":"themes/huxblog/source/css/font-awesome.min.css","hash":"b71d1c7c315b67c614563382d1c2a868ac14d729","modified":1468314342219},{"_id":"themes/huxblog/source/css/hux-blog.css","hash":"c1b0a32ad8075ac09d99fb4d64a9fbc84163abf8","modified":1466216495296},{"_id":"themes/huxblog/source/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1466216495296},{"_id":"themes/huxblog/source/css/syntax.styl","hash":"f3f9ff0d1ebc4f7fa18d7e367b2ba2f0899adbd4","modified":1466216495300},{"_id":"themes/huxblog/source/fonts/fontawesome-webfont.eot","hash":"0183979056f0b87616cd99d5c54a48f3b771eee6","modified":1468324893974},{"_id":"themes/huxblog/source/fonts/fontawesome-webfont.woff","hash":"7d65e0227d0d7cdc1718119cd2a7dce0638f151c","modified":1468324540774},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1466216495300},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1466216495300},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1466216495300},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1466216495300},{"_id":"themes/huxblog/source/js/hux-blog.js","hash":"0a1d60a3e4416ebdf3336e24e94187a78d471081","modified":1468478435222},{"_id":"themes/huxblog/source/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1466216495300},{"_id":"themes/huxblog/source/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1466216495300},{"_id":"themes/huxblog/source/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1466216495300},{"_id":"themes/huxblog/source/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1466216495300},{"_id":"source/about/index.md","hash":"efffab14a74920c4cd4646d2fa19fcc4aca4095a","modified":1469708127020},{"_id":"source/_posts/AndroidStudio_shortcut_key/02-move_between_methods.gif","hash":"f1b51488f24870c2de696621eb7062bebdc31cf8","modified":1469708126732},{"_id":"source/_posts/AndroidStudio_shortcut_key/03-filestructure.gif","hash":"94ff3c1404f2032ef91fad561b601d67eb6a1b51","modified":1469708126732},{"_id":"source/_posts/AndroidStudio_shortcut_key/19-select-in.gif","hash":"dc032ba09be553702c9bcde39e2e8bd475d26c1f","modified":1469708126764},{"_id":"source/_posts/AndroidStudio_shortcut_key/22-conditionalbreakpoint.gif","hash":"8e78623f5fe9a56798d922175019cded07e0fe0b","modified":1469708126772},{"_id":"source/_posts/AndroidStudio_shortcut_key/25-disablebreakpoint.gif","hash":"d31859e4a3db33911c7ed9ec02622c68558b18d2","modified":1469708126780},{"_id":"source/_posts/AndroidStudio_shortcut_key/28-mouse_evaluate_expression.gif","hash":"f4b7d4631566791d9515e0a8b976ae9050d72842","modified":1469708126780},{"_id":"source/_posts/AndroidStudio_shortcut_key/33-columnselection.gif","hash":"15144f102f81d570d88d43fb6a09ae056a8a8ac6","modified":1469708126792},{"_id":"source/_posts/AndroidStudio_shortcut_key/34-comparewithclipboard.gif","hash":"3aaed02b28391a0b0780514be373fdde500101e9","modified":1469708126792},{"_id":"source/_posts/AndroidStudio_shortcut_key/35-stoprocess.gif","hash":"2f65511a046b84319e3d7f912fb6f50d3965bd98","modified":1469708126792},{"_id":"source/_posts/AndroidStudio_shortcut_key/36-executionpoint.gif","hash":"31337e99cb1755912fca5b0ba70d6a6f5d695708","modified":1469708126796},{"_id":"source/_posts/AndroidStudio_shortcut_key/49-recentlyedited.gif","hash":"cb6176adecaba9274dbc2c05c8254df98f01a1c6","modified":1469708126808},{"_id":"source/_posts/AndroidStudio_shortcut_key/51-extractvariable.gif","hash":"9c1a20c172f3c9d0139cd865a7828beec24945de","modified":1469708126808},{"_id":"source/_posts/AndroidStudio_shortcut_key/52-extractparam.gif","hash":"ded64f76f3fbc577681d8fdda7f6ff946621b64c","modified":1469708126808},{"_id":"source/_posts/AndroidStudio_shortcut_key/migration_guide_save_settings.png","hash":"f89c131f75c4428ba0c4e45965a94c2efba3d55a","modified":1469708126812},{"_id":"source/_posts/AndroidStudio_shortcut_key/post-bg-androidstudio.jpg","hash":"e8f3739cb78ea6d1645665d07ebdb79881774fb6","modified":1469708126812},{"_id":"source/_posts/Markdown_user_guide/markdown-guide-1.jpg","hash":"1ab371279a3a22f43be16c2f49cd2f7e3dbf21a2","modified":1468326643430},{"_id":"source/_posts/UML_learning_note/what-is-uml.jpg","hash":"4d1f050dd72121bc5b0466ee047fec69a1534a10","modified":1469708126980},{"_id":"source/_posts/envsetup_common_command/post-bg-unix-linux.jpg","hash":"e8f3739cb78ea6d1645665d07ebdb79881774fb6","modified":1469708126980},{"_id":"themes/huxblog/source/css/bootstrap.min.css","hash":"973e37a8502921d56bc02bb55321f45b072b6f71","modified":1466216495296},{"_id":"themes/huxblog/source/fonts/fontawesome-webfont.ttf","hash":"6225ccc4ec94d060f19efab97ca42d842845b949","modified":1468324805306},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1466216495300},{"_id":"themes/huxblog/source/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1466216495300},{"_id":"themes/huxblog/source/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1466216495300},{"_id":"source/_posts/AndroidStudio_VS_eclipse/migration_guide_auto_scroll_from_source.png","hash":"4f161f0abd8bf1e2f760893e71d46c4aac14f0b0","modified":1469708126708},{"_id":"source/_posts/AndroidStudio_shortcut_key/40-returntoeditor.gif","hash":"6a169e4d67bd1c7de4fe161b211cff3f2f705c48","modified":1469708126796},{"_id":"source/_posts/AndroidStudio_shortcut_key/20-unwrap.gif","hash":"5a69c57abf84011a92733b2fda8d56649fc221d6","modified":1469708126772},{"_id":"source/img/contact-bg.jpg","hash":"f1161e144dabf93bd7dc896e46682d84987b28ee","modified":1468325583722},{"_id":"themes/huxblog/source/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1466216495296},{"_id":"source/_posts/AndroidStudio_shortcut_key/04-callinghierarchy.gif","hash":"e443e4a748ab294ee0614f02954b569e2a1abe5d","modified":1469708126744},{"_id":"source/_posts/AndroidStudio_shortcut_key/07-bookmarks.gif","hash":"33076fbff66dcb66c26e4ad5a98843c5a2fa03e7","modified":1469708126744},{"_id":"source/_posts/AndroidStudio_shortcut_key/27-evaluateexpression.gif","hash":"05a27baeeca7ed3dae8d97c40566d423a1500220","modified":1469708126780},{"_id":"source/_posts/AndroidStudio_shortcut_key/42-hideallwindows.gif","hash":"02bc942d7ac07a6f183365a4a38693a1c0fcf24e","modified":1469708126800},{"_id":"source/_posts/AndroidStudio_shortcut_key/46-switcher.gif","hash":"3e8c849b325b05cfc2ac917f013b5dbc7923e94f","modified":1469708126804},{"_id":"source/_posts/AndroidStudio_shortcut_key/53-extractmethod.gif","hash":"316258a2e84c44bfaf7742107decc6ef3fd7187b","modified":1469708126812},{"_id":"source/_posts/AndroidStudio_shortcut_key/56-pullupdown.gif","hash":"70131260ff92ff3b36c96aa142b1ce4e5012379d","modified":1469708126812},{"_id":"source/img/404-bg.jpg","hash":"2f2b9d28c1e88cf2ae9def86e0b5b2dec43171b8","modified":1468325583718},{"_id":"source/img/home-bg.jpg","hash":"6747a31d9b463684827dbd1c5eacb8d47613dd9a","modified":1468325583722},{"_id":"themes/huxblog/source/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1466216495300},{"_id":"source/_posts/AndroidStudio_shortcut_key/31-analyzedataflow.gif","hash":"e006a00a6a6164b36d800fe8164410a0bf9fe4f4","modified":1469708126792},{"_id":"source/_posts/AndroidStudio_VS_eclipse/migration_guide_debugger_1.png","hash":"6374bfd594ec029428605aa64fa1dd25a1ae6a06","modified":1469708126708},{"_id":"source/_posts/yunnan_in_my_heart/dali.jpg","hash":"ddc74c004feb294229a2286cdca5a58b3ad0d458","modified":1469708127000},{"_id":"source/img/about-bg.jpg","hash":"dd35479982bf5aabf38388f2d5d7346939ee7724","modified":1468325583718},{"_id":"source/_posts/AndroidStudio_shortcut_key/38-comparewithbranch.gif","hash":"bfc58a5ff9dd4b33f4b076ac9da7ce65decf5edc","modified":1469708126796},{"_id":"source/_posts/yunnan_in_my_heart/yunnanyinxiang.jpg","hash":"9fbab6390bfd3d524978adead5f03e7be68d0d33","modified":1469708127020},{"_id":"source/_posts/AndroidStudio_shortcut_key/30-analyzestacktrace.gif","hash":"3e91f1deb746d4f8e1d0513c9fcaa134816c1b18","modified":1469708126788},{"_id":"source/_posts/To_Commemorate_The_First_Anniversary_Of_Graduation/shiyanshi.jpg","hash":"1d54ac19a724b8edd990d55a89c2ba572ef7cac3","modified":1469708126948},{"_id":"source/_posts/yunnan_in_my_heart/lvxing.jpg","hash":"83ca06f4f927ef4851655717ca01b7b20116998c","modified":1469708127016},{"_id":"source/_posts/yunnan_in_my_heart/weihushan.JPG","hash":"5e825e2a91a401ee989b26c87efc050b290761d9","modified":1469708127016},{"_id":"source/_posts/AndroidStudio_VS_eclipse/post-bg-2015.jpg","hash":"2cdac12fdb5a0ef1e6e80c4b213c98f522c4b79a","modified":1469708126712},{"_id":"source/_posts/AndroidStudio_shortcut_key/43-openpanelbynumber.gif","hash":"96ea257a107674ae47c490169d7781a334ca8189","modified":1469708126804},{"_id":"source/_posts/AndroidStudio_shortcut_key/23-loggingbreakpoints.gif","hash":"de01475684333cfda0be927f655faaa1984d9619","modified":1469708126780},{"_id":"source/_posts/To_Commemorate_The_First_Anniversary_Of_Graduation/jucan.JPG","hash":"5f3645257804e44a68b7d30646290da528de2513","modified":1469708126916},{"_id":"source/_posts/AndroidStudio_shortcut_key/29-markobject.gif","hash":"ef50bab69e8050ee0737f5dbbd32e846f23a55cf","modified":1469708126788},{"_id":"source/_posts/To_Commemorate_The_First_Anniversary_Of_Graduation/qiqihaer.jpg","hash":"b98bf120e619867f2f55405e894e2a9686d4794f","modified":1469708126932},{"_id":"source/_posts/To_Commemorate_The_First_Anniversary_Of_Graduation/beijing.jpg","hash":"f03b1ce77c50e1bea364cc95b495c0e0442c8ecf","modified":1469708126892},{"_id":"source/_posts/To_Commemorate_The_First_Anniversary_Of_Graduation/graduation.jpg","hash":"75ae2058a250c200129047eee52b669fbfa3a33f","modified":1469708126908},{"_id":"source/_posts/AndroidStudySource/android-study-source-bg.png","hash":"9b436d24250cc7a501f587f60c9658ef1f219a76","modified":1469708126840},{"_id":"source/_posts/AndroidStudySource/android-study-source-bg1.jpeg","hash":"e2c864be1f24ca100d453b0c3a78cb77051b1998","modified":1469708126856},{"_id":"public/404.html","hash":"5e087199b96b4a449cf9cd1d1cef725c77b4e9ad","modified":1470150010612},{"_id":"public/archives/index.html","hash":"8b2cf793cd91caaaca0f83f1d1d6de0b3757cd6e","modified":1470150010612},{"_id":"public/archives/2016/index.html","hash":"54047fedb445400ffc0558622c255adee51ad12c","modified":1470150010613},{"_id":"public/archives/2016/03/index.html","hash":"23863bee0b1b0eea3e8663d39734c9343968da1a","modified":1470150010613},{"_id":"public/archives/2016/04/index.html","hash":"9c5d17245ba90959d729da7994887697866a0e12","modified":1470150010613},{"_id":"public/archives/2016/05/index.html","hash":"7b202167be885142dd91582eade8a064d7993e4e","modified":1470150010613},{"_id":"public/archives/2016/06/index.html","hash":"48b458d95367e852d0903ca0d590dbc46ef69ff4","modified":1470150010613},{"_id":"public/archives/2016/07/index.html","hash":"23f85e167e10987089f8a93bfcc326857e650d5e","modified":1470150010613},{"_id":"public/archives/2016/08/index.html","hash":"a2c1af2bef4ae454c15cf57a966ca753f5ffdbd5","modified":1470150010613},{"_id":"public/tags/AndroidStudio/index.html","hash":"bac44a6fa0b4845e4f79f35be91741c861c05725","modified":1470150010613},{"_id":"public/tags/开源项目/index.html","hash":"4b8cff7bc753868ef99d554202526d8c86e9e712","modified":1470150010613},{"_id":"public/tags/Android/index.html","hash":"8aea24501d721d0cb2a2663002278ba3dfd29c8a","modified":1470150010613},{"_id":"public/tags/Markdown/index.html","hash":"389dafe80b80c21687ca178020158635a94b704d","modified":1470150010613},{"_id":"public/tags/感悟/index.html","hash":"f245eeb992dd6e99111721d27a39f4fa9245076d","modified":1470150010613},{"_id":"public/tags/UML/index.html","hash":"cb7430182b2f22dcd8779bf4f32098130dcfd2d3","modified":1470150010613},{"_id":"public/tags/Java/index.html","hash":"2c72b075f6a6b7563ecfd1309d101b0cb54ecf1a","modified":1470150010613},{"_id":"public/tags/index.html","hash":"da6e297933e22ff6ae246c91ccc279dad96928dd","modified":1470150010614},{"_id":"public/2016/08/02/annotation_learning/index.html","hash":"cb6e8f514e3e1369e12a849d76d982ff3d29eb2e","modified":1470150010614},{"_id":"public/2016/07/21/Logger_analyse/index.html","hash":"6e4e725c314bafa067ba157b33c1fe8292379ed9","modified":1470150010614},{"_id":"public/2016/07/18/yunnan_in_my_heart/index.html","hash":"13ebe733ce4b006001e9ec13aee5c855530fdb39","modified":1470150010614},{"_id":"public/2016/07/15/To_Commemorate_The_First_Anniversary_Of_Graduation/index.html","hash":"79775f6976ad3561ed8c1e8b616ae912f1324bac","modified":1470150010614},{"_id":"public/2016/07/12/UML_learning_note/index.html","hash":"be3d95f74b13fcaf0d87ae575e2b1a03d0603239","modified":1470150010614},{"_id":"public/2016/07/12/Markdown_user_guide/index.html","hash":"2411d781b297959d6f07c3b10498ef4c90857441","modified":1470150010614},{"_id":"public/2016/06/20/AndroidStudySource/index.html","hash":"2dad39a158cc75c1d2b50391171fe6359c1ed3b9","modified":1470150010614},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/index.html","hash":"41c442da0a9a05a423d15d673a7100822774c607","modified":1470150010614},{"_id":"public/2016/04/19/AndroidStudio_VS_eclipse/index.html","hash":"87a185fbadc0217c5a074a8aa37346baac8a4e8c","modified":1470150010614},{"_id":"public/2016/03/10/envsetup_common_command/index.html","hash":"718f332d0e9b87ff908bdb7b80c19d472e4b8c23","modified":1470150010614},{"_id":"public/about/index.html","hash":"ef51be5121e4bc91a007529737e943705af38939","modified":1470150010614},{"_id":"public/index.html","hash":"8c8ed3fd5c90f1029ec822ed265b9cad85e9f375","modified":1470150010614},{"_id":"public/CNAME","hash":"3278c9d7d4882edeeac323f4c59d874c13a7fbc3","modified":1470150010625},{"_id":"public/img/avatar.jpg","hash":"44988594e1a6bcdc2ba5e5a13a641b854f1959b1","modified":1470150010625},{"_id":"public/img/icon_wechat.jpg","hash":"06159dc41c093fae4709ad6b21a095e380f9fee3","modified":1470150010625},{"_id":"public/fonts/fontawesome-webfont.eot","hash":"0183979056f0b87616cd99d5c54a48f3b771eee6","modified":1470150010625},{"_id":"public/fonts/fontawesome-webfont.woff","hash":"7d65e0227d0d7cdc1718119cd2a7dce0638f151c","modified":1470150010625},{"_id":"public/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1470150010625},{"_id":"public/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1470150010625},{"_id":"public/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1470150010625},{"_id":"public/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1470150010625},{"_id":"public/2016/07/12/Markdown_user_guide/guide-to-markdown-web-writing.png","hash":"a9ccaf67b2c85d547ecd304887d998dd473da935","modified":1470150010625},{"_id":"public/2016/07/12/UML_learning_note/shili4.png","hash":"6a20f2b3a265a96abe51d6d0204c02b83368771a","modified":1470150010625},{"_id":"public/2016/07/12/UML_learning_note/shili5.png","hash":"35a5ec431753a6c392d27eddaaf3cba76edf03e6","modified":1470150010625},{"_id":"public/2016/07/12/UML_learning_note/shili6.jpg","hash":"b091abf4c3b0db5824d9ac70f8bc382e773abe21","modified":1470150010625},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/01-highlight.gif","hash":"37549fd11fc845ff645d944c89d1851a903c9d07","modified":1470150010625},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/05-quickdefinition.gif","hash":"f957bb5ffd41f83d1dd5dbb0bca615239cd9e132","modified":1470150010625},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/06-codefolding.gif","hash":"1a0e34fca50e49b84c3da96fab2748b4212350e6","modified":1470150010625},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/10-deleteline.gif","hash":"be20980597f6cf38356fc8313902dda3bc4176de","modified":1470150010625},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/09-movelines.gif","hash":"b49af57e70b4a4f86172da75e797a5fc6c202892","modified":1470150010625},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/11-duplicate_lines.gif","hash":"34fcaa4e84dca6da0c23bd9b5ccbd850bde040a0","modified":1470150010625},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/08-findaction.gif","hash":"dc22d7155601cba04a32d760c26d19570211145e","modified":1470150010625},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/12-expand_shrink_selection.gif","hash":"0c21407236f89283af4f9255cb4de5bbcf0490a0","modified":1470150010625},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/13-surround_with.gif","hash":"fa49968f10f4fcc509dc8c470d008b5723069fe2","modified":1470150010625},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/14-recents.gif","hash":"58ee2d99743fcd34cab010c699d7274f1004dafe","modified":1470150010625},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/15-live_templates.gif","hash":"7f2f804937fd6c452c56f72187d1dc40aa30e74e","modified":1470150010625},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/15-movemethods.gif","hash":"469b3a9f284770e034d6226969739881fc74afec","modified":1470150010626},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/16-completestatement.gif","hash":"a7242a57ebe112b455e855f31c29193002f7ce03","modified":1470150010626},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/17-navigate-previous-changes.gif","hash":"fa0a177b3593df9198ba97914276137a5ce397e7","modified":1470150010626},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/18-joinlines.gif","hash":"7d8b08bac9789385a5a2bf4a328073ceb67b7bde","modified":1470150010626},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/21-togglebreakpoints.gif","hash":"54ede77b801de23d19b8f9c9df9f612048898408","modified":1470150010626},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/24-temporarybreakpoints.gif","hash":"ed0f0fd21f89e0787521b0c25c27fb4cd0caf4a1","modified":1470150010626},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/32-multiselection.gif","hash":"1806b83d743a4af60c67dcdaa99cc990955526d6","modified":1470150010626},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/33-postfixcompletion.gif","hash":"9c866ec339a1ebe31a6339abd6b48f2f62ec0b7f","modified":1470150010626},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/37-vcspopup.gif","hash":"328c55f8b36a8610a0f1e0b7861391d7af45732a","modified":1470150010626},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/39-navigatetoparent.gif","hash":"7e00455793140948441327aca8a27ab1fbc25c71","modified":1470150010626},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/41-lasttoolwindow.gif","hash":"622c978f289f0b8c2916976c1108e1f7e81d2fc6","modified":1470150010626},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/44-parameterinfo.gif","hash":"c1d6214e7ac75d6a7671f008925d0bb9e8dcdb1e","modified":1470150010626},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/45-codecompletionentertab.gif","hash":"b364aaac2429dd58720d832053f7db4cfc470dec","modified":1470150010626},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/47-contextinfo.gif","hash":"d587a809652100395df75136231ede55fcedc429","modified":1470150010626},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/48-refactorthis.png","hash":"fb90d1f4118c437c3650e6c9c5f6740b17070de8","modified":1470150010626},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/54-inline.gif","hash":"1aecd2c078b2eac2c17d59084e32d693ef3fc45a","modified":1470150010626},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/55-rename.gif","hash":"34ef7726d642a33cd37c7afc9b22c50d34acd049","modified":1470150010627},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/studio-debug-settings-icon.png","hash":"e968ecfabfd1a20bbedd0833875aa263f51a1af9","modified":1470150010627},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/summary1.png","hash":"d34c48716ea4d67409b92913e66920087388c509","modified":1470150010627},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/summary_2.png","hash":"7ca9dc1ead58b11e871df5f1c04beeb3bc5da689","modified":1470150010627},{"_id":"public/img/favicon.ico","hash":"5228c9322413d7f677d67685502b9efdfdc3b953","modified":1470150010815},{"_id":"public/img/tag-bg.jpg","hash":"8844274a812ae19e8f2a3b7e4e465342e63eb852","modified":1470150010815},{"_id":"public/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1470150010817},{"_id":"public/fonts/fontawesome-webfont.ttf","hash":"6225ccc4ec94d060f19efab97ca42d842845b949","modified":1470150010817},{"_id":"public/2016/03/10/envsetup_common_command/post-bg-unix-linux.jpg","hash":"e8f3739cb78ea6d1645665d07ebdb79881774fb6","modified":1470150010817},{"_id":"public/2016/07/12/Markdown_user_guide/markdown-guide-1.jpg","hash":"1ab371279a3a22f43be16c2f49cd2f7e3dbf21a2","modified":1470150010817},{"_id":"public/2016/07/12/UML_learning_note/what-is-uml.jpg","hash":"4d1f050dd72121bc5b0466ee047fec69a1534a10","modified":1470150010817},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/02-move_between_methods.gif","hash":"f1b51488f24870c2de696621eb7062bebdc31cf8","modified":1470150010817},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/03-filestructure.gif","hash":"94ff3c1404f2032ef91fad561b601d67eb6a1b51","modified":1470150010817},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/19-select-in.gif","hash":"dc032ba09be553702c9bcde39e2e8bd475d26c1f","modified":1470150010817},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/22-conditionalbreakpoint.gif","hash":"8e78623f5fe9a56798d922175019cded07e0fe0b","modified":1470150010817},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/25-disablebreakpoint.gif","hash":"d31859e4a3db33911c7ed9ec02622c68558b18d2","modified":1470150010817},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/28-mouse_evaluate_expression.gif","hash":"f4b7d4631566791d9515e0a8b976ae9050d72842","modified":1470150010817},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/33-columnselection.gif","hash":"15144f102f81d570d88d43fb6a09ae056a8a8ac6","modified":1470150010817},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/35-stoprocess.gif","hash":"2f65511a046b84319e3d7f912fb6f50d3965bd98","modified":1470150010817},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/34-comparewithclipboard.gif","hash":"3aaed02b28391a0b0780514be373fdde500101e9","modified":1470150010817},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/36-executionpoint.gif","hash":"31337e99cb1755912fca5b0ba70d6a6f5d695708","modified":1470150010818},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/49-recentlyedited.gif","hash":"cb6176adecaba9274dbc2c05c8254df98f01a1c6","modified":1470150010818},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/51-extractvariable.gif","hash":"9c1a20c172f3c9d0139cd865a7828beec24945de","modified":1470150010818},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/52-extractparam.gif","hash":"ded64f76f3fbc577681d8fdda7f6ff946621b64c","modified":1470150010818},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/migration_guide_save_settings.png","hash":"f89c131f75c4428ba0c4e45965a94c2efba3d55a","modified":1470150010818},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/post-bg-androidstudio.jpg","hash":"e8f3739cb78ea6d1645665d07ebdb79881774fb6","modified":1470150010818},{"_id":"public/css/syntax.css","hash":"4616879fec214c9cc4f5835615348f0bbeabf2a9","modified":1470150010826},{"_id":"public/js/hux-blog.js","hash":"0a1d60a3e4416ebdf3336e24e94187a78d471081","modified":1470150010826},{"_id":"public/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1470150010826},{"_id":"public/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1470150010826},{"_id":"public/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1470150010826},{"_id":"public/css/hux-blog.css","hash":"c1b0a32ad8075ac09d99fb4d64a9fbc84163abf8","modified":1470150010826},{"_id":"public/css/font-awesome.min.css","hash":"b71d1c7c315b67c614563382d1c2a868ac14d729","modified":1470150010826},{"_id":"public/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1470150010826},{"_id":"public/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1470150010826},{"_id":"public/css/bootstrap.min.css","hash":"973e37a8502921d56bc02bb55321f45b072b6f71","modified":1470150010826},{"_id":"public/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1470150010826},{"_id":"public/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1470150010827},{"_id":"public/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1470150010827},{"_id":"public/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1470150010827},{"_id":"public/img/home-bg-o.jpg","hash":"990f6f9dd0ecb5348bfcc47305553d58c0d8f326","modified":1470150010827},{"_id":"public/2016/04/19/AndroidStudio_VS_eclipse/migration_guide_auto_scroll_from_source.png","hash":"4f161f0abd8bf1e2f760893e71d46c4aac14f0b0","modified":1470150010827},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/40-returntoeditor.gif","hash":"6a169e4d67bd1c7de4fe161b211cff3f2f705c48","modified":1470150010827},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/20-unwrap.gif","hash":"5a69c57abf84011a92733b2fda8d56649fc221d6","modified":1470150010828},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/04-callinghierarchy.gif","hash":"e443e4a748ab294ee0614f02954b569e2a1abe5d","modified":1470150010838},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/27-evaluateexpression.gif","hash":"05a27baeeca7ed3dae8d97c40566d423a1500220","modified":1470150010838},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/07-bookmarks.gif","hash":"33076fbff66dcb66c26e4ad5a98843c5a2fa03e7","modified":1470150010838},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/42-hideallwindows.gif","hash":"02bc942d7ac07a6f183365a4a38693a1c0fcf24e","modified":1470150010838},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/46-switcher.gif","hash":"3e8c849b325b05cfc2ac917f013b5dbc7923e94f","modified":1470150010838},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/53-extractmethod.gif","hash":"316258a2e84c44bfaf7742107decc6ef3fd7187b","modified":1470150010838},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/56-pullupdown.gif","hash":"70131260ff92ff3b36c96aa142b1ce4e5012379d","modified":1470150010838},{"_id":"public/img/contact-bg.jpg","hash":"f1161e144dabf93bd7dc896e46682d84987b28ee","modified":1470150010845},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/31-analyzedataflow.gif","hash":"e006a00a6a6164b36d800fe8164410a0bf9fe4f4","modified":1470150010845},{"_id":"public/2016/04/19/AndroidStudio_VS_eclipse/migration_guide_debugger_1.png","hash":"6374bfd594ec029428605aa64fa1dd25a1ae6a06","modified":1470150010845},{"_id":"public/2016/07/18/yunnan_in_my_heart/dali.jpg","hash":"ddc74c004feb294229a2286cdca5a58b3ad0d458","modified":1470150010846},{"_id":"public/img/404-bg.jpg","hash":"2f2b9d28c1e88cf2ae9def86e0b5b2dec43171b8","modified":1470150010850},{"_id":"public/img/home-bg.jpg","hash":"6747a31d9b463684827dbd1c5eacb8d47613dd9a","modified":1470150010850},{"_id":"public/img/about-bg.jpg","hash":"dd35479982bf5aabf38388f2d5d7346939ee7724","modified":1470150010855},{"_id":"public/2016/07/18/yunnan_in_my_heart/yunnanyinxiang.jpg","hash":"9fbab6390bfd3d524978adead5f03e7be68d0d33","modified":1470150010855},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/38-comparewithbranch.gif","hash":"bfc58a5ff9dd4b33f4b076ac9da7ce65decf5edc","modified":1470150010856},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/30-analyzestacktrace.gif","hash":"3e91f1deb746d4f8e1d0513c9fcaa134816c1b18","modified":1470150010861},{"_id":"public/2016/07/18/yunnan_in_my_heart/weihushan.JPG","hash":"5e825e2a91a401ee989b26c87efc050b290761d9","modified":1470150010866},{"_id":"public/2016/07/18/yunnan_in_my_heart/lvxing.jpg","hash":"83ca06f4f927ef4851655717ca01b7b20116998c","modified":1470150010866},{"_id":"public/2016/07/15/To_Commemorate_The_First_Anniversary_Of_Graduation/shiyanshi.jpg","hash":"1d54ac19a724b8edd990d55a89c2ba572ef7cac3","modified":1470150010867},{"_id":"public/2016/04/19/AndroidStudio_VS_eclipse/post-bg-2015.jpg","hash":"2cdac12fdb5a0ef1e6e80c4b213c98f522c4b79a","modified":1470150010870},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/43-openpanelbynumber.gif","hash":"96ea257a107674ae47c490169d7781a334ca8189","modified":1470150010870},{"_id":"public/2016/07/15/To_Commemorate_The_First_Anniversary_Of_Graduation/jucan.JPG","hash":"5f3645257804e44a68b7d30646290da528de2513","modified":1470150010874},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/23-loggingbreakpoints.gif","hash":"de01475684333cfda0be927f655faaa1984d9619","modified":1470150010874},{"_id":"public/2016/07/15/To_Commemorate_The_First_Anniversary_Of_Graduation/qiqihaer.jpg","hash":"b98bf120e619867f2f55405e894e2a9686d4794f","modified":1470150010876},{"_id":"public/2016/05/03/AndroidStudio_shortcut_key/29-markobject.gif","hash":"ef50bab69e8050ee0737f5dbbd32e846f23a55cf","modified":1470150010876},{"_id":"public/2016/07/15/To_Commemorate_The_First_Anniversary_Of_Graduation/beijing.jpg","hash":"f03b1ce77c50e1bea364cc95b495c0e0442c8ecf","modified":1470150010880},{"_id":"public/2016/07/15/To_Commemorate_The_First_Anniversary_Of_Graduation/graduation.jpg","hash":"75ae2058a250c200129047eee52b669fbfa3a33f","modified":1470150010880},{"_id":"public/2016/06/20/AndroidStudySource/android-study-source-bg.png","hash":"9b436d24250cc7a501f587f60c9658ef1f219a76","modified":1470150010883},{"_id":"public/2016/06/20/AndroidStudySource/android-study-source-bg1.jpeg","hash":"e2c864be1f24ca100d453b0c3a78cb77051b1998","modified":1470150010886}],"Category":[],"Data":[],"Page":[{"layout":"404","description":"你来到了没有知识的荒原 :(","header-img":"img/404-bg.jpg","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"你来到了没有知识的荒原 :(\"\nheader-img: \"img/404-bg.jpg\"\n---\n","date":"2016-06-18T02:21:35.244Z","updated":"2016-06-18T02:21:35.244Z","path":"404.html","title":"","comments":1,"_id":"cirdlcvao0000252n1hfmk7qk","content":"","excerpt":"","more":""},{"layout":"tags","title":"Tags","description":"Hey, this is Tags.","header-img":"img/tag-bg.jpg","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"Tags\"\ndescription: \"Hey, this is Tags.\"\nheader-img: \"img/tag-bg.jpg\"\n---\n","date":"2016-06-18T02:21:35.296Z","updated":"2016-06-18T02:21:35.296Z","path":"tags/index.html","comments":1,"_id":"cirdlcvd9000v252ndrloulhr","content":"","excerpt":"","more":""},{"layout":"about","title":"About Me","date":"2016-06-16T05:48:33.000Z","description":"Hey, this is jianguo.","header-img":"img/about-bg.jpg","_content":"\n\n> 酷爱技术，懂点摄影，乐于探索\n> 希望在这个世界遇到更好的你。\n\nAndroid攻城师一枚(Android engineer at [thundersoft.Inc](http://www.thundersoft.com), Beijing)\n\n### 关注(Focus)\n1. Android,Java,Python,AI,Machin Learning\n2. Internet of things,Intelligent devices.\n3. 摄影，影像\n\n### 联系我(contact)\n\nGitHub: [lgyjg](https://github.com/lgyjg)\n微博: [HelloVirtualWorld](http://weibo.com/lgyjg)\n知乎: [杨建国](https://www.zhihu.com/people/yang-jian-guo-51)\n\n\n\n\n","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"About Me\"\ndate: 2016-06-16 13:48:33\ndescription: \"Hey, this is jianguo.\"\nheader-img: \"img/about-bg.jpg\"\n---\n\n\n> 酷爱技术，懂点摄影，乐于探索\n> 希望在这个世界遇到更好的你。\n\nAndroid攻城师一枚(Android engineer at [thundersoft.Inc](http://www.thundersoft.com), Beijing)\n\n### 关注(Focus)\n1. Android,Java,Python,AI,Machin Learning\n2. Internet of things,Intelligent devices.\n3. 摄影，影像\n\n### 联系我(contact)\n\nGitHub: [lgyjg](https://github.com/lgyjg)\n微博: [HelloVirtualWorld](http://weibo.com/lgyjg)\n知乎: [杨建国](https://www.zhihu.com/people/yang-jian-guo-51)\n\n\n\n\n","updated":"2016-07-28T12:15:27.020Z","path":"about/index.html","comments":1,"_id":"cirdlcvf2000w252n2bo2z2sj","content":"<blockquote>\n<p>酷爱技术，懂点摄影，乐于探索<br>希望在这个世界遇到更好的你。</p>\n</blockquote>\n<p>Android攻城师一枚(Android engineer at <a href=\"http://www.thundersoft.com\" target=\"_blank\" rel=\"external\">thundersoft.Inc</a>, Beijing)</p>\n<h3 id=\"关注-Focus\"><a href=\"#关注-Focus\" class=\"headerlink\" title=\"关注(Focus)\"></a>关注(Focus)</h3><ol>\n<li>Android,Java,Python,AI,Machin Learning</li>\n<li>Internet of things,Intelligent devices.</li>\n<li>摄影，影像</li>\n</ol>\n<h3 id=\"联系我-contact\"><a href=\"#联系我-contact\" class=\"headerlink\" title=\"联系我(contact)\"></a>联系我(contact)</h3><p>GitHub: <a href=\"https://github.com/lgyjg\" target=\"_blank\" rel=\"external\">lgyjg</a><br>微博: <a href=\"http://weibo.com/lgyjg\" target=\"_blank\" rel=\"external\">HelloVirtualWorld</a><br>知乎: <a href=\"https://www.zhihu.com/people/yang-jian-guo-51\" target=\"_blank\" rel=\"external\">杨建国</a></p>\n","excerpt":"","more":"<blockquote>\n<p>酷爱技术，懂点摄影，乐于探索<br>希望在这个世界遇到更好的你。</p>\n</blockquote>\n<p>Android攻城师一枚(Android engineer at <a href=\"http://www.thundersoft.com\">thundersoft.Inc</a>, Beijing)</p>\n<h3 id=\"关注-Focus\"><a href=\"#关注-Focus\" class=\"headerlink\" title=\"关注(Focus)\"></a>关注(Focus)</h3><ol>\n<li>Android,Java,Python,AI,Machin Learning</li>\n<li>Internet of things,Intelligent devices.</li>\n<li>摄影，影像</li>\n</ol>\n<h3 id=\"联系我-contact\"><a href=\"#联系我-contact\" class=\"headerlink\" title=\"联系我(contact)\"></a>联系我(contact)</h3><p>GitHub: <a href=\"https://github.com/lgyjg\">lgyjg</a><br>微博: <a href=\"http://weibo.com/lgyjg\">HelloVirtualWorld</a><br>知乎: <a href=\"https://www.zhihu.com/people/yang-jian-guo-51\">杨建国</a></p>\n"}],"Post":[{"layout":"post","title":"AndroidStudio快捷键大全","subtitle":"介绍AndroidStudio常用的快捷键功能，收集了所有的Android Studio Tips Of the Day的内容","date":"2016-05-03T10:18:18.000Z","author":"JianGuo Yang","header-img":"post-bg-androidstudio.jpg","_content":"\n\n## 高亮所有\nos X: ** command + shift + F7  **  \nWindows Or Linux: ** ctrl+Shift+F7 **  \n\n![hight light all](01-highlight.gif)\n* 高亮代码方法中的“return” 或者 “throw” 也会高亮这个方法的所有出口。\n* 高亮后可使用\"F3\"或“shift + F3”上下选择。\n* Esc 或者再次使用该快捷键，可以取消高亮。\n\n<!--more-->\n\n## 在方法和内部类之间跳转\nOS X: ** Ctrl + ↑ / ↓ **  \nWindows Or Linux: ** Alt+ ↑ / ↓**  \n\n![02-move_between_methods](02-move_between_methods.gif)\n\n## 跳转到已经打开的下一个/上一个文件\nOS X: ** Ctrl + ← / → **  \nWindows Or Linux: ** Alt+  ← / →**  \n\n## 快速定位到类中的方法/内部类/成员变量\nOS X: ** Command+F12**  \nWindows Or Linux: ** Ctrl+F12 **   \n\n![03-filestructure](03-filestructure.gif)\n* 你可以使用驼峰字符来过滤候选方法列表。例如:输入 “oCr” 就可以找到 “onCreate”方法。\n* 你可以选择是否展示继承的成员变量。如勾选了\"show inherited members\"就可以很方便的查找继承自父类的成员变量。\n* 你可以选择是否展示匿名类。如勾选了\"show Anonymous classes\", 就可以很方便的查找 OnClickListener里面的OnClick方法了。\n\n## 显示方法的调用层级关系\nOS X: ** Ctrl+Alt+H **  \nWindows Or Linux: ** Ctrl+Alt+H **  \n\n![04-callinghierarchy](04-callinghierarchy.gif)\n> 注，ubuntu上与输入法快捷键冲突无法使用\n\n## 快速显示变量或方法的定义\nOS X: ** Alt+Space**  \nWindows Or Linux: ** Ctrl+Shift+i**  \n如果你想立马知道某个类或者方法的来源同时又不想丢掉当前的编码环境，你可以试试这个快捷键。  \n\n![05-quickdefinition](05-quickdefinition.gif)\n\n## 快速收缩或者展开代码块\nOS X : ** Alt + +/- **  \nWindows Or Linux: ** Ctrl +/- **\n\n![06-codefolding](06-codefolding.gif)\n\n* 可以使用 Ctrl + Shift +/- ** 收缩或者展开文件中的所有方法\n* 多次使用会逐级收缩或者展开\n> 你可以在“Editor → Code Folding”自定义你的代码折叠范围\n\n## 书签\n### 默认书签\nOS X : ** F3 **   \nWindows Or Linux : ** F11 **\n### 带字母或者数字的标签\nOS X : ** Alt+F3 **  \nWindows Or Linux : ** Ctrl+F11 **   \n> 按下此快捷键就可以在你的当前光标所在行打上标签，并提供字母或者数字标记。如果你选择的是数字标记，那么可以通过ctrl+对应的数字直接跳转至相应位置。  \n\n### 展示标签\nOS X : ** Command+F3**  \nWindows Or Linux : ** Shift+F11**  \n\n![07-bookmarks](07-bookmarks.gif)\n\n## 查找Android Studio的菜单选项\nOS X :   ** Command+Shift+A**  \nWindows Or Linux : ** Ctrl+Shift+A**  \n你可以通过输入菜单名来查找任意的菜单选项，这对那些使用频率低的操作很有效果。\n\n![08-findaction](08-findaction.gif)\n\n> 如果这个选项有对应的快捷方式，那么这个快捷键会在列表旁边显示。  \n\n## 行操作\n----\n### 移动整行\nOS X : ** Alt+Shift+ ↑ / ↓**   \nWindows Or Linux: ** Alt+Shift+ ↑ / ↓**  \n\n![09-movelines](09-movelines.gif)\n\n### 代码行合并\nMac OS : ** Ctrl+Shift+j **  \nWindows & Linux : ** Ctrl+Shift+j **  \n按照语法规则将可以合并的代码行进行合并，保持代码精简。它主要适用以下规则：  \n* 将变量声明定义和赋值合并;\n* 合并多行字符串的时候，会移掉“+“和双引号;\n* 合并两行评论代码时，评论变成一行，会去掉另一行的“//”;\n\n![18-joinlines](18-joinlines.gif)\n\n### 删除整行\nOS X : ** Command + Backspace**  \nWindows Or Linux : ** Ctrl + Y**  \n\n![10-deleteline](10-deleteline.gif)\n\n### 复制整行\nMac OS: ** Command+D**  \nWindows & Linux: ** Ctrl+D**  \n这个快捷键的厉害之处在于它会复制当前行同时又不会影响系统的剪贴板。\n![11-duplicate_lines](11-duplicate_lines.gif)\n\n----\n\n## 上下移动整个方法\nMac OS : ** Command+Alt+↑/↓ **  \nWindows & Linux : ** Ctrl+Shift+↑/↓ **  \n\n![15-movemethods](15-movemethods.gif)\n\n\n## 展开或者收缩选择区域\nMac OS : ** alt + ↑/↓ **  \nWindows & Linux: ** (Ctrl+w )/(Ctrl+Shift+w) **   \n扩大（或者缩小）当前的选择范围。比如当前选中一个变量，此操作会把选中范围扩展至句子，方法等。\n\n![12-expand_shrink_selection](12-expand_shrink_selection.gif)\n\n## 包裹代码段\nMac OS : ** Command+Alt+t **  \nWindows & Linux : ** Ctrl+Alt+t **  \n选中一段代码段，然后使用if语句或者循环结构等包裹代码。  \n\n![13-surround_with.gif](13-surround_with.gif)  \n## 删除代码块的包裹\nMac OS : ** Command+Shift+Delete **  \nWindows & Linux : ** Ctrl+Shift+Delete **\n移除代码结构中的包裹代码，比如 if 语句,  while 循环, 或者 try/catch 语句。\n![20-unwrap](20-unwrap.gif)\n\n## 查询最近编辑的文件和使用的工作区\nMac OS : ** Command+e **  \nWindows & Linux : ** Ctrl+e **  \n\n![14-recents](14-recents.gif)\n\n## 代码模板\nMac OS : ** Command+j **  \nWindows & Linux : ** Ctrl+j **  \n此快捷键可以让你迅速地在文件中插入预留的代码片段。你也可以定制你自己的代码片段。\n\n![15-live_templates](15-live_templates.gif)\n\n## 代码结构自动补全\nMac OS : ** Command+Shift+Enter **  \nWindows & Linux : ** Ctrl+Shift+Enter **  \n这个操作会将还未完成的代码结构补全。一般可以补全的情形如下：\n\n* 在代码行后面添加分号；\n* 为 if, while 或者 for 语句添加括号\n* 为方法声明添加括号。\n\n![16-completestatement](16-completestatement.gif)\n\n## 回到上次编辑的位置\nMac OS : ** Command+Shift+backspace **  \nWindows & Linux : ** Ctrl+Shift+backspace **  \n\n![17-navigate-previous-changes](17-navigate-previous-changes.gif)\n\n## 在代码中根据标签选择功能（Select In）\nMac OS : ** Alt+F1 **  \nWindows:** Alt+F1 **  \nLinux : 与系统快捷键冲突\n在代码中执行此快捷方式可以快速定位到select Target所示的功能中。\n\n![19-select-in](19-select-in.gif)\n\n## 调试常用快捷键\n\n----\n\n### 添加断点（Toggle Breakpoints）\nOSX: ** Cmd+F8 **  \nWindows/Linux: ** Ctrl+F8 **  \n相应大家都知道使用鼠标左键点击行首添加断点，使用快捷键添加断点的方式如下：\n![21-togglebreakpoints](21-togglebreakpoints.gif)\n\n### 条件断点（Conditional Breakpoints）\n通过右键断点，可以对一个断点加入条件。只有当满足条件时，才会进入到断点中。调试神技，只对自己关心的情况进行调试，不浪费时间。\n\n![22-conditionalbreakpoint](22-conditionalbreakpoint.gif)\n\n### 在断点上打log\n如果你不想在调试过程中添加log，并且重新编译，可以在断点直接打log，查看结果。\n鼠标右键点击断点，取消选择“suspend”,并在 “Log evaluated Expression” 中输入你想要打印的log信息。实例如下：  \n![23-loggingbreakpoints](23-loggingbreakpoints.gif)\n\n### 临时断点\n鼠标（ubuntu上无效）：** Alt+LeftClick ** in the left gutter  \nMac: ** Cmd+Alt+Shift+F8 **  \nWindows/Linux: ** Ctrl+Alt+Shift+F8 **  \n这种方式可以添加一个临时断点，当第一次执行完后，会自动消失。\n\n### disable断点\n在已经完成了一些条件，或者打印了断点，不再需要这些断点的时候，你可以使这些断点无效。  \nMouse(ubuntu 上无效):在已经存在的断点上按住ALT并点击左键： ** Alt+LeftClick **   \n> 没有默认的快捷键，如果需要的话，可以创建快捷键。\n\n![25-disablebreakpoint](25-disablebreakpoint.gif)\n\n### 附加调试器\n及时你没有在调试模式下启动app，你也可以通过以下方式开启调试器。你不需要重新在调试模式下调用app。这是非常有用的。  \nMouse: 点击图标，选择“ Attach debugger to Android Process”\n> 没有默认的快捷键，如果需要的话，可以创建快捷键。\n\n### 评估表达式（Evaluate Expression）\n快捷键：** Alt+F8 **    \n这个功能用来检查变量的内容，评估几乎任何有效的Java表达式。要知道，如果你转变了状态，它会保持下去，当你恢复程序的执行。\n![27-evaluateexpression](27-evaluateexpression.gif)\n\n### 检查变量（Inspect Variable）\n快捷键：在调试时，在表达式中按住ALT键点击鼠标左键** Alt+LeftClick  **  \n不需要打开“Evaluate Expression”对话框，即可查看一个评估一个表达式。\n\n![28-mouse_evaluate_expression](28-mouse_evaluate_expression.gif)\n\n### 标记对象（Mark Object）\n* Mouse: 右击并选择 “Mark Object”  \n* OSX : 选中对象，按 F3  \n* Windows/Linux: 选中对象，按 F11  \n\n在调试过程中，你可以使用这个命令给特定的对象添加一个标签，以便于以后识别该对象。\n\n![29-markobject](29-markobject.gif)\n\n### 分析堆栈信息\n* Menu: Analyze → Analyze Stacktrace\n* Find Actions(ctrl+shift+a)输入\"analyze stacktrace\"即可查看堆栈信息。  \n\n可以从你的剪切板中加载log的堆栈信息，并且使得他是可点击的。对于我们从bug报告中摘取一段堆栈进行分析非常有利。  \n\n![30-analyzestacktrace](30-analyzestacktrace.gif)\n\n> 你可以使用\"ProGuard Unscramble\"插件来分析混淆后的堆栈信息。\n\n### 分析数据流\n* Menu: Analyze → Analyze Data Flow to Here\n* Find action: Analyze Data Flow to Here\n\n可以查看当前变量、参数或field调用的路径！这是非常有用的当你进入到一个你不熟悉的代码环境中，并且你想了解这个参数是怎样传到这里的。  \n这也有一个反向操作“Analyze Data Flow from Here”，它将会显示变量、field或返回类型的被调用的路径。\n\n![31-analyzedataflow](31-analyzedataflow.gif)\n\n## 显示正在执行的行（Show Execution Point）\n快捷键：（debug模式下） : Alt+F10\n将光标移动到当前正在调试的行。通常用于下列情况：\n* 你中断的某些地方\n* 你开始在这个文件查看然后跳到了其它一些文件\n* 调用这个快捷键可以返回到你正在一步一步的调试会话的地方\n\n![36-executionpoint](36-executionpoint.gif)\n\n----\n## 多行选择\n* Mac : ** Ctrl+G **  \n* Windows/Linux: ** Alt+J **  \n\n这一条格外的精彩！它可以同时选择多行，进行编辑。这就意味着你可以在同一个文档中有多个光标。\n\n![32-multiselection](32-multiselection.gif)\n\n## 多列选择（Column Selection）\n* Mouse(ubuntu上无效): Alt+鼠标拖拽  \n* Mac : ** Cmd+Shift+8 **  \n* Windows/Linux: ** Shift+Alt+Insert **\n\n![ 33-columnselection.gif](33-columnselection.gif)\n\n> 和多行编辑的区别在于，多列编辑只能是每一行的相同列一起编辑。\n\n## 后缀补全（Postfix Completion）\n\n这个不是非常直观的，但是相当的给力，基本上，它是无需按一连串左键到头部，实现方法的包裹的最好的方式了。\n比较常用的有：\n* .for (for a foreach)\n* .format (wraps a string in String.format())\n* .cast (wraps a statement in a type cast)\n\n![33-postfixcompletion](33-postfixcompletion.gif)\n\n## 与剪切板代码进行比较（Compare With Clipboard）\n* Mouse: right-click the selection and select Compare With Clipboard  \n* Find action: compare with clipboard\n\n用来比较当前你选择的代码和剪切板中的代码有什么区别。个人觉得用处不大。\n![34-comparewithclipboard](34-comparewithclipboard.gif)\n\n## 停止进程\n* Mac : Cmd+F2\n* Windows/Linux: Ctrl+F2\n\n将会终止正在运行的最近的task或者显示一个可选的可能需要终止的task列表。用于停止调试或者终止一个build。\n\n![35-stoprocess](35-stoprocess.gif)\n\n## VCS 操作弹窗\nMac: ** Ctrl+V **  \nWindows/Linux: ** Alt+\\` **   \n显示一些常用的版本控制命令。如git commit。  \n\n![37-vcspopup](37-vcspopup.gif)\n\n## 与分支进行比较（Compare With Branch (Git)）\nMenu (for git): ** VCS -> Git -> Compare With Branch **   \nFind Actions: ** Compare With Branch **  \n\n如果你的项目是在git下，你可以同另一个分支比较你的文件或者文件夹。特别用来比较你的修改和主分支差异多大。\n\n![38-comparewithbranch](38-comparewithbranch.gif)\n\n## 回车键和TAB键的区别\n你可以使用Enter或Tab来自动补全代码。它们之间有一个有趣的差异：使用Enter将会自动完成语句。使用Tab将会自动完成删除光标到下一个点号，括号，分号或空格出现前的内容。\n\n![45-codecompletionentertab](45-codecompletionentertab.gif)\n\n## 跳转到父类的方法\nMac: ** Cmd+U **  \nWindows/Linux: ** Ctrl+U **  \n\n如果光标在一个复写自父类的方法中（例如Activity#onCreate()方法），使用该快捷键，将会到达该方法的父类的实现。如果光标停留在类名上，则跳转到父类。\n\n![39-navigatetoparent](39-navigatetoparent.gif)\n\n## 返回到编辑器（Return to the Editor）\n返回并不关闭面板：Escape   \n返回并关闭面板：Shift+Escape\n\n![40-returntoeditor](40-returntoeditor.gif)\n\n## 跳到最近使用的工具窗口\nMac:F12   \nWindows/Linux:F12  \n\n有时候，你从面板返回到编辑器，但是你发现不得不再返回到这个面板。例如：浏览find usages。使用这个快捷键，你可以不用鼠标返回到这个面板。\n\n![41-lasttoolwindow](41-lasttoolwindow.gif)\n\n## 隐藏所有面板（Hide All Panels）\nMac: ** Cmd+Shift+F12 **   \nwindows/linux: ** Ctrl+Shift+F12 **  \n\n让编辑器进入某种形式上的全屏模式。再次调用这个快捷键可以返回所有面板到它们之前的状态。\n\n![42-hideallwindows](42-hideallwindows.gif)\n\n## 通过编号打开面板\nMac: ** Cmd+Number **   \nwindows/linux: ** Alt+Number **  \n\n可以通过面板上标签对应的数字打开相应的面板。\n\n![43-openpanelbynumber](43-openpanelbynumber.gif)\n\n## 参数信息\nMac:**  Cmd+P **  \nwindows/linux: ** Ctrl+P **    \n\n![44-parameterinfo](44-parameterinfo.gif)\n\n## 切换器\nShortcut:** Ctrl+Tab **\n\n这个功能和IDE的alt+tab/cmd+tab差不多。它允许你导航到一个tab或一个panel。一旦它被打开，只要你按住ctrl键，你可以使用数字或字母快捷键快速导航。你也可以通过按下backspace关闭一个打开的文件。\n\n![46-switcher](46-switcher.gif)\n\n## 上下文信息（Context Info）\nShortcut:** Ctrl+Shift+Q **    \n\n这个将会显示你当前位置，当你的定义范围超出滚动的区域时。通常，这将会是类或内部类的名称，但它也可能是当前方法名。在我看来，它最好的使用是快速查看当前类继承或实现。 它也可以在xml文件中使用。\n\n![47-contextinfo](47-contextinfo.gif)\n\n## 代码重构\nMac: ** Ctrl+T **  \nWindows/Linux: ** Ctrl+Alt+Shift+T **  \n这是一个针对当前选择的代码显示上下文所有可用的重构的快捷键。这个列表可以通过键盘进行检索并且你也可以使用左侧的数字进行快速访问\n\n![48-refactorthis](48-refactorthis.png)\n\n## 跳转到最近编辑的文件（Recently Changed Files）\nMac: ** Cmd+Shift+E **  \nWindows/Linux: ** Ctrl+Shift+E **  \n\n这个和“Recents”弹出框有所不同，这个列出是在本地最近被修改的文件。\n\n![49-recentlyedited](49-recentlyedited.gif)\n\n## 提取变量\nMac:** Cmd+Alt+V **\nWindows/Linux:** Ctrl+Alt+V **\n\n这是一个可以不用通过重构菜单，来提取变量的快捷键。  \n\n![51-extractvariable](51-extractvariable.gif)\n\n>额外的技巧：  \n如果你想修改声明类型为一些更通用的（如：List而不是ArrayList）,你可以使用Shift+Tab它会给出一个可用类型的列表。\n\n## 提取参数\nMac:Cmd+Alt+P\nWindows/Linux:Ctrl+Alt+P\n\n这是一个不用通过重构菜单提取参数的快捷键。\n这个功能是有用的当你意识到一个方法可能是泛型时通过提取一部分做为一个参数。它作用的方式是它会使用当前值作为一个参数然后复制原先的值作为每个调用者的参数。  \n![52-extractparam](52-extractparam.gif)\n\n>额外的技巧：  \n你也可以保持原来的方法使用它声明一个新方法通过“delegate”选项。  \n\n\n## 提取方法\nMac: Cmd+Alt+M\nWindows/Linux: Ctrl+Alt+M\n\n可以提取一个代码块做为一个新的方法。这个功能是相当有用的。无论什么时候你遇到一个开始变得有点复杂的方法，你可以使用这个安全地抽取一部分到另一个方法。我所说的安全是因为IDE不会像我们可能会犯一个愚蠢的复制粘贴错误。\n\n![53-extractmethod](53-extractmethod.gif)\n\n> 额外的技巧：  \n当你在抽取对话框，你可以修改方法的可见性和参数名称。\n\n## inline\nMac: Cmd+Alt+N\nWindows/Linux: Ctrl+Alt+N\n\n你使用提取有一点疯狂并且现在有太多的东西？你可以使用反向操作，它叫做“inline”。\n它可以作用于方法，Fields，参数和变量。\n\n![54-inline](54-inline.gif)\n\n## 重命名\n快捷键：** Shift+F6 **  \n![55-rename.gif](55-rename.gif)\n\n\n## Pull Up / Push Down\nMac: Ctrl+T 然后选择成员   \nWindows/Linux: Ctrl+Alt+Shift+T 然后选择成员  \n\n当我们谈论上拉成员，我们的意思是我们将会让当前类的一些成员（通常是方法或field）发送它到父类或接口。\n\n如果继承于一个类，内容会被移动。如果是实现的一个接口，它将会声明方法作为接口的一部分，在你的类中保持原有的方法并且添加 @Override注解。\n当我们谈论下推成员，这正好是反向操作，我们会从父类或接口发送一些成员到子类\n\n![56-pullupdown.gif](56-pullupdown.gif)\n\n\n# 索引\n\n| 按键\t| 说明 |\n| ------| -----|\n| Ctrl(Command)+C\t| 复制当前行或选中的内容  |\n| Ctrl(Command)+D\t| 粘贴当前行或选中的内容  |\n| Ctrl(Command)+X\t| 剪切当前行或选中的内容  |\n| Ctrl(Command)+Y\t| 删除行  |\n| Ctrl(Command)+Z | \t倒退  |\n| Ctrl(Command)+Shift+Z | 向前 |    \n| Alt(Option)+Enter | 自动修正 |\n| Ctrl(Command)+Alt(Option)+L | 格式化代码  |\n| Ctrl(Command)+Alt(Option)+I | 将选中的代码进行自动缩进编排  |\n| Ctrl(Command)+Alt(Option)+O |\t优化导入的类和包  |\n| Alt(Option)+Insert | 得到一些Intention Action，可以生成构造器、Getter、Setter、将 == 改为equals() 等  |\n| Ctrl(Command)+Shift+V\t| 选最近使用的剪贴板内容并插入  |\n| Ctrl(Command)+Alt(Option)+Shift+V | 简单粘贴  |\n| Ctrl(Command)+Shift+Insert\t| 选最近使用的剪贴板内容并插入（同Ctrl(Command)+Shift+V）  |\n| Ctrl(Command)+Enter\t| 在当前行的上面插入新行，并移动光标到新行（此功能光标在行首时有效）  |\n| Shift+Enter\t| 在当前行的下面插入新行，并移动光标到新行  |\n| Ctrl(Command)+J\t| 自动代码  |\n| Ctrl(Command)+Alt(Option)+T\t| 把选中的代码放在 try{} 、if{} 、 else{} 里  |\n| Shift+Alt(Option)+Insert\t| 竖编辑模式  |\n| Ctrl(Command)+ /\t| 注释 //  |\n| Ctrl(Command)+Shift+ /\t| 注释 /…/  |\n| Ctrl(Command)+Shift+J\t| 合并成一行  |\n| F2/Shift+F2\t| 跳转到下/上一个错误语句处  |\n| Ctrl(Command)+Shift+Back\t| 跳转到上次编辑的地方  |\n| Ctrl(Command)+Alt(Option)+Space\t| 类名自动完成  |\n| Shift+Alt(Option)+Up/Down\t| 内容向上/下移动  |\n| Ctrl(Command)+Shift+Up/Down | \t语句向上/下移动 |   \n| Ctrl(Command)+Shift+U | \t大小写切换  |\n| Tab | \t代码标签输入完成后，按 Tab，生成代码  |\n| Ctrl(Command)+Backspace\t| 按单词删除 |  \n| Ctrl(Command)+Shift+Enter | \t语句完成 |   \n| Ctrl(Command)+Alt(Option)+J\t| 用动态模板环绕  |\n\n## 文件  \n\n| 按键\t| 说明 |\n| ------| ------|\n| Ctrl(Command)+F12\t| 显示当前文件的结构  |\n| Ctrl(Command)+H\t| 显示类继承结构图   |\n| Ctrl(Command)+Q\t| 显示注释文档  |\n| Ctrl(Command)+P\t| 方法参数提示  |\n| Ctrl(Command)+U\t| 打开当前类的父类或者实现的接口  |\n| Alt(Option)+Left/Right | \t切换代码视图  |\n| Ctrl(Command)+Alt(Option)+Left/Right | \t返回上次编辑的位置  |\n| Alt(Option)+Up/Down\t| 在方法间快速移动定位  |\n| Ctrl(Command)+B\t| 快速打开光标处的类或方法  |\n| Ctrl(Command)+W\t| 选中代码，连续按会有其他效果  |\n| Ctrl(Command)+Shift+W\t| 取消选择光标所在词  |\n| Ctrl(Command)+ - / + | \t折叠/展开代码  |\n| Ctrl(Command)+Shift+ - / +\t| 折叠/展开全部代码  |\n| Ctrl(Command)+Shift+.\t| 折叠/展开当前花括号中的代码  |\n| Ctrl(Command)+ ] / [ | \t跳转到代码块结束/开始处  |\n| F2 或 Shift+F2\t | 高亮错误或警告快速定位  |\n| Ctrl(Command)+Shift+C\t | 复制路径  |\n| Ctrl(Command)+Alt(Option)+Shift+C | \t复制引用，必须选择类名  |\n| Alt(Option)+Up/Down | \t在方法间快速移动定位  |\n| Shift+F1 | \t要打开编辑器光标字符处使用的类或者方法 Java 文档的浏览器  |\n| Ctrl(Command)+G | \t定位行  |\n\n\n## 查找  \n\n| 按键\t |  说明  |\n| ------| --------|\n| Ctrl(Command)+F | \t在当前窗口查找文本  |\n| Ctrl(Command)+Shift+F\t|  在指定环境下查找文本|   \n| F3 | \t向下查找关键字出现位置   |\n| Shift+F3 | \t向上一个关键字出现位置 |    \n| Ctrl(Command)+R | \t在当前窗口替换文本 |   \n| Ctrl(Command)+Shift+R | \t在指定窗口替换文本 |  \n| Ctrl(Command)+N\t|  查找类  |\n| Ctrl(Command)+Shift+N\t|  查找文件 |   \n| Ctrl(Command)+Shift+Alt(Option)+N | \t查找项目中的方法或变量 |  \n| Ctrl(Command)+B | \t查找变量的来源  |\n| Ctrl(Command)+Alt(Option)+B | \t快速打开光标处的类或方法  |\n| Ctrl(Command)+Shift+B | \t跳转到类或方法实现处  |\n| Ctrl(Command)+E | \t最近打开的文件  |\n| Alt(Option)+F3 | \t快速查找，效果和Ctrl(Command)+F相同  |\n| F4 | \t跳转至定义变量的位置  |\n| Alt(Option)+F7 | \t查询当前元素在工程中的引用  |\n| Ctrl(Command)+F7 | \t查询当前元素在当前文件中的引用，然后按 F3 可以选择  |\n| Ctrl(Command)+Alt(Option)+F7 | \t选中查询当前元素在工程中的引用  |\n| Ctrl(Command)+Shift+F7 | \t高亮显示匹配的字符，按 Esc 高亮消失  |\n| Ctrl(Command)+Alt(Option)+F7 | \t查找某个方法的所有调用地方  |\n| Ctrl(Command)+Shift+Alt(Option)+N\t| 查找类中的方法或变量  |\n| Ctrl(Command)+Shift+O | \t弹出显示查找内容  |\n| Ctrl(Command)+Alt(Option)+Up/Down | \t快速跳转搜索结果  |\n| Ctrl(Command)+Shift+S | \t高级搜索、搜索结构  |\n\n## 重构\n\n| 按键\t|  说明  |\n|----|----|\n| F5 | \t复制 |  \n| F6\t| 移动  |\n| Alt(Option)+Delete | \t安全删除 |   \n| Ctrl(Command)+U\t| 转到父类  |\n| Ctrl(Command)+O\t| 重写父类的方法 |  \n| Ctrl(Command)+I\t| 实现方法  |\n| Ctrl(Command)+Alt(Option)+N\t| 内联  |\n| Ctrl(Command)+Alt(Option)+Shift+T\t| 弹出重构菜单  |\n| Shift+F6\t| 重构-重命名   |\n| Ctrl(Command)+Alt(Option)+M\t| 提取代码组成方法  |\n| Ctrl(Command)+Alt(Option)+C\t| 将变量更改为常量  |\n| Ctrl(Command)+Alt(Option)+V\t| 定义变量引用当前对象或者方法的返回值 |  \n| Ctrl(Command)+Alt(Option)+F\t| 将局部变量更改为类的成员变量 |  \n| Ctrl(Command)+Alt(Option)+P\t| 将变量更改为方法的参数  |\n\n## 调试  \n\n| 按键 |\t说明  |\n|-----|-----|\n| F8\t | 跳到下一步  |\n| Shift+F8\t| 跳出函数、跳到下一个断点  |\n| Alt(Option)+Shift+F8 |\t强制跳出函数  |\n| F7 |\t进入代码   |\n| Shift+F7 |\t智能进入代码  |\n| Alt(Option)+Shift+F7 |\t强制进入代码  |\n| Alt(Option)+F9 |\t运行至光标处  |\n| Ctrl(Command)+Alt(Option)+F9 |\t强制运行至光标处  |\n| Ctrl(Command)+F2 |\t停止运行  |\n| Alt(Option)+F8 |\t计算变量值  |\n\n## VCS  \n\n| 按键  | 说明 |\n|------| ----|  \n| Alt(Option)+ ~  | VCS 操作菜单 |  \n| Ctrl(Command)+K | 提交更改 |  \n| Ctrl(Command)+T | 更新项目 |  \n| Ctrl(Command)+Alt(Option)+Shift+D | 显示变化 |  \n\n谢谢阅读完这篇整理的文章，希望从中能够收获知识。  \n转载请注明出处：[www.aman.site](www.aman.site)\n\n> 参考文献：  \n> [Android Cool Posts](https://greenrobot.me/android-dev-tool/android-studio-dev-tips-1/)  \n> [Android Studio Tips Of the Day - Roundup #1  ](http://www.developerphil.com/android-studio-tips-of-the-day-roundup-1/)  \n> [Android Studio Tips Of the Day - Roundup #2  ](http://www.developerphil.com/android-studio-tips-of-the-day-roundup-2/)  \n> [Android Studio Tips Of the Day - Roundup #3  ](http://www.developerphil.com/android-studio-tips-of-the-day-roundup-3/)  \n> [Android Studio Tips Of the Day - Roundup #4  ](http://www.developerphil.com/android-studio-tips-of-the-day-roundup-4/)  \n> [Android Studio Tips Of the Day - Roundup #5  ](http://www.developerphil.com/android-studio-tips-of-the-day-roundup-5/)  \n> [Android Studio Tips Of the Day - Roundup #6  ](http://www.developerphil.com/android-studio-tips-of-the-day-roundup-6/)  \n","source":"_posts/AndroidStudio_shortcut_key.md","raw":"---\nlayout:     post\ntitle: AndroidStudio快捷键大全\nsubtitle:   \"介绍AndroidStudio常用的快捷键功能，收集了所有的Android Studio Tips Of the Day的内容\"\ndate: 2016-05-03 18:18:18\nauthor:     \"JianGuo Yang\"\nheader-img: \"post-bg-androidstudio.jpg\"\ntags: AndroidStudio\n---\n\n\n## 高亮所有\nos X: ** command + shift + F7  **  \nWindows Or Linux: ** ctrl+Shift+F7 **  \n\n![hight light all](01-highlight.gif)\n* 高亮代码方法中的“return” 或者 “throw” 也会高亮这个方法的所有出口。\n* 高亮后可使用\"F3\"或“shift + F3”上下选择。\n* Esc 或者再次使用该快捷键，可以取消高亮。\n\n<!--more-->\n\n## 在方法和内部类之间跳转\nOS X: ** Ctrl + ↑ / ↓ **  \nWindows Or Linux: ** Alt+ ↑ / ↓**  \n\n![02-move_between_methods](02-move_between_methods.gif)\n\n## 跳转到已经打开的下一个/上一个文件\nOS X: ** Ctrl + ← / → **  \nWindows Or Linux: ** Alt+  ← / →**  \n\n## 快速定位到类中的方法/内部类/成员变量\nOS X: ** Command+F12**  \nWindows Or Linux: ** Ctrl+F12 **   \n\n![03-filestructure](03-filestructure.gif)\n* 你可以使用驼峰字符来过滤候选方法列表。例如:输入 “oCr” 就可以找到 “onCreate”方法。\n* 你可以选择是否展示继承的成员变量。如勾选了\"show inherited members\"就可以很方便的查找继承自父类的成员变量。\n* 你可以选择是否展示匿名类。如勾选了\"show Anonymous classes\", 就可以很方便的查找 OnClickListener里面的OnClick方法了。\n\n## 显示方法的调用层级关系\nOS X: ** Ctrl+Alt+H **  \nWindows Or Linux: ** Ctrl+Alt+H **  \n\n![04-callinghierarchy](04-callinghierarchy.gif)\n> 注，ubuntu上与输入法快捷键冲突无法使用\n\n## 快速显示变量或方法的定义\nOS X: ** Alt+Space**  \nWindows Or Linux: ** Ctrl+Shift+i**  \n如果你想立马知道某个类或者方法的来源同时又不想丢掉当前的编码环境，你可以试试这个快捷键。  \n\n![05-quickdefinition](05-quickdefinition.gif)\n\n## 快速收缩或者展开代码块\nOS X : ** Alt + +/- **  \nWindows Or Linux: ** Ctrl +/- **\n\n![06-codefolding](06-codefolding.gif)\n\n* 可以使用 Ctrl + Shift +/- ** 收缩或者展开文件中的所有方法\n* 多次使用会逐级收缩或者展开\n> 你可以在“Editor → Code Folding”自定义你的代码折叠范围\n\n## 书签\n### 默认书签\nOS X : ** F3 **   \nWindows Or Linux : ** F11 **\n### 带字母或者数字的标签\nOS X : ** Alt+F3 **  \nWindows Or Linux : ** Ctrl+F11 **   \n> 按下此快捷键就可以在你的当前光标所在行打上标签，并提供字母或者数字标记。如果你选择的是数字标记，那么可以通过ctrl+对应的数字直接跳转至相应位置。  \n\n### 展示标签\nOS X : ** Command+F3**  \nWindows Or Linux : ** Shift+F11**  \n\n![07-bookmarks](07-bookmarks.gif)\n\n## 查找Android Studio的菜单选项\nOS X :   ** Command+Shift+A**  \nWindows Or Linux : ** Ctrl+Shift+A**  \n你可以通过输入菜单名来查找任意的菜单选项，这对那些使用频率低的操作很有效果。\n\n![08-findaction](08-findaction.gif)\n\n> 如果这个选项有对应的快捷方式，那么这个快捷键会在列表旁边显示。  \n\n## 行操作\n----\n### 移动整行\nOS X : ** Alt+Shift+ ↑ / ↓**   \nWindows Or Linux: ** Alt+Shift+ ↑ / ↓**  \n\n![09-movelines](09-movelines.gif)\n\n### 代码行合并\nMac OS : ** Ctrl+Shift+j **  \nWindows & Linux : ** Ctrl+Shift+j **  \n按照语法规则将可以合并的代码行进行合并，保持代码精简。它主要适用以下规则：  \n* 将变量声明定义和赋值合并;\n* 合并多行字符串的时候，会移掉“+“和双引号;\n* 合并两行评论代码时，评论变成一行，会去掉另一行的“//”;\n\n![18-joinlines](18-joinlines.gif)\n\n### 删除整行\nOS X : ** Command + Backspace**  \nWindows Or Linux : ** Ctrl + Y**  \n\n![10-deleteline](10-deleteline.gif)\n\n### 复制整行\nMac OS: ** Command+D**  \nWindows & Linux: ** Ctrl+D**  \n这个快捷键的厉害之处在于它会复制当前行同时又不会影响系统的剪贴板。\n![11-duplicate_lines](11-duplicate_lines.gif)\n\n----\n\n## 上下移动整个方法\nMac OS : ** Command+Alt+↑/↓ **  \nWindows & Linux : ** Ctrl+Shift+↑/↓ **  \n\n![15-movemethods](15-movemethods.gif)\n\n\n## 展开或者收缩选择区域\nMac OS : ** alt + ↑/↓ **  \nWindows & Linux: ** (Ctrl+w )/(Ctrl+Shift+w) **   \n扩大（或者缩小）当前的选择范围。比如当前选中一个变量，此操作会把选中范围扩展至句子，方法等。\n\n![12-expand_shrink_selection](12-expand_shrink_selection.gif)\n\n## 包裹代码段\nMac OS : ** Command+Alt+t **  \nWindows & Linux : ** Ctrl+Alt+t **  \n选中一段代码段，然后使用if语句或者循环结构等包裹代码。  \n\n![13-surround_with.gif](13-surround_with.gif)  \n## 删除代码块的包裹\nMac OS : ** Command+Shift+Delete **  \nWindows & Linux : ** Ctrl+Shift+Delete **\n移除代码结构中的包裹代码，比如 if 语句,  while 循环, 或者 try/catch 语句。\n![20-unwrap](20-unwrap.gif)\n\n## 查询最近编辑的文件和使用的工作区\nMac OS : ** Command+e **  \nWindows & Linux : ** Ctrl+e **  \n\n![14-recents](14-recents.gif)\n\n## 代码模板\nMac OS : ** Command+j **  \nWindows & Linux : ** Ctrl+j **  \n此快捷键可以让你迅速地在文件中插入预留的代码片段。你也可以定制你自己的代码片段。\n\n![15-live_templates](15-live_templates.gif)\n\n## 代码结构自动补全\nMac OS : ** Command+Shift+Enter **  \nWindows & Linux : ** Ctrl+Shift+Enter **  \n这个操作会将还未完成的代码结构补全。一般可以补全的情形如下：\n\n* 在代码行后面添加分号；\n* 为 if, while 或者 for 语句添加括号\n* 为方法声明添加括号。\n\n![16-completestatement](16-completestatement.gif)\n\n## 回到上次编辑的位置\nMac OS : ** Command+Shift+backspace **  \nWindows & Linux : ** Ctrl+Shift+backspace **  \n\n![17-navigate-previous-changes](17-navigate-previous-changes.gif)\n\n## 在代码中根据标签选择功能（Select In）\nMac OS : ** Alt+F1 **  \nWindows:** Alt+F1 **  \nLinux : 与系统快捷键冲突\n在代码中执行此快捷方式可以快速定位到select Target所示的功能中。\n\n![19-select-in](19-select-in.gif)\n\n## 调试常用快捷键\n\n----\n\n### 添加断点（Toggle Breakpoints）\nOSX: ** Cmd+F8 **  \nWindows/Linux: ** Ctrl+F8 **  \n相应大家都知道使用鼠标左键点击行首添加断点，使用快捷键添加断点的方式如下：\n![21-togglebreakpoints](21-togglebreakpoints.gif)\n\n### 条件断点（Conditional Breakpoints）\n通过右键断点，可以对一个断点加入条件。只有当满足条件时，才会进入到断点中。调试神技，只对自己关心的情况进行调试，不浪费时间。\n\n![22-conditionalbreakpoint](22-conditionalbreakpoint.gif)\n\n### 在断点上打log\n如果你不想在调试过程中添加log，并且重新编译，可以在断点直接打log，查看结果。\n鼠标右键点击断点，取消选择“suspend”,并在 “Log evaluated Expression” 中输入你想要打印的log信息。实例如下：  \n![23-loggingbreakpoints](23-loggingbreakpoints.gif)\n\n### 临时断点\n鼠标（ubuntu上无效）：** Alt+LeftClick ** in the left gutter  \nMac: ** Cmd+Alt+Shift+F8 **  \nWindows/Linux: ** Ctrl+Alt+Shift+F8 **  \n这种方式可以添加一个临时断点，当第一次执行完后，会自动消失。\n\n### disable断点\n在已经完成了一些条件，或者打印了断点，不再需要这些断点的时候，你可以使这些断点无效。  \nMouse(ubuntu 上无效):在已经存在的断点上按住ALT并点击左键： ** Alt+LeftClick **   \n> 没有默认的快捷键，如果需要的话，可以创建快捷键。\n\n![25-disablebreakpoint](25-disablebreakpoint.gif)\n\n### 附加调试器\n及时你没有在调试模式下启动app，你也可以通过以下方式开启调试器。你不需要重新在调试模式下调用app。这是非常有用的。  \nMouse: 点击图标，选择“ Attach debugger to Android Process”\n> 没有默认的快捷键，如果需要的话，可以创建快捷键。\n\n### 评估表达式（Evaluate Expression）\n快捷键：** Alt+F8 **    \n这个功能用来检查变量的内容，评估几乎任何有效的Java表达式。要知道，如果你转变了状态，它会保持下去，当你恢复程序的执行。\n![27-evaluateexpression](27-evaluateexpression.gif)\n\n### 检查变量（Inspect Variable）\n快捷键：在调试时，在表达式中按住ALT键点击鼠标左键** Alt+LeftClick  **  \n不需要打开“Evaluate Expression”对话框，即可查看一个评估一个表达式。\n\n![28-mouse_evaluate_expression](28-mouse_evaluate_expression.gif)\n\n### 标记对象（Mark Object）\n* Mouse: 右击并选择 “Mark Object”  \n* OSX : 选中对象，按 F3  \n* Windows/Linux: 选中对象，按 F11  \n\n在调试过程中，你可以使用这个命令给特定的对象添加一个标签，以便于以后识别该对象。\n\n![29-markobject](29-markobject.gif)\n\n### 分析堆栈信息\n* Menu: Analyze → Analyze Stacktrace\n* Find Actions(ctrl+shift+a)输入\"analyze stacktrace\"即可查看堆栈信息。  \n\n可以从你的剪切板中加载log的堆栈信息，并且使得他是可点击的。对于我们从bug报告中摘取一段堆栈进行分析非常有利。  \n\n![30-analyzestacktrace](30-analyzestacktrace.gif)\n\n> 你可以使用\"ProGuard Unscramble\"插件来分析混淆后的堆栈信息。\n\n### 分析数据流\n* Menu: Analyze → Analyze Data Flow to Here\n* Find action: Analyze Data Flow to Here\n\n可以查看当前变量、参数或field调用的路径！这是非常有用的当你进入到一个你不熟悉的代码环境中，并且你想了解这个参数是怎样传到这里的。  \n这也有一个反向操作“Analyze Data Flow from Here”，它将会显示变量、field或返回类型的被调用的路径。\n\n![31-analyzedataflow](31-analyzedataflow.gif)\n\n## 显示正在执行的行（Show Execution Point）\n快捷键：（debug模式下） : Alt+F10\n将光标移动到当前正在调试的行。通常用于下列情况：\n* 你中断的某些地方\n* 你开始在这个文件查看然后跳到了其它一些文件\n* 调用这个快捷键可以返回到你正在一步一步的调试会话的地方\n\n![36-executionpoint](36-executionpoint.gif)\n\n----\n## 多行选择\n* Mac : ** Ctrl+G **  \n* Windows/Linux: ** Alt+J **  \n\n这一条格外的精彩！它可以同时选择多行，进行编辑。这就意味着你可以在同一个文档中有多个光标。\n\n![32-multiselection](32-multiselection.gif)\n\n## 多列选择（Column Selection）\n* Mouse(ubuntu上无效): Alt+鼠标拖拽  \n* Mac : ** Cmd+Shift+8 **  \n* Windows/Linux: ** Shift+Alt+Insert **\n\n![ 33-columnselection.gif](33-columnselection.gif)\n\n> 和多行编辑的区别在于，多列编辑只能是每一行的相同列一起编辑。\n\n## 后缀补全（Postfix Completion）\n\n这个不是非常直观的，但是相当的给力，基本上，它是无需按一连串左键到头部，实现方法的包裹的最好的方式了。\n比较常用的有：\n* .for (for a foreach)\n* .format (wraps a string in String.format())\n* .cast (wraps a statement in a type cast)\n\n![33-postfixcompletion](33-postfixcompletion.gif)\n\n## 与剪切板代码进行比较（Compare With Clipboard）\n* Mouse: right-click the selection and select Compare With Clipboard  \n* Find action: compare with clipboard\n\n用来比较当前你选择的代码和剪切板中的代码有什么区别。个人觉得用处不大。\n![34-comparewithclipboard](34-comparewithclipboard.gif)\n\n## 停止进程\n* Mac : Cmd+F2\n* Windows/Linux: Ctrl+F2\n\n将会终止正在运行的最近的task或者显示一个可选的可能需要终止的task列表。用于停止调试或者终止一个build。\n\n![35-stoprocess](35-stoprocess.gif)\n\n## VCS 操作弹窗\nMac: ** Ctrl+V **  \nWindows/Linux: ** Alt+\\` **   \n显示一些常用的版本控制命令。如git commit。  \n\n![37-vcspopup](37-vcspopup.gif)\n\n## 与分支进行比较（Compare With Branch (Git)）\nMenu (for git): ** VCS -> Git -> Compare With Branch **   \nFind Actions: ** Compare With Branch **  \n\n如果你的项目是在git下，你可以同另一个分支比较你的文件或者文件夹。特别用来比较你的修改和主分支差异多大。\n\n![38-comparewithbranch](38-comparewithbranch.gif)\n\n## 回车键和TAB键的区别\n你可以使用Enter或Tab来自动补全代码。它们之间有一个有趣的差异：使用Enter将会自动完成语句。使用Tab将会自动完成删除光标到下一个点号，括号，分号或空格出现前的内容。\n\n![45-codecompletionentertab](45-codecompletionentertab.gif)\n\n## 跳转到父类的方法\nMac: ** Cmd+U **  \nWindows/Linux: ** Ctrl+U **  \n\n如果光标在一个复写自父类的方法中（例如Activity#onCreate()方法），使用该快捷键，将会到达该方法的父类的实现。如果光标停留在类名上，则跳转到父类。\n\n![39-navigatetoparent](39-navigatetoparent.gif)\n\n## 返回到编辑器（Return to the Editor）\n返回并不关闭面板：Escape   \n返回并关闭面板：Shift+Escape\n\n![40-returntoeditor](40-returntoeditor.gif)\n\n## 跳到最近使用的工具窗口\nMac:F12   \nWindows/Linux:F12  \n\n有时候，你从面板返回到编辑器，但是你发现不得不再返回到这个面板。例如：浏览find usages。使用这个快捷键，你可以不用鼠标返回到这个面板。\n\n![41-lasttoolwindow](41-lasttoolwindow.gif)\n\n## 隐藏所有面板（Hide All Panels）\nMac: ** Cmd+Shift+F12 **   \nwindows/linux: ** Ctrl+Shift+F12 **  \n\n让编辑器进入某种形式上的全屏模式。再次调用这个快捷键可以返回所有面板到它们之前的状态。\n\n![42-hideallwindows](42-hideallwindows.gif)\n\n## 通过编号打开面板\nMac: ** Cmd+Number **   \nwindows/linux: ** Alt+Number **  \n\n可以通过面板上标签对应的数字打开相应的面板。\n\n![43-openpanelbynumber](43-openpanelbynumber.gif)\n\n## 参数信息\nMac:**  Cmd+P **  \nwindows/linux: ** Ctrl+P **    \n\n![44-parameterinfo](44-parameterinfo.gif)\n\n## 切换器\nShortcut:** Ctrl+Tab **\n\n这个功能和IDE的alt+tab/cmd+tab差不多。它允许你导航到一个tab或一个panel。一旦它被打开，只要你按住ctrl键，你可以使用数字或字母快捷键快速导航。你也可以通过按下backspace关闭一个打开的文件。\n\n![46-switcher](46-switcher.gif)\n\n## 上下文信息（Context Info）\nShortcut:** Ctrl+Shift+Q **    \n\n这个将会显示你当前位置，当你的定义范围超出滚动的区域时。通常，这将会是类或内部类的名称，但它也可能是当前方法名。在我看来，它最好的使用是快速查看当前类继承或实现。 它也可以在xml文件中使用。\n\n![47-contextinfo](47-contextinfo.gif)\n\n## 代码重构\nMac: ** Ctrl+T **  \nWindows/Linux: ** Ctrl+Alt+Shift+T **  \n这是一个针对当前选择的代码显示上下文所有可用的重构的快捷键。这个列表可以通过键盘进行检索并且你也可以使用左侧的数字进行快速访问\n\n![48-refactorthis](48-refactorthis.png)\n\n## 跳转到最近编辑的文件（Recently Changed Files）\nMac: ** Cmd+Shift+E **  \nWindows/Linux: ** Ctrl+Shift+E **  \n\n这个和“Recents”弹出框有所不同，这个列出是在本地最近被修改的文件。\n\n![49-recentlyedited](49-recentlyedited.gif)\n\n## 提取变量\nMac:** Cmd+Alt+V **\nWindows/Linux:** Ctrl+Alt+V **\n\n这是一个可以不用通过重构菜单，来提取变量的快捷键。  \n\n![51-extractvariable](51-extractvariable.gif)\n\n>额外的技巧：  \n如果你想修改声明类型为一些更通用的（如：List而不是ArrayList）,你可以使用Shift+Tab它会给出一个可用类型的列表。\n\n## 提取参数\nMac:Cmd+Alt+P\nWindows/Linux:Ctrl+Alt+P\n\n这是一个不用通过重构菜单提取参数的快捷键。\n这个功能是有用的当你意识到一个方法可能是泛型时通过提取一部分做为一个参数。它作用的方式是它会使用当前值作为一个参数然后复制原先的值作为每个调用者的参数。  \n![52-extractparam](52-extractparam.gif)\n\n>额外的技巧：  \n你也可以保持原来的方法使用它声明一个新方法通过“delegate”选项。  \n\n\n## 提取方法\nMac: Cmd+Alt+M\nWindows/Linux: Ctrl+Alt+M\n\n可以提取一个代码块做为一个新的方法。这个功能是相当有用的。无论什么时候你遇到一个开始变得有点复杂的方法，你可以使用这个安全地抽取一部分到另一个方法。我所说的安全是因为IDE不会像我们可能会犯一个愚蠢的复制粘贴错误。\n\n![53-extractmethod](53-extractmethod.gif)\n\n> 额外的技巧：  \n当你在抽取对话框，你可以修改方法的可见性和参数名称。\n\n## inline\nMac: Cmd+Alt+N\nWindows/Linux: Ctrl+Alt+N\n\n你使用提取有一点疯狂并且现在有太多的东西？你可以使用反向操作，它叫做“inline”。\n它可以作用于方法，Fields，参数和变量。\n\n![54-inline](54-inline.gif)\n\n## 重命名\n快捷键：** Shift+F6 **  \n![55-rename.gif](55-rename.gif)\n\n\n## Pull Up / Push Down\nMac: Ctrl+T 然后选择成员   \nWindows/Linux: Ctrl+Alt+Shift+T 然后选择成员  \n\n当我们谈论上拉成员，我们的意思是我们将会让当前类的一些成员（通常是方法或field）发送它到父类或接口。\n\n如果继承于一个类，内容会被移动。如果是实现的一个接口，它将会声明方法作为接口的一部分，在你的类中保持原有的方法并且添加 @Override注解。\n当我们谈论下推成员，这正好是反向操作，我们会从父类或接口发送一些成员到子类\n\n![56-pullupdown.gif](56-pullupdown.gif)\n\n\n# 索引\n\n| 按键\t| 说明 |\n| ------| -----|\n| Ctrl(Command)+C\t| 复制当前行或选中的内容  |\n| Ctrl(Command)+D\t| 粘贴当前行或选中的内容  |\n| Ctrl(Command)+X\t| 剪切当前行或选中的内容  |\n| Ctrl(Command)+Y\t| 删除行  |\n| Ctrl(Command)+Z | \t倒退  |\n| Ctrl(Command)+Shift+Z | 向前 |    \n| Alt(Option)+Enter | 自动修正 |\n| Ctrl(Command)+Alt(Option)+L | 格式化代码  |\n| Ctrl(Command)+Alt(Option)+I | 将选中的代码进行自动缩进编排  |\n| Ctrl(Command)+Alt(Option)+O |\t优化导入的类和包  |\n| Alt(Option)+Insert | 得到一些Intention Action，可以生成构造器、Getter、Setter、将 == 改为equals() 等  |\n| Ctrl(Command)+Shift+V\t| 选最近使用的剪贴板内容并插入  |\n| Ctrl(Command)+Alt(Option)+Shift+V | 简单粘贴  |\n| Ctrl(Command)+Shift+Insert\t| 选最近使用的剪贴板内容并插入（同Ctrl(Command)+Shift+V）  |\n| Ctrl(Command)+Enter\t| 在当前行的上面插入新行，并移动光标到新行（此功能光标在行首时有效）  |\n| Shift+Enter\t| 在当前行的下面插入新行，并移动光标到新行  |\n| Ctrl(Command)+J\t| 自动代码  |\n| Ctrl(Command)+Alt(Option)+T\t| 把选中的代码放在 try{} 、if{} 、 else{} 里  |\n| Shift+Alt(Option)+Insert\t| 竖编辑模式  |\n| Ctrl(Command)+ /\t| 注释 //  |\n| Ctrl(Command)+Shift+ /\t| 注释 /…/  |\n| Ctrl(Command)+Shift+J\t| 合并成一行  |\n| F2/Shift+F2\t| 跳转到下/上一个错误语句处  |\n| Ctrl(Command)+Shift+Back\t| 跳转到上次编辑的地方  |\n| Ctrl(Command)+Alt(Option)+Space\t| 类名自动完成  |\n| Shift+Alt(Option)+Up/Down\t| 内容向上/下移动  |\n| Ctrl(Command)+Shift+Up/Down | \t语句向上/下移动 |   \n| Ctrl(Command)+Shift+U | \t大小写切换  |\n| Tab | \t代码标签输入完成后，按 Tab，生成代码  |\n| Ctrl(Command)+Backspace\t| 按单词删除 |  \n| Ctrl(Command)+Shift+Enter | \t语句完成 |   \n| Ctrl(Command)+Alt(Option)+J\t| 用动态模板环绕  |\n\n## 文件  \n\n| 按键\t| 说明 |\n| ------| ------|\n| Ctrl(Command)+F12\t| 显示当前文件的结构  |\n| Ctrl(Command)+H\t| 显示类继承结构图   |\n| Ctrl(Command)+Q\t| 显示注释文档  |\n| Ctrl(Command)+P\t| 方法参数提示  |\n| Ctrl(Command)+U\t| 打开当前类的父类或者实现的接口  |\n| Alt(Option)+Left/Right | \t切换代码视图  |\n| Ctrl(Command)+Alt(Option)+Left/Right | \t返回上次编辑的位置  |\n| Alt(Option)+Up/Down\t| 在方法间快速移动定位  |\n| Ctrl(Command)+B\t| 快速打开光标处的类或方法  |\n| Ctrl(Command)+W\t| 选中代码，连续按会有其他效果  |\n| Ctrl(Command)+Shift+W\t| 取消选择光标所在词  |\n| Ctrl(Command)+ - / + | \t折叠/展开代码  |\n| Ctrl(Command)+Shift+ - / +\t| 折叠/展开全部代码  |\n| Ctrl(Command)+Shift+.\t| 折叠/展开当前花括号中的代码  |\n| Ctrl(Command)+ ] / [ | \t跳转到代码块结束/开始处  |\n| F2 或 Shift+F2\t | 高亮错误或警告快速定位  |\n| Ctrl(Command)+Shift+C\t | 复制路径  |\n| Ctrl(Command)+Alt(Option)+Shift+C | \t复制引用，必须选择类名  |\n| Alt(Option)+Up/Down | \t在方法间快速移动定位  |\n| Shift+F1 | \t要打开编辑器光标字符处使用的类或者方法 Java 文档的浏览器  |\n| Ctrl(Command)+G | \t定位行  |\n\n\n## 查找  \n\n| 按键\t |  说明  |\n| ------| --------|\n| Ctrl(Command)+F | \t在当前窗口查找文本  |\n| Ctrl(Command)+Shift+F\t|  在指定环境下查找文本|   \n| F3 | \t向下查找关键字出现位置   |\n| Shift+F3 | \t向上一个关键字出现位置 |    \n| Ctrl(Command)+R | \t在当前窗口替换文本 |   \n| Ctrl(Command)+Shift+R | \t在指定窗口替换文本 |  \n| Ctrl(Command)+N\t|  查找类  |\n| Ctrl(Command)+Shift+N\t|  查找文件 |   \n| Ctrl(Command)+Shift+Alt(Option)+N | \t查找项目中的方法或变量 |  \n| Ctrl(Command)+B | \t查找变量的来源  |\n| Ctrl(Command)+Alt(Option)+B | \t快速打开光标处的类或方法  |\n| Ctrl(Command)+Shift+B | \t跳转到类或方法实现处  |\n| Ctrl(Command)+E | \t最近打开的文件  |\n| Alt(Option)+F3 | \t快速查找，效果和Ctrl(Command)+F相同  |\n| F4 | \t跳转至定义变量的位置  |\n| Alt(Option)+F7 | \t查询当前元素在工程中的引用  |\n| Ctrl(Command)+F7 | \t查询当前元素在当前文件中的引用，然后按 F3 可以选择  |\n| Ctrl(Command)+Alt(Option)+F7 | \t选中查询当前元素在工程中的引用  |\n| Ctrl(Command)+Shift+F7 | \t高亮显示匹配的字符，按 Esc 高亮消失  |\n| Ctrl(Command)+Alt(Option)+F7 | \t查找某个方法的所有调用地方  |\n| Ctrl(Command)+Shift+Alt(Option)+N\t| 查找类中的方法或变量  |\n| Ctrl(Command)+Shift+O | \t弹出显示查找内容  |\n| Ctrl(Command)+Alt(Option)+Up/Down | \t快速跳转搜索结果  |\n| Ctrl(Command)+Shift+S | \t高级搜索、搜索结构  |\n\n## 重构\n\n| 按键\t|  说明  |\n|----|----|\n| F5 | \t复制 |  \n| F6\t| 移动  |\n| Alt(Option)+Delete | \t安全删除 |   \n| Ctrl(Command)+U\t| 转到父类  |\n| Ctrl(Command)+O\t| 重写父类的方法 |  \n| Ctrl(Command)+I\t| 实现方法  |\n| Ctrl(Command)+Alt(Option)+N\t| 内联  |\n| Ctrl(Command)+Alt(Option)+Shift+T\t| 弹出重构菜单  |\n| Shift+F6\t| 重构-重命名   |\n| Ctrl(Command)+Alt(Option)+M\t| 提取代码组成方法  |\n| Ctrl(Command)+Alt(Option)+C\t| 将变量更改为常量  |\n| Ctrl(Command)+Alt(Option)+V\t| 定义变量引用当前对象或者方法的返回值 |  \n| Ctrl(Command)+Alt(Option)+F\t| 将局部变量更改为类的成员变量 |  \n| Ctrl(Command)+Alt(Option)+P\t| 将变量更改为方法的参数  |\n\n## 调试  \n\n| 按键 |\t说明  |\n|-----|-----|\n| F8\t | 跳到下一步  |\n| Shift+F8\t| 跳出函数、跳到下一个断点  |\n| Alt(Option)+Shift+F8 |\t强制跳出函数  |\n| F7 |\t进入代码   |\n| Shift+F7 |\t智能进入代码  |\n| Alt(Option)+Shift+F7 |\t强制进入代码  |\n| Alt(Option)+F9 |\t运行至光标处  |\n| Ctrl(Command)+Alt(Option)+F9 |\t强制运行至光标处  |\n| Ctrl(Command)+F2 |\t停止运行  |\n| Alt(Option)+F8 |\t计算变量值  |\n\n## VCS  \n\n| 按键  | 说明 |\n|------| ----|  \n| Alt(Option)+ ~  | VCS 操作菜单 |  \n| Ctrl(Command)+K | 提交更改 |  \n| Ctrl(Command)+T | 更新项目 |  \n| Ctrl(Command)+Alt(Option)+Shift+D | 显示变化 |  \n\n谢谢阅读完这篇整理的文章，希望从中能够收获知识。  \n转载请注明出处：[www.aman.site](www.aman.site)\n\n> 参考文献：  \n> [Android Cool Posts](https://greenrobot.me/android-dev-tool/android-studio-dev-tips-1/)  \n> [Android Studio Tips Of the Day - Roundup #1  ](http://www.developerphil.com/android-studio-tips-of-the-day-roundup-1/)  \n> [Android Studio Tips Of the Day - Roundup #2  ](http://www.developerphil.com/android-studio-tips-of-the-day-roundup-2/)  \n> [Android Studio Tips Of the Day - Roundup #3  ](http://www.developerphil.com/android-studio-tips-of-the-day-roundup-3/)  \n> [Android Studio Tips Of the Day - Roundup #4  ](http://www.developerphil.com/android-studio-tips-of-the-day-roundup-4/)  \n> [Android Studio Tips Of the Day - Roundup #5  ](http://www.developerphil.com/android-studio-tips-of-the-day-roundup-5/)  \n> [Android Studio Tips Of the Day - Roundup #6  ](http://www.developerphil.com/android-studio-tips-of-the-day-roundup-6/)  \n","slug":"AndroidStudio_shortcut_key","published":1,"updated":"2016-07-28T12:15:26.732Z","comments":1,"photos":[],"link":"","_id":"cirdlcvbn0001252na1hgzz0z","content":"<h2 id=\"高亮所有\"><a href=\"#高亮所有\" class=\"headerlink\" title=\"高亮所有\"></a>高亮所有</h2><p>os X: <strong> command + shift + F7  </strong><br>Windows Or Linux: <strong> ctrl+Shift+F7 </strong>  </p>\n<p><img src=\"01-highlight.gif\" alt=\"hight light all\"></p>\n<ul>\n<li>高亮代码方法中的“return” 或者 “throw” 也会高亮这个方法的所有出口。</li>\n<li>高亮后可使用”F3”或“shift + F3”上下选择。</li>\n<li>Esc 或者再次使用该快捷键，可以取消高亮。</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"在方法和内部类之间跳转\"><a href=\"#在方法和内部类之间跳转\" class=\"headerlink\" title=\"在方法和内部类之间跳转\"></a>在方法和内部类之间跳转</h2><p>OS X: <strong> Ctrl + ↑ / ↓ </strong><br>Windows Or Linux: <strong> Alt+ ↑ / ↓</strong>  </p>\n<p><img src=\"02-move_between_methods.gif\" alt=\"02-move_between_methods\"></p>\n<h2 id=\"跳转到已经打开的下一个-上一个文件\"><a href=\"#跳转到已经打开的下一个-上一个文件\" class=\"headerlink\" title=\"跳转到已经打开的下一个/上一个文件\"></a>跳转到已经打开的下一个/上一个文件</h2><p>OS X: <strong> Ctrl + ← / → </strong><br>Windows Or Linux: <strong> Alt+  ← / →</strong>  </p>\n<h2 id=\"快速定位到类中的方法-内部类-成员变量\"><a href=\"#快速定位到类中的方法-内部类-成员变量\" class=\"headerlink\" title=\"快速定位到类中的方法/内部类/成员变量\"></a>快速定位到类中的方法/内部类/成员变量</h2><p>OS X: <strong> Command+F12</strong><br>Windows Or Linux: <strong> Ctrl+F12 </strong>   </p>\n<p><img src=\"03-filestructure.gif\" alt=\"03-filestructure\"></p>\n<ul>\n<li>你可以使用驼峰字符来过滤候选方法列表。例如:输入 “oCr” 就可以找到 “onCreate”方法。</li>\n<li>你可以选择是否展示继承的成员变量。如勾选了”show inherited members”就可以很方便的查找继承自父类的成员变量。</li>\n<li>你可以选择是否展示匿名类。如勾选了”show Anonymous classes”, 就可以很方便的查找 OnClickListener里面的OnClick方法了。</li>\n</ul>\n<h2 id=\"显示方法的调用层级关系\"><a href=\"#显示方法的调用层级关系\" class=\"headerlink\" title=\"显示方法的调用层级关系\"></a>显示方法的调用层级关系</h2><p>OS X: <strong> Ctrl+Alt+H </strong><br>Windows Or Linux: <strong> Ctrl+Alt+H </strong>  </p>\n<p><img src=\"04-callinghierarchy.gif\" alt=\"04-callinghierarchy\"></p>\n<blockquote>\n<p>注，ubuntu上与输入法快捷键冲突无法使用</p>\n</blockquote>\n<h2 id=\"快速显示变量或方法的定义\"><a href=\"#快速显示变量或方法的定义\" class=\"headerlink\" title=\"快速显示变量或方法的定义\"></a>快速显示变量或方法的定义</h2><p>OS X: <strong> Alt+Space</strong><br>Windows Or Linux: <strong> Ctrl+Shift+i</strong><br>如果你想立马知道某个类或者方法的来源同时又不想丢掉当前的编码环境，你可以试试这个快捷键。  </p>\n<p><img src=\"05-quickdefinition.gif\" alt=\"05-quickdefinition\"></p>\n<h2 id=\"快速收缩或者展开代码块\"><a href=\"#快速收缩或者展开代码块\" class=\"headerlink\" title=\"快速收缩或者展开代码块\"></a>快速收缩或者展开代码块</h2><p>OS X : <strong> Alt + +/- </strong><br>Windows Or Linux: <strong> Ctrl +/- </strong></p>\n<p><img src=\"06-codefolding.gif\" alt=\"06-codefolding\"></p>\n<ul>\n<li>可以使用 Ctrl + Shift +/- ** 收缩或者展开文件中的所有方法</li>\n<li>多次使用会逐级收缩或者展开<blockquote>\n<p>你可以在“Editor → Code Folding”自定义你的代码折叠范围</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"书签\"><a href=\"#书签\" class=\"headerlink\" title=\"书签\"></a>书签</h2><h3 id=\"默认书签\"><a href=\"#默认书签\" class=\"headerlink\" title=\"默认书签\"></a>默认书签</h3><p>OS X : <strong> F3 </strong><br>Windows Or Linux : <strong> F11 </strong></p>\n<h3 id=\"带字母或者数字的标签\"><a href=\"#带字母或者数字的标签\" class=\"headerlink\" title=\"带字母或者数字的标签\"></a>带字母或者数字的标签</h3><p>OS X : <strong> Alt+F3 </strong><br>Windows Or Linux : <strong> Ctrl+F11 </strong>   </p>\n<blockquote>\n<p>按下此快捷键就可以在你的当前光标所在行打上标签，并提供字母或者数字标记。如果你选择的是数字标记，那么可以通过ctrl+对应的数字直接跳转至相应位置。  </p>\n</blockquote>\n<h3 id=\"展示标签\"><a href=\"#展示标签\" class=\"headerlink\" title=\"展示标签\"></a>展示标签</h3><p>OS X : <strong> Command+F3</strong><br>Windows Or Linux : <strong> Shift+F11</strong>  </p>\n<p><img src=\"07-bookmarks.gif\" alt=\"07-bookmarks\"></p>\n<h2 id=\"查找Android-Studio的菜单选项\"><a href=\"#查找Android-Studio的菜单选项\" class=\"headerlink\" title=\"查找Android Studio的菜单选项\"></a>查找Android Studio的菜单选项</h2><p>OS X :   <strong> Command+Shift+A</strong><br>Windows Or Linux : <strong> Ctrl+Shift+A</strong><br>你可以通过输入菜单名来查找任意的菜单选项，这对那些使用频率低的操作很有效果。</p>\n<p><img src=\"08-findaction.gif\" alt=\"08-findaction\"></p>\n<blockquote>\n<p>如果这个选项有对应的快捷方式，那么这个快捷键会在列表旁边显示。  </p>\n</blockquote>\n<h2 id=\"行操作\"><a href=\"#行操作\" class=\"headerlink\" title=\"行操作\"></a>行操作</h2><hr>\n<h3 id=\"移动整行\"><a href=\"#移动整行\" class=\"headerlink\" title=\"移动整行\"></a>移动整行</h3><p>OS X : <strong> Alt+Shift+ ↑ / ↓</strong><br>Windows Or Linux: <strong> Alt+Shift+ ↑ / ↓</strong>  </p>\n<p><img src=\"09-movelines.gif\" alt=\"09-movelines\"></p>\n<h3 id=\"代码行合并\"><a href=\"#代码行合并\" class=\"headerlink\" title=\"代码行合并\"></a>代码行合并</h3><p>Mac OS : <strong> Ctrl+Shift+j </strong><br>Windows &amp; Linux : <strong> Ctrl+Shift+j </strong><br>按照语法规则将可以合并的代码行进行合并，保持代码精简。它主要适用以下规则：  </p>\n<ul>\n<li>将变量声明定义和赋值合并;</li>\n<li>合并多行字符串的时候，会移掉“+“和双引号;</li>\n<li>合并两行评论代码时，评论变成一行，会去掉另一行的“//”;</li>\n</ul>\n<p><img src=\"18-joinlines.gif\" alt=\"18-joinlines\"></p>\n<h3 id=\"删除整行\"><a href=\"#删除整行\" class=\"headerlink\" title=\"删除整行\"></a>删除整行</h3><p>OS X : <strong> Command + Backspace</strong><br>Windows Or Linux : <strong> Ctrl + Y</strong>  </p>\n<p><img src=\"10-deleteline.gif\" alt=\"10-deleteline\"></p>\n<h3 id=\"复制整行\"><a href=\"#复制整行\" class=\"headerlink\" title=\"复制整行\"></a>复制整行</h3><p>Mac OS: <strong> Command+D</strong><br>Windows &amp; Linux: <strong> Ctrl+D</strong><br>这个快捷键的厉害之处在于它会复制当前行同时又不会影响系统的剪贴板。<br><img src=\"11-duplicate_lines.gif\" alt=\"11-duplicate_lines\"></p>\n<hr>\n<h2 id=\"上下移动整个方法\"><a href=\"#上下移动整个方法\" class=\"headerlink\" title=\"上下移动整个方法\"></a>上下移动整个方法</h2><p>Mac OS : <strong> Command+Alt+↑/↓ </strong><br>Windows &amp; Linux : <strong> Ctrl+Shift+↑/↓ </strong>  </p>\n<p><img src=\"15-movemethods.gif\" alt=\"15-movemethods\"></p>\n<h2 id=\"展开或者收缩选择区域\"><a href=\"#展开或者收缩选择区域\" class=\"headerlink\" title=\"展开或者收缩选择区域\"></a>展开或者收缩选择区域</h2><p>Mac OS : <strong> alt + ↑/↓ </strong><br>Windows &amp; Linux: <strong> (Ctrl+w )/(Ctrl+Shift+w) </strong><br>扩大（或者缩小）当前的选择范围。比如当前选中一个变量，此操作会把选中范围扩展至句子，方法等。</p>\n<p><img src=\"12-expand_shrink_selection.gif\" alt=\"12-expand_shrink_selection\"></p>\n<h2 id=\"包裹代码段\"><a href=\"#包裹代码段\" class=\"headerlink\" title=\"包裹代码段\"></a>包裹代码段</h2><p>Mac OS : <strong> Command+Alt+t </strong><br>Windows &amp; Linux : <strong> Ctrl+Alt+t </strong><br>选中一段代码段，然后使用if语句或者循环结构等包裹代码。  </p>\n<p><img src=\"13-surround_with.gif\" alt=\"13-surround_with.gif\">  </p>\n<h2 id=\"删除代码块的包裹\"><a href=\"#删除代码块的包裹\" class=\"headerlink\" title=\"删除代码块的包裹\"></a>删除代码块的包裹</h2><p>Mac OS : <strong> Command+Shift+Delete </strong><br>Windows &amp; Linux : <strong> Ctrl+Shift+Delete </strong><br>移除代码结构中的包裹代码，比如 if 语句,  while 循环, 或者 try/catch 语句。<br><img src=\"20-unwrap.gif\" alt=\"20-unwrap\"></p>\n<h2 id=\"查询最近编辑的文件和使用的工作区\"><a href=\"#查询最近编辑的文件和使用的工作区\" class=\"headerlink\" title=\"查询最近编辑的文件和使用的工作区\"></a>查询最近编辑的文件和使用的工作区</h2><p>Mac OS : <strong> Command+e </strong><br>Windows &amp; Linux : <strong> Ctrl+e </strong>  </p>\n<p><img src=\"14-recents.gif\" alt=\"14-recents\"></p>\n<h2 id=\"代码模板\"><a href=\"#代码模板\" class=\"headerlink\" title=\"代码模板\"></a>代码模板</h2><p>Mac OS : <strong> Command+j </strong><br>Windows &amp; Linux : <strong> Ctrl+j </strong><br>此快捷键可以让你迅速地在文件中插入预留的代码片段。你也可以定制你自己的代码片段。</p>\n<p><img src=\"15-live_templates.gif\" alt=\"15-live_templates\"></p>\n<h2 id=\"代码结构自动补全\"><a href=\"#代码结构自动补全\" class=\"headerlink\" title=\"代码结构自动补全\"></a>代码结构自动补全</h2><p>Mac OS : <strong> Command+Shift+Enter </strong><br>Windows &amp; Linux : <strong> Ctrl+Shift+Enter </strong><br>这个操作会将还未完成的代码结构补全。一般可以补全的情形如下：</p>\n<ul>\n<li>在代码行后面添加分号；</li>\n<li>为 if, while 或者 for 语句添加括号</li>\n<li>为方法声明添加括号。</li>\n</ul>\n<p><img src=\"16-completestatement.gif\" alt=\"16-completestatement\"></p>\n<h2 id=\"回到上次编辑的位置\"><a href=\"#回到上次编辑的位置\" class=\"headerlink\" title=\"回到上次编辑的位置\"></a>回到上次编辑的位置</h2><p>Mac OS : <strong> Command+Shift+backspace </strong><br>Windows &amp; Linux : <strong> Ctrl+Shift+backspace </strong>  </p>\n<p><img src=\"17-navigate-previous-changes.gif\" alt=\"17-navigate-previous-changes\"></p>\n<h2 id=\"在代码中根据标签选择功能（Select-In）\"><a href=\"#在代码中根据标签选择功能（Select-In）\" class=\"headerlink\" title=\"在代码中根据标签选择功能（Select In）\"></a>在代码中根据标签选择功能（Select In）</h2><p>Mac OS : <strong> Alt+F1 </strong><br>Windows:<strong> Alt+F1 </strong><br>Linux : 与系统快捷键冲突<br>在代码中执行此快捷方式可以快速定位到select Target所示的功能中。</p>\n<p><img src=\"19-select-in.gif\" alt=\"19-select-in\"></p>\n<h2 id=\"调试常用快捷键\"><a href=\"#调试常用快捷键\" class=\"headerlink\" title=\"调试常用快捷键\"></a>调试常用快捷键</h2><hr>\n<h3 id=\"添加断点（Toggle-Breakpoints）\"><a href=\"#添加断点（Toggle-Breakpoints）\" class=\"headerlink\" title=\"添加断点（Toggle Breakpoints）\"></a>添加断点（Toggle Breakpoints）</h3><p>OSX: <strong> Cmd+F8 </strong><br>Windows/Linux: <strong> Ctrl+F8 </strong><br>相应大家都知道使用鼠标左键点击行首添加断点，使用快捷键添加断点的方式如下：<br><img src=\"21-togglebreakpoints.gif\" alt=\"21-togglebreakpoints\"></p>\n<h3 id=\"条件断点（Conditional-Breakpoints）\"><a href=\"#条件断点（Conditional-Breakpoints）\" class=\"headerlink\" title=\"条件断点（Conditional Breakpoints）\"></a>条件断点（Conditional Breakpoints）</h3><p>通过右键断点，可以对一个断点加入条件。只有当满足条件时，才会进入到断点中。调试神技，只对自己关心的情况进行调试，不浪费时间。</p>\n<p><img src=\"22-conditionalbreakpoint.gif\" alt=\"22-conditionalbreakpoint\"></p>\n<h3 id=\"在断点上打log\"><a href=\"#在断点上打log\" class=\"headerlink\" title=\"在断点上打log\"></a>在断点上打log</h3><p>如果你不想在调试过程中添加log，并且重新编译，可以在断点直接打log，查看结果。<br>鼠标右键点击断点，取消选择“suspend”,并在 “Log evaluated Expression” 中输入你想要打印的log信息。实例如下：<br><img src=\"23-loggingbreakpoints.gif\" alt=\"23-loggingbreakpoints\"></p>\n<h3 id=\"临时断点\"><a href=\"#临时断点\" class=\"headerlink\" title=\"临时断点\"></a>临时断点</h3><p>鼠标（ubuntu上无效）：<strong> Alt+LeftClick </strong> in the left gutter<br>Mac: <strong> Cmd+Alt+Shift+F8 </strong><br>Windows/Linux: <strong> Ctrl+Alt+Shift+F8 </strong><br>这种方式可以添加一个临时断点，当第一次执行完后，会自动消失。</p>\n<h3 id=\"disable断点\"><a href=\"#disable断点\" class=\"headerlink\" title=\"disable断点\"></a>disable断点</h3><p>在已经完成了一些条件，或者打印了断点，不再需要这些断点的时候，你可以使这些断点无效。<br>Mouse(ubuntu 上无效):在已经存在的断点上按住ALT并点击左键： <strong> Alt+LeftClick </strong>   </p>\n<blockquote>\n<p>没有默认的快捷键，如果需要的话，可以创建快捷键。</p>\n</blockquote>\n<p><img src=\"25-disablebreakpoint.gif\" alt=\"25-disablebreakpoint\"></p>\n<h3 id=\"附加调试器\"><a href=\"#附加调试器\" class=\"headerlink\" title=\"附加调试器\"></a>附加调试器</h3><p>及时你没有在调试模式下启动app，你也可以通过以下方式开启调试器。你不需要重新在调试模式下调用app。这是非常有用的。<br>Mouse: 点击图标，选择“ Attach debugger to Android Process”</p>\n<blockquote>\n<p>没有默认的快捷键，如果需要的话，可以创建快捷键。</p>\n</blockquote>\n<h3 id=\"评估表达式（Evaluate-Expression）\"><a href=\"#评估表达式（Evaluate-Expression）\" class=\"headerlink\" title=\"评估表达式（Evaluate Expression）\"></a>评估表达式（Evaluate Expression）</h3><p>快捷键：<strong> Alt+F8 </strong><br>这个功能用来检查变量的内容，评估几乎任何有效的Java表达式。要知道，如果你转变了状态，它会保持下去，当你恢复程序的执行。<br><img src=\"27-evaluateexpression.gif\" alt=\"27-evaluateexpression\"></p>\n<h3 id=\"检查变量（Inspect-Variable）\"><a href=\"#检查变量（Inspect-Variable）\" class=\"headerlink\" title=\"检查变量（Inspect Variable）\"></a>检查变量（Inspect Variable）</h3><p>快捷键：在调试时，在表达式中按住ALT键点击鼠标左键<strong> Alt+LeftClick  </strong><br>不需要打开“Evaluate Expression”对话框，即可查看一个评估一个表达式。</p>\n<p><img src=\"28-mouse_evaluate_expression.gif\" alt=\"28-mouse_evaluate_expression\"></p>\n<h3 id=\"标记对象（Mark-Object）\"><a href=\"#标记对象（Mark-Object）\" class=\"headerlink\" title=\"标记对象（Mark Object）\"></a>标记对象（Mark Object）</h3><ul>\n<li>Mouse: 右击并选择 “Mark Object”  </li>\n<li>OSX : 选中对象，按 F3  </li>\n<li>Windows/Linux: 选中对象，按 F11  </li>\n</ul>\n<p>在调试过程中，你可以使用这个命令给特定的对象添加一个标签，以便于以后识别该对象。</p>\n<p><img src=\"29-markobject.gif\" alt=\"29-markobject\"></p>\n<h3 id=\"分析堆栈信息\"><a href=\"#分析堆栈信息\" class=\"headerlink\" title=\"分析堆栈信息\"></a>分析堆栈信息</h3><ul>\n<li>Menu: Analyze → Analyze Stacktrace</li>\n<li>Find Actions(ctrl+shift+a)输入”analyze stacktrace”即可查看堆栈信息。  </li>\n</ul>\n<p>可以从你的剪切板中加载log的堆栈信息，并且使得他是可点击的。对于我们从bug报告中摘取一段堆栈进行分析非常有利。  </p>\n<p><img src=\"30-analyzestacktrace.gif\" alt=\"30-analyzestacktrace\"></p>\n<blockquote>\n<p>你可以使用”ProGuard Unscramble”插件来分析混淆后的堆栈信息。</p>\n</blockquote>\n<h3 id=\"分析数据流\"><a href=\"#分析数据流\" class=\"headerlink\" title=\"分析数据流\"></a>分析数据流</h3><ul>\n<li>Menu: Analyze → Analyze Data Flow to Here</li>\n<li>Find action: Analyze Data Flow to Here</li>\n</ul>\n<p>可以查看当前变量、参数或field调用的路径！这是非常有用的当你进入到一个你不熟悉的代码环境中，并且你想了解这个参数是怎样传到这里的。<br>这也有一个反向操作“Analyze Data Flow from Here”，它将会显示变量、field或返回类型的被调用的路径。</p>\n<p><img src=\"31-analyzedataflow.gif\" alt=\"31-analyzedataflow\"></p>\n<h2 id=\"显示正在执行的行（Show-Execution-Point）\"><a href=\"#显示正在执行的行（Show-Execution-Point）\" class=\"headerlink\" title=\"显示正在执行的行（Show Execution Point）\"></a>显示正在执行的行（Show Execution Point）</h2><p>快捷键：（debug模式下） : Alt+F10<br>将光标移动到当前正在调试的行。通常用于下列情况：</p>\n<ul>\n<li>你中断的某些地方</li>\n<li>你开始在这个文件查看然后跳到了其它一些文件</li>\n<li>调用这个快捷键可以返回到你正在一步一步的调试会话的地方</li>\n</ul>\n<p><img src=\"36-executionpoint.gif\" alt=\"36-executionpoint\"></p>\n<hr>\n<h2 id=\"多行选择\"><a href=\"#多行选择\" class=\"headerlink\" title=\"多行选择\"></a>多行选择</h2><ul>\n<li>Mac : <strong> Ctrl+G </strong>  </li>\n<li>Windows/Linux: <strong> Alt+J </strong>  </li>\n</ul>\n<p>这一条格外的精彩！它可以同时选择多行，进行编辑。这就意味着你可以在同一个文档中有多个光标。</p>\n<p><img src=\"32-multiselection.gif\" alt=\"32-multiselection\"></p>\n<h2 id=\"多列选择（Column-Selection）\"><a href=\"#多列选择（Column-Selection）\" class=\"headerlink\" title=\"多列选择（Column Selection）\"></a>多列选择（Column Selection）</h2><ul>\n<li>Mouse(ubuntu上无效): Alt+鼠标拖拽  </li>\n<li>Mac : <strong> Cmd+Shift+8 </strong>  </li>\n<li>Windows/Linux: <strong> Shift+Alt+Insert </strong></li>\n</ul>\n<p><img src=\"33-columnselection.gif\" alt=\" 33-columnselection.gif\"></p>\n<blockquote>\n<p>和多行编辑的区别在于，多列编辑只能是每一行的相同列一起编辑。</p>\n</blockquote>\n<h2 id=\"后缀补全（Postfix-Completion）\"><a href=\"#后缀补全（Postfix-Completion）\" class=\"headerlink\" title=\"后缀补全（Postfix Completion）\"></a>后缀补全（Postfix Completion）</h2><p>这个不是非常直观的，但是相当的给力，基本上，它是无需按一连串左键到头部，实现方法的包裹的最好的方式了。<br>比较常用的有：</p>\n<ul>\n<li>.for (for a foreach)</li>\n<li>.format (wraps a string in String.format())</li>\n<li>.cast (wraps a statement in a type cast)</li>\n</ul>\n<p><img src=\"33-postfixcompletion.gif\" alt=\"33-postfixcompletion\"></p>\n<h2 id=\"与剪切板代码进行比较（Compare-With-Clipboard）\"><a href=\"#与剪切板代码进行比较（Compare-With-Clipboard）\" class=\"headerlink\" title=\"与剪切板代码进行比较（Compare With Clipboard）\"></a>与剪切板代码进行比较（Compare With Clipboard）</h2><ul>\n<li>Mouse: right-click the selection and select Compare With Clipboard  </li>\n<li>Find action: compare with clipboard</li>\n</ul>\n<p>用来比较当前你选择的代码和剪切板中的代码有什么区别。个人觉得用处不大。<br><img src=\"34-comparewithclipboard.gif\" alt=\"34-comparewithclipboard\"></p>\n<h2 id=\"停止进程\"><a href=\"#停止进程\" class=\"headerlink\" title=\"停止进程\"></a>停止进程</h2><ul>\n<li>Mac : Cmd+F2</li>\n<li>Windows/Linux: Ctrl+F2</li>\n</ul>\n<p>将会终止正在运行的最近的task或者显示一个可选的可能需要终止的task列表。用于停止调试或者终止一个build。</p>\n<p><img src=\"35-stoprocess.gif\" alt=\"35-stoprocess\"></p>\n<h2 id=\"VCS-操作弹窗\"><a href=\"#VCS-操作弹窗\" class=\"headerlink\" title=\"VCS 操作弹窗\"></a>VCS 操作弹窗</h2><p>Mac: <strong> Ctrl+V </strong><br>Windows/Linux: <strong> Alt+` </strong><br>显示一些常用的版本控制命令。如git commit。  </p>\n<p><img src=\"37-vcspopup.gif\" alt=\"37-vcspopup\"></p>\n<h2 id=\"与分支进行比较（Compare-With-Branch-Git-）\"><a href=\"#与分支进行比较（Compare-With-Branch-Git-）\" class=\"headerlink\" title=\"与分支进行比较（Compare With Branch (Git)）\"></a>与分支进行比较（Compare With Branch (Git)）</h2><p>Menu (for git): <strong> VCS -&gt; Git -&gt; Compare With Branch </strong><br>Find Actions: <strong> Compare With Branch </strong>  </p>\n<p>如果你的项目是在git下，你可以同另一个分支比较你的文件或者文件夹。特别用来比较你的修改和主分支差异多大。</p>\n<p><img src=\"38-comparewithbranch.gif\" alt=\"38-comparewithbranch\"></p>\n<h2 id=\"回车键和TAB键的区别\"><a href=\"#回车键和TAB键的区别\" class=\"headerlink\" title=\"回车键和TAB键的区别\"></a>回车键和TAB键的区别</h2><p>你可以使用Enter或Tab来自动补全代码。它们之间有一个有趣的差异：使用Enter将会自动完成语句。使用Tab将会自动完成删除光标到下一个点号，括号，分号或空格出现前的内容。</p>\n<p><img src=\"45-codecompletionentertab.gif\" alt=\"45-codecompletionentertab\"></p>\n<h2 id=\"跳转到父类的方法\"><a href=\"#跳转到父类的方法\" class=\"headerlink\" title=\"跳转到父类的方法\"></a>跳转到父类的方法</h2><p>Mac: <strong> Cmd+U </strong><br>Windows/Linux: <strong> Ctrl+U </strong>  </p>\n<p>如果光标在一个复写自父类的方法中（例如Activity#onCreate()方法），使用该快捷键，将会到达该方法的父类的实现。如果光标停留在类名上，则跳转到父类。</p>\n<p><img src=\"39-navigatetoparent.gif\" alt=\"39-navigatetoparent\"></p>\n<h2 id=\"返回到编辑器（Return-to-the-Editor）\"><a href=\"#返回到编辑器（Return-to-the-Editor）\" class=\"headerlink\" title=\"返回到编辑器（Return to the Editor）\"></a>返回到编辑器（Return to the Editor）</h2><p>返回并不关闭面板：Escape<br>返回并关闭面板：Shift+Escape</p>\n<p><img src=\"40-returntoeditor.gif\" alt=\"40-returntoeditor\"></p>\n<h2 id=\"跳到最近使用的工具窗口\"><a href=\"#跳到最近使用的工具窗口\" class=\"headerlink\" title=\"跳到最近使用的工具窗口\"></a>跳到最近使用的工具窗口</h2><p>Mac:F12<br>Windows/Linux:F12  </p>\n<p>有时候，你从面板返回到编辑器，但是你发现不得不再返回到这个面板。例如：浏览find usages。使用这个快捷键，你可以不用鼠标返回到这个面板。</p>\n<p><img src=\"41-lasttoolwindow.gif\" alt=\"41-lasttoolwindow\"></p>\n<h2 id=\"隐藏所有面板（Hide-All-Panels）\"><a href=\"#隐藏所有面板（Hide-All-Panels）\" class=\"headerlink\" title=\"隐藏所有面板（Hide All Panels）\"></a>隐藏所有面板（Hide All Panels）</h2><p>Mac: <strong> Cmd+Shift+F12 </strong><br>windows/linux: <strong> Ctrl+Shift+F12 </strong>  </p>\n<p>让编辑器进入某种形式上的全屏模式。再次调用这个快捷键可以返回所有面板到它们之前的状态。</p>\n<p><img src=\"42-hideallwindows.gif\" alt=\"42-hideallwindows\"></p>\n<h2 id=\"通过编号打开面板\"><a href=\"#通过编号打开面板\" class=\"headerlink\" title=\"通过编号打开面板\"></a>通过编号打开面板</h2><p>Mac: <strong> Cmd+Number </strong><br>windows/linux: <strong> Alt+Number </strong>  </p>\n<p>可以通过面板上标签对应的数字打开相应的面板。</p>\n<p><img src=\"43-openpanelbynumber.gif\" alt=\"43-openpanelbynumber\"></p>\n<h2 id=\"参数信息\"><a href=\"#参数信息\" class=\"headerlink\" title=\"参数信息\"></a>参数信息</h2><p>Mac:<strong>  Cmd+P </strong><br>windows/linux: <strong> Ctrl+P </strong>    </p>\n<p><img src=\"44-parameterinfo.gif\" alt=\"44-parameterinfo\"></p>\n<h2 id=\"切换器\"><a href=\"#切换器\" class=\"headerlink\" title=\"切换器\"></a>切换器</h2><p>Shortcut:<strong> Ctrl+Tab </strong></p>\n<p>这个功能和IDE的alt+tab/cmd+tab差不多。它允许你导航到一个tab或一个panel。一旦它被打开，只要你按住ctrl键，你可以使用数字或字母快捷键快速导航。你也可以通过按下backspace关闭一个打开的文件。</p>\n<p><img src=\"46-switcher.gif\" alt=\"46-switcher\"></p>\n<h2 id=\"上下文信息（Context-Info）\"><a href=\"#上下文信息（Context-Info）\" class=\"headerlink\" title=\"上下文信息（Context Info）\"></a>上下文信息（Context Info）</h2><p>Shortcut:<strong> Ctrl+Shift+Q </strong>    </p>\n<p>这个将会显示你当前位置，当你的定义范围超出滚动的区域时。通常，这将会是类或内部类的名称，但它也可能是当前方法名。在我看来，它最好的使用是快速查看当前类继承或实现。 它也可以在xml文件中使用。</p>\n<p><img src=\"47-contextinfo.gif\" alt=\"47-contextinfo\"></p>\n<h2 id=\"代码重构\"><a href=\"#代码重构\" class=\"headerlink\" title=\"代码重构\"></a>代码重构</h2><p>Mac: <strong> Ctrl+T </strong><br>Windows/Linux: <strong> Ctrl+Alt+Shift+T </strong><br>这是一个针对当前选择的代码显示上下文所有可用的重构的快捷键。这个列表可以通过键盘进行检索并且你也可以使用左侧的数字进行快速访问</p>\n<p><img src=\"48-refactorthis.png\" alt=\"48-refactorthis\"></p>\n<h2 id=\"跳转到最近编辑的文件（Recently-Changed-Files）\"><a href=\"#跳转到最近编辑的文件（Recently-Changed-Files）\" class=\"headerlink\" title=\"跳转到最近编辑的文件（Recently Changed Files）\"></a>跳转到最近编辑的文件（Recently Changed Files）</h2><p>Mac: <strong> Cmd+Shift+E </strong><br>Windows/Linux: <strong> Ctrl+Shift+E </strong>  </p>\n<p>这个和“Recents”弹出框有所不同，这个列出是在本地最近被修改的文件。</p>\n<p><img src=\"49-recentlyedited.gif\" alt=\"49-recentlyedited\"></p>\n<h2 id=\"提取变量\"><a href=\"#提取变量\" class=\"headerlink\" title=\"提取变量\"></a>提取变量</h2><p>Mac:<strong> Cmd+Alt+V </strong><br>Windows/Linux:<strong> Ctrl+Alt+V </strong></p>\n<p>这是一个可以不用通过重构菜单，来提取变量的快捷键。  </p>\n<p><img src=\"51-extractvariable.gif\" alt=\"51-extractvariable\"></p>\n<blockquote>\n<p>额外的技巧：<br>如果你想修改声明类型为一些更通用的（如：List而不是ArrayList）,你可以使用Shift+Tab它会给出一个可用类型的列表。</p>\n</blockquote>\n<h2 id=\"提取参数\"><a href=\"#提取参数\" class=\"headerlink\" title=\"提取参数\"></a>提取参数</h2><p>Mac:Cmd+Alt+P<br>Windows/Linux:Ctrl+Alt+P</p>\n<p>这是一个不用通过重构菜单提取参数的快捷键。<br>这个功能是有用的当你意识到一个方法可能是泛型时通过提取一部分做为一个参数。它作用的方式是它会使用当前值作为一个参数然后复制原先的值作为每个调用者的参数。<br><img src=\"52-extractparam.gif\" alt=\"52-extractparam\"></p>\n<blockquote>\n<p>额外的技巧：<br>你也可以保持原来的方法使用它声明一个新方法通过“delegate”选项。  </p>\n</blockquote>\n<h2 id=\"提取方法\"><a href=\"#提取方法\" class=\"headerlink\" title=\"提取方法\"></a>提取方法</h2><p>Mac: Cmd+Alt+M<br>Windows/Linux: Ctrl+Alt+M</p>\n<p>可以提取一个代码块做为一个新的方法。这个功能是相当有用的。无论什么时候你遇到一个开始变得有点复杂的方法，你可以使用这个安全地抽取一部分到另一个方法。我所说的安全是因为IDE不会像我们可能会犯一个愚蠢的复制粘贴错误。</p>\n<p><img src=\"53-extractmethod.gif\" alt=\"53-extractmethod\"></p>\n<blockquote>\n<p>额外的技巧：<br>当你在抽取对话框，你可以修改方法的可见性和参数名称。</p>\n</blockquote>\n<h2 id=\"inline\"><a href=\"#inline\" class=\"headerlink\" title=\"inline\"></a>inline</h2><p>Mac: Cmd+Alt+N<br>Windows/Linux: Ctrl+Alt+N</p>\n<p>你使用提取有一点疯狂并且现在有太多的东西？你可以使用反向操作，它叫做“inline”。<br>它可以作用于方法，Fields，参数和变量。</p>\n<p><img src=\"54-inline.gif\" alt=\"54-inline\"></p>\n<h2 id=\"重命名\"><a href=\"#重命名\" class=\"headerlink\" title=\"重命名\"></a>重命名</h2><p>快捷键：<strong> Shift+F6 </strong><br><img src=\"55-rename.gif\" alt=\"55-rename.gif\"></p>\n<h2 id=\"Pull-Up-Push-Down\"><a href=\"#Pull-Up-Push-Down\" class=\"headerlink\" title=\"Pull Up / Push Down\"></a>Pull Up / Push Down</h2><p>Mac: Ctrl+T 然后选择成员<br>Windows/Linux: Ctrl+Alt+Shift+T 然后选择成员  </p>\n<p>当我们谈论上拉成员，我们的意思是我们将会让当前类的一些成员（通常是方法或field）发送它到父类或接口。</p>\n<p>如果继承于一个类，内容会被移动。如果是实现的一个接口，它将会声明方法作为接口的一部分，在你的类中保持原有的方法并且添加 @Override注解。<br>当我们谈论下推成员，这正好是反向操作，我们会从父类或接口发送一些成员到子类</p>\n<p><img src=\"56-pullupdown.gif\" alt=\"56-pullupdown.gif\"></p>\n<h1 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h1><table>\n<thead>\n<tr>\n<th>按键</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Ctrl(Command)+C</td>\n<td>复制当前行或选中的内容</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+D</td>\n<td>粘贴当前行或选中的内容</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+X</td>\n<td>剪切当前行或选中的内容</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Y</td>\n<td>删除行</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Z</td>\n<td>倒退</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Shift+Z</td>\n<td>向前</td>\n</tr>\n<tr>\n<td>Alt(Option)+Enter</td>\n<td>自动修正</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Alt(Option)+L</td>\n<td>格式化代码</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Alt(Option)+I</td>\n<td>将选中的代码进行自动缩进编排</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Alt(Option)+O</td>\n<td>优化导入的类和包</td>\n</tr>\n<tr>\n<td>Alt(Option)+Insert</td>\n<td>得到一些Intention Action，可以生成构造器、Getter、Setter、将 == 改为equals() 等</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Shift+V</td>\n<td>选最近使用的剪贴板内容并插入</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Alt(Option)+Shift+V</td>\n<td>简单粘贴</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Shift+Insert</td>\n<td>选最近使用的剪贴板内容并插入（同Ctrl(Command)+Shift+V）</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Enter</td>\n<td>在当前行的上面插入新行，并移动光标到新行（此功能光标在行首时有效）</td>\n</tr>\n<tr>\n<td>Shift+Enter</td>\n<td>在当前行的下面插入新行，并移动光标到新行</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+J</td>\n<td>自动代码</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Alt(Option)+T</td>\n<td>把选中的代码放在 try{} 、if{} 、 else{} 里</td>\n</tr>\n<tr>\n<td>Shift+Alt(Option)+Insert</td>\n<td>竖编辑模式</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+ /</td>\n<td>注释 //</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Shift+ /</td>\n<td>注释 /…/</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Shift+J</td>\n<td>合并成一行</td>\n</tr>\n<tr>\n<td>F2/Shift+F2</td>\n<td>跳转到下/上一个错误语句处</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Shift+Back</td>\n<td>跳转到上次编辑的地方</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Alt(Option)+Space</td>\n<td>类名自动完成</td>\n</tr>\n<tr>\n<td>Shift+Alt(Option)+Up/Down</td>\n<td>内容向上/下移动</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Shift+Up/Down</td>\n<td>语句向上/下移动</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Shift+U</td>\n<td>大小写切换</td>\n</tr>\n<tr>\n<td>Tab</td>\n<td>代码标签输入完成后，按 Tab，生成代码</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Backspace</td>\n<td>按单词删除</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Shift+Enter</td>\n<td>语句完成</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Alt(Option)+J</td>\n<td>用动态模板环绕</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"文件\"><a href=\"#文件\" class=\"headerlink\" title=\"文件\"></a>文件</h2><table>\n<thead>\n<tr>\n<th>按键</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Ctrl(Command)+F12</td>\n<td>显示当前文件的结构</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+H</td>\n<td>显示类继承结构图</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Q</td>\n<td>显示注释文档</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+P</td>\n<td>方法参数提示</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+U</td>\n<td>打开当前类的父类或者实现的接口</td>\n</tr>\n<tr>\n<td>Alt(Option)+Left/Right</td>\n<td>切换代码视图</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Alt(Option)+Left/Right</td>\n<td>返回上次编辑的位置</td>\n</tr>\n<tr>\n<td>Alt(Option)+Up/Down</td>\n<td>在方法间快速移动定位</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+B</td>\n<td>快速打开光标处的类或方法</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+W</td>\n<td>选中代码，连续按会有其他效果</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Shift+W</td>\n<td>取消选择光标所在词</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+ - / +</td>\n<td>折叠/展开代码</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Shift+ - / +</td>\n<td>折叠/展开全部代码</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Shift+.</td>\n<td>折叠/展开当前花括号中的代码</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+ ] / [</td>\n<td>跳转到代码块结束/开始处</td>\n</tr>\n<tr>\n<td>F2 或 Shift+F2</td>\n<td>高亮错误或警告快速定位</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Shift+C</td>\n<td>复制路径</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Alt(Option)+Shift+C</td>\n<td>复制引用，必须选择类名</td>\n</tr>\n<tr>\n<td>Alt(Option)+Up/Down</td>\n<td>在方法间快速移动定位</td>\n</tr>\n<tr>\n<td>Shift+F1</td>\n<td>要打开编辑器光标字符处使用的类或者方法 Java 文档的浏览器</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+G</td>\n<td>定位行</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h2><table>\n<thead>\n<tr>\n<th>按键</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Ctrl(Command)+F</td>\n<td>在当前窗口查找文本</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Shift+F</td>\n<td>在指定环境下查找文本</td>\n</tr>\n<tr>\n<td>F3</td>\n<td>向下查找关键字出现位置</td>\n</tr>\n<tr>\n<td>Shift+F3</td>\n<td>向上一个关键字出现位置</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+R</td>\n<td>在当前窗口替换文本</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Shift+R</td>\n<td>在指定窗口替换文本</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+N</td>\n<td>查找类</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Shift+N</td>\n<td>查找文件</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Shift+Alt(Option)+N</td>\n<td>查找项目中的方法或变量</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+B</td>\n<td>查找变量的来源</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Alt(Option)+B</td>\n<td>快速打开光标处的类或方法</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Shift+B</td>\n<td>跳转到类或方法实现处</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+E</td>\n<td>最近打开的文件</td>\n</tr>\n<tr>\n<td>Alt(Option)+F3</td>\n<td>快速查找，效果和Ctrl(Command)+F相同</td>\n</tr>\n<tr>\n<td>F4</td>\n<td>跳转至定义变量的位置</td>\n</tr>\n<tr>\n<td>Alt(Option)+F7</td>\n<td>查询当前元素在工程中的引用</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+F7</td>\n<td>查询当前元素在当前文件中的引用，然后按 F3 可以选择</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Alt(Option)+F7</td>\n<td>选中查询当前元素在工程中的引用</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Shift+F7</td>\n<td>高亮显示匹配的字符，按 Esc 高亮消失</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Alt(Option)+F7</td>\n<td>查找某个方法的所有调用地方</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Shift+Alt(Option)+N</td>\n<td>查找类中的方法或变量</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Shift+O</td>\n<td>弹出显示查找内容</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Alt(Option)+Up/Down</td>\n<td>快速跳转搜索结果</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Shift+S</td>\n<td>高级搜索、搜索结构</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"重构\"><a href=\"#重构\" class=\"headerlink\" title=\"重构\"></a>重构</h2><table>\n<thead>\n<tr>\n<th>按键</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>F5</td>\n<td>复制</td>\n</tr>\n<tr>\n<td>F6</td>\n<td>移动</td>\n</tr>\n<tr>\n<td>Alt(Option)+Delete</td>\n<td>安全删除</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+U</td>\n<td>转到父类</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+O</td>\n<td>重写父类的方法</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+I</td>\n<td>实现方法</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Alt(Option)+N</td>\n<td>内联</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Alt(Option)+Shift+T</td>\n<td>弹出重构菜单</td>\n</tr>\n<tr>\n<td>Shift+F6</td>\n<td>重构-重命名</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Alt(Option)+M</td>\n<td>提取代码组成方法</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Alt(Option)+C</td>\n<td>将变量更改为常量</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Alt(Option)+V</td>\n<td>定义变量引用当前对象或者方法的返回值</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Alt(Option)+F</td>\n<td>将局部变量更改为类的成员变量</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Alt(Option)+P</td>\n<td>将变量更改为方法的参数</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h2><table>\n<thead>\n<tr>\n<th>按键</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>F8</td>\n<td>跳到下一步</td>\n</tr>\n<tr>\n<td>Shift+F8</td>\n<td>跳出函数、跳到下一个断点</td>\n</tr>\n<tr>\n<td>Alt(Option)+Shift+F8</td>\n<td>强制跳出函数</td>\n</tr>\n<tr>\n<td>F7</td>\n<td>进入代码</td>\n</tr>\n<tr>\n<td>Shift+F7</td>\n<td>智能进入代码</td>\n</tr>\n<tr>\n<td>Alt(Option)+Shift+F7</td>\n<td>强制进入代码</td>\n</tr>\n<tr>\n<td>Alt(Option)+F9</td>\n<td>运行至光标处</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Alt(Option)+F9</td>\n<td>强制运行至光标处</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+F2</td>\n<td>停止运行</td>\n</tr>\n<tr>\n<td>Alt(Option)+F8</td>\n<td>计算变量值</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"VCS\"><a href=\"#VCS\" class=\"headerlink\" title=\"VCS\"></a>VCS</h2><table>\n<thead>\n<tr>\n<th>按键</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Alt(Option)+ ~</td>\n<td>VCS 操作菜单</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+K</td>\n<td>提交更改</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+T</td>\n<td>更新项目</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Alt(Option)+Shift+D</td>\n<td>显示变化</td>\n</tr>\n</tbody>\n</table>\n<p>谢谢阅读完这篇整理的文章，希望从中能够收获知识。<br>转载请注明出处：<a href=\"www.aman.site\">www.aman.site</a></p>\n<blockquote>\n<p>参考文献：<br><a href=\"https://greenrobot.me/android-dev-tool/android-studio-dev-tips-1/\" target=\"_blank\" rel=\"external\">Android Cool Posts</a><br><a href=\"http://www.developerphil.com/android-studio-tips-of-the-day-roundup-1/\" target=\"_blank\" rel=\"external\">Android Studio Tips Of the Day - Roundup #1  </a><br><a href=\"http://www.developerphil.com/android-studio-tips-of-the-day-roundup-2/\" target=\"_blank\" rel=\"external\">Android Studio Tips Of the Day - Roundup #2  </a><br><a href=\"http://www.developerphil.com/android-studio-tips-of-the-day-roundup-3/\" target=\"_blank\" rel=\"external\">Android Studio Tips Of the Day - Roundup #3  </a><br><a href=\"http://www.developerphil.com/android-studio-tips-of-the-day-roundup-4/\" target=\"_blank\" rel=\"external\">Android Studio Tips Of the Day - Roundup #4  </a><br><a href=\"http://www.developerphil.com/android-studio-tips-of-the-day-roundup-5/\" target=\"_blank\" rel=\"external\">Android Studio Tips Of the Day - Roundup #5  </a><br><a href=\"http://www.developerphil.com/android-studio-tips-of-the-day-roundup-6/\" target=\"_blank\" rel=\"external\">Android Studio Tips Of the Day - Roundup #6  </a>  </p>\n</blockquote>\n","excerpt":"<h2 id=\"高亮所有\"><a href=\"#高亮所有\" class=\"headerlink\" title=\"高亮所有\"></a>高亮所有</h2><p>os X: <strong> command + shift + F7  </strong><br>Windows Or Linux: <strong> ctrl+Shift+F7 </strong>  </p>\n<p><img src=\"01-highlight.gif\" alt=\"hight light all\"></p>\n<ul>\n<li>高亮代码方法中的“return” 或者 “throw” 也会高亮这个方法的所有出口。</li>\n<li>高亮后可使用”F3”或“shift + F3”上下选择。</li>\n<li>Esc 或者再次使用该快捷键，可以取消高亮。</li>\n</ul>","more":"<h2 id=\"在方法和内部类之间跳转\"><a href=\"#在方法和内部类之间跳转\" class=\"headerlink\" title=\"在方法和内部类之间跳转\"></a>在方法和内部类之间跳转</h2><p>OS X: <strong> Ctrl + ↑ / ↓ </strong><br>Windows Or Linux: <strong> Alt+ ↑ / ↓</strong>  </p>\n<p><img src=\"02-move_between_methods.gif\" alt=\"02-move_between_methods\"></p>\n<h2 id=\"跳转到已经打开的下一个-上一个文件\"><a href=\"#跳转到已经打开的下一个-上一个文件\" class=\"headerlink\" title=\"跳转到已经打开的下一个/上一个文件\"></a>跳转到已经打开的下一个/上一个文件</h2><p>OS X: <strong> Ctrl + ← / → </strong><br>Windows Or Linux: <strong> Alt+  ← / →</strong>  </p>\n<h2 id=\"快速定位到类中的方法-内部类-成员变量\"><a href=\"#快速定位到类中的方法-内部类-成员变量\" class=\"headerlink\" title=\"快速定位到类中的方法/内部类/成员变量\"></a>快速定位到类中的方法/内部类/成员变量</h2><p>OS X: <strong> Command+F12</strong><br>Windows Or Linux: <strong> Ctrl+F12 </strong>   </p>\n<p><img src=\"03-filestructure.gif\" alt=\"03-filestructure\"></p>\n<ul>\n<li>你可以使用驼峰字符来过滤候选方法列表。例如:输入 “oCr” 就可以找到 “onCreate”方法。</li>\n<li>你可以选择是否展示继承的成员变量。如勾选了”show inherited members”就可以很方便的查找继承自父类的成员变量。</li>\n<li>你可以选择是否展示匿名类。如勾选了”show Anonymous classes”, 就可以很方便的查找 OnClickListener里面的OnClick方法了。</li>\n</ul>\n<h2 id=\"显示方法的调用层级关系\"><a href=\"#显示方法的调用层级关系\" class=\"headerlink\" title=\"显示方法的调用层级关系\"></a>显示方法的调用层级关系</h2><p>OS X: <strong> Ctrl+Alt+H </strong><br>Windows Or Linux: <strong> Ctrl+Alt+H </strong>  </p>\n<p><img src=\"04-callinghierarchy.gif\" alt=\"04-callinghierarchy\"></p>\n<blockquote>\n<p>注，ubuntu上与输入法快捷键冲突无法使用</p>\n</blockquote>\n<h2 id=\"快速显示变量或方法的定义\"><a href=\"#快速显示变量或方法的定义\" class=\"headerlink\" title=\"快速显示变量或方法的定义\"></a>快速显示变量或方法的定义</h2><p>OS X: <strong> Alt+Space</strong><br>Windows Or Linux: <strong> Ctrl+Shift+i</strong><br>如果你想立马知道某个类或者方法的来源同时又不想丢掉当前的编码环境，你可以试试这个快捷键。  </p>\n<p><img src=\"05-quickdefinition.gif\" alt=\"05-quickdefinition\"></p>\n<h2 id=\"快速收缩或者展开代码块\"><a href=\"#快速收缩或者展开代码块\" class=\"headerlink\" title=\"快速收缩或者展开代码块\"></a>快速收缩或者展开代码块</h2><p>OS X : <strong> Alt + +/- </strong><br>Windows Or Linux: <strong> Ctrl +/- </strong></p>\n<p><img src=\"06-codefolding.gif\" alt=\"06-codefolding\"></p>\n<ul>\n<li>可以使用 Ctrl + Shift +/- ** 收缩或者展开文件中的所有方法</li>\n<li>多次使用会逐级收缩或者展开<blockquote>\n<p>你可以在“Editor → Code Folding”自定义你的代码折叠范围</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"书签\"><a href=\"#书签\" class=\"headerlink\" title=\"书签\"></a>书签</h2><h3 id=\"默认书签\"><a href=\"#默认书签\" class=\"headerlink\" title=\"默认书签\"></a>默认书签</h3><p>OS X : <strong> F3 </strong><br>Windows Or Linux : <strong> F11 </strong></p>\n<h3 id=\"带字母或者数字的标签\"><a href=\"#带字母或者数字的标签\" class=\"headerlink\" title=\"带字母或者数字的标签\"></a>带字母或者数字的标签</h3><p>OS X : <strong> Alt+F3 </strong><br>Windows Or Linux : <strong> Ctrl+F11 </strong>   </p>\n<blockquote>\n<p>按下此快捷键就可以在你的当前光标所在行打上标签，并提供字母或者数字标记。如果你选择的是数字标记，那么可以通过ctrl+对应的数字直接跳转至相应位置。  </p>\n</blockquote>\n<h3 id=\"展示标签\"><a href=\"#展示标签\" class=\"headerlink\" title=\"展示标签\"></a>展示标签</h3><p>OS X : <strong> Command+F3</strong><br>Windows Or Linux : <strong> Shift+F11</strong>  </p>\n<p><img src=\"07-bookmarks.gif\" alt=\"07-bookmarks\"></p>\n<h2 id=\"查找Android-Studio的菜单选项\"><a href=\"#查找Android-Studio的菜单选项\" class=\"headerlink\" title=\"查找Android Studio的菜单选项\"></a>查找Android Studio的菜单选项</h2><p>OS X :   <strong> Command+Shift+A</strong><br>Windows Or Linux : <strong> Ctrl+Shift+A</strong><br>你可以通过输入菜单名来查找任意的菜单选项，这对那些使用频率低的操作很有效果。</p>\n<p><img src=\"08-findaction.gif\" alt=\"08-findaction\"></p>\n<blockquote>\n<p>如果这个选项有对应的快捷方式，那么这个快捷键会在列表旁边显示。  </p>\n</blockquote>\n<h2 id=\"行操作\"><a href=\"#行操作\" class=\"headerlink\" title=\"行操作\"></a>行操作</h2><hr>\n<h3 id=\"移动整行\"><a href=\"#移动整行\" class=\"headerlink\" title=\"移动整行\"></a>移动整行</h3><p>OS X : <strong> Alt+Shift+ ↑ / ↓</strong><br>Windows Or Linux: <strong> Alt+Shift+ ↑ / ↓</strong>  </p>\n<p><img src=\"09-movelines.gif\" alt=\"09-movelines\"></p>\n<h3 id=\"代码行合并\"><a href=\"#代码行合并\" class=\"headerlink\" title=\"代码行合并\"></a>代码行合并</h3><p>Mac OS : <strong> Ctrl+Shift+j </strong><br>Windows &amp; Linux : <strong> Ctrl+Shift+j </strong><br>按照语法规则将可以合并的代码行进行合并，保持代码精简。它主要适用以下规则：  </p>\n<ul>\n<li>将变量声明定义和赋值合并;</li>\n<li>合并多行字符串的时候，会移掉“+“和双引号;</li>\n<li>合并两行评论代码时，评论变成一行，会去掉另一行的“//”;</li>\n</ul>\n<p><img src=\"18-joinlines.gif\" alt=\"18-joinlines\"></p>\n<h3 id=\"删除整行\"><a href=\"#删除整行\" class=\"headerlink\" title=\"删除整行\"></a>删除整行</h3><p>OS X : <strong> Command + Backspace</strong><br>Windows Or Linux : <strong> Ctrl + Y</strong>  </p>\n<p><img src=\"10-deleteline.gif\" alt=\"10-deleteline\"></p>\n<h3 id=\"复制整行\"><a href=\"#复制整行\" class=\"headerlink\" title=\"复制整行\"></a>复制整行</h3><p>Mac OS: <strong> Command+D</strong><br>Windows &amp; Linux: <strong> Ctrl+D</strong><br>这个快捷键的厉害之处在于它会复制当前行同时又不会影响系统的剪贴板。<br><img src=\"11-duplicate_lines.gif\" alt=\"11-duplicate_lines\"></p>\n<hr>\n<h2 id=\"上下移动整个方法\"><a href=\"#上下移动整个方法\" class=\"headerlink\" title=\"上下移动整个方法\"></a>上下移动整个方法</h2><p>Mac OS : <strong> Command+Alt+↑/↓ </strong><br>Windows &amp; Linux : <strong> Ctrl+Shift+↑/↓ </strong>  </p>\n<p><img src=\"15-movemethods.gif\" alt=\"15-movemethods\"></p>\n<h2 id=\"展开或者收缩选择区域\"><a href=\"#展开或者收缩选择区域\" class=\"headerlink\" title=\"展开或者收缩选择区域\"></a>展开或者收缩选择区域</h2><p>Mac OS : <strong> alt + ↑/↓ </strong><br>Windows &amp; Linux: <strong> (Ctrl+w )/(Ctrl+Shift+w) </strong><br>扩大（或者缩小）当前的选择范围。比如当前选中一个变量，此操作会把选中范围扩展至句子，方法等。</p>\n<p><img src=\"12-expand_shrink_selection.gif\" alt=\"12-expand_shrink_selection\"></p>\n<h2 id=\"包裹代码段\"><a href=\"#包裹代码段\" class=\"headerlink\" title=\"包裹代码段\"></a>包裹代码段</h2><p>Mac OS : <strong> Command+Alt+t </strong><br>Windows &amp; Linux : <strong> Ctrl+Alt+t </strong><br>选中一段代码段，然后使用if语句或者循环结构等包裹代码。  </p>\n<p><img src=\"13-surround_with.gif\" alt=\"13-surround_with.gif\">  </p>\n<h2 id=\"删除代码块的包裹\"><a href=\"#删除代码块的包裹\" class=\"headerlink\" title=\"删除代码块的包裹\"></a>删除代码块的包裹</h2><p>Mac OS : <strong> Command+Shift+Delete </strong><br>Windows &amp; Linux : <strong> Ctrl+Shift+Delete </strong><br>移除代码结构中的包裹代码，比如 if 语句,  while 循环, 或者 try/catch 语句。<br><img src=\"20-unwrap.gif\" alt=\"20-unwrap\"></p>\n<h2 id=\"查询最近编辑的文件和使用的工作区\"><a href=\"#查询最近编辑的文件和使用的工作区\" class=\"headerlink\" title=\"查询最近编辑的文件和使用的工作区\"></a>查询最近编辑的文件和使用的工作区</h2><p>Mac OS : <strong> Command+e </strong><br>Windows &amp; Linux : <strong> Ctrl+e </strong>  </p>\n<p><img src=\"14-recents.gif\" alt=\"14-recents\"></p>\n<h2 id=\"代码模板\"><a href=\"#代码模板\" class=\"headerlink\" title=\"代码模板\"></a>代码模板</h2><p>Mac OS : <strong> Command+j </strong><br>Windows &amp; Linux : <strong> Ctrl+j </strong><br>此快捷键可以让你迅速地在文件中插入预留的代码片段。你也可以定制你自己的代码片段。</p>\n<p><img src=\"15-live_templates.gif\" alt=\"15-live_templates\"></p>\n<h2 id=\"代码结构自动补全\"><a href=\"#代码结构自动补全\" class=\"headerlink\" title=\"代码结构自动补全\"></a>代码结构自动补全</h2><p>Mac OS : <strong> Command+Shift+Enter </strong><br>Windows &amp; Linux : <strong> Ctrl+Shift+Enter </strong><br>这个操作会将还未完成的代码结构补全。一般可以补全的情形如下：</p>\n<ul>\n<li>在代码行后面添加分号；</li>\n<li>为 if, while 或者 for 语句添加括号</li>\n<li>为方法声明添加括号。</li>\n</ul>\n<p><img src=\"16-completestatement.gif\" alt=\"16-completestatement\"></p>\n<h2 id=\"回到上次编辑的位置\"><a href=\"#回到上次编辑的位置\" class=\"headerlink\" title=\"回到上次编辑的位置\"></a>回到上次编辑的位置</h2><p>Mac OS : <strong> Command+Shift+backspace </strong><br>Windows &amp; Linux : <strong> Ctrl+Shift+backspace </strong>  </p>\n<p><img src=\"17-navigate-previous-changes.gif\" alt=\"17-navigate-previous-changes\"></p>\n<h2 id=\"在代码中根据标签选择功能（Select-In）\"><a href=\"#在代码中根据标签选择功能（Select-In）\" class=\"headerlink\" title=\"在代码中根据标签选择功能（Select In）\"></a>在代码中根据标签选择功能（Select In）</h2><p>Mac OS : <strong> Alt+F1 </strong><br>Windows:<strong> Alt+F1 </strong><br>Linux : 与系统快捷键冲突<br>在代码中执行此快捷方式可以快速定位到select Target所示的功能中。</p>\n<p><img src=\"19-select-in.gif\" alt=\"19-select-in\"></p>\n<h2 id=\"调试常用快捷键\"><a href=\"#调试常用快捷键\" class=\"headerlink\" title=\"调试常用快捷键\"></a>调试常用快捷键</h2><hr>\n<h3 id=\"添加断点（Toggle-Breakpoints）\"><a href=\"#添加断点（Toggle-Breakpoints）\" class=\"headerlink\" title=\"添加断点（Toggle Breakpoints）\"></a>添加断点（Toggle Breakpoints）</h3><p>OSX: <strong> Cmd+F8 </strong><br>Windows/Linux: <strong> Ctrl+F8 </strong><br>相应大家都知道使用鼠标左键点击行首添加断点，使用快捷键添加断点的方式如下：<br><img src=\"21-togglebreakpoints.gif\" alt=\"21-togglebreakpoints\"></p>\n<h3 id=\"条件断点（Conditional-Breakpoints）\"><a href=\"#条件断点（Conditional-Breakpoints）\" class=\"headerlink\" title=\"条件断点（Conditional Breakpoints）\"></a>条件断点（Conditional Breakpoints）</h3><p>通过右键断点，可以对一个断点加入条件。只有当满足条件时，才会进入到断点中。调试神技，只对自己关心的情况进行调试，不浪费时间。</p>\n<p><img src=\"22-conditionalbreakpoint.gif\" alt=\"22-conditionalbreakpoint\"></p>\n<h3 id=\"在断点上打log\"><a href=\"#在断点上打log\" class=\"headerlink\" title=\"在断点上打log\"></a>在断点上打log</h3><p>如果你不想在调试过程中添加log，并且重新编译，可以在断点直接打log，查看结果。<br>鼠标右键点击断点，取消选择“suspend”,并在 “Log evaluated Expression” 中输入你想要打印的log信息。实例如下：<br><img src=\"23-loggingbreakpoints.gif\" alt=\"23-loggingbreakpoints\"></p>\n<h3 id=\"临时断点\"><a href=\"#临时断点\" class=\"headerlink\" title=\"临时断点\"></a>临时断点</h3><p>鼠标（ubuntu上无效）：<strong> Alt+LeftClick </strong> in the left gutter<br>Mac: <strong> Cmd+Alt+Shift+F8 </strong><br>Windows/Linux: <strong> Ctrl+Alt+Shift+F8 </strong><br>这种方式可以添加一个临时断点，当第一次执行完后，会自动消失。</p>\n<h3 id=\"disable断点\"><a href=\"#disable断点\" class=\"headerlink\" title=\"disable断点\"></a>disable断点</h3><p>在已经完成了一些条件，或者打印了断点，不再需要这些断点的时候，你可以使这些断点无效。<br>Mouse(ubuntu 上无效):在已经存在的断点上按住ALT并点击左键： <strong> Alt+LeftClick </strong>   </p>\n<blockquote>\n<p>没有默认的快捷键，如果需要的话，可以创建快捷键。</p>\n</blockquote>\n<p><img src=\"25-disablebreakpoint.gif\" alt=\"25-disablebreakpoint\"></p>\n<h3 id=\"附加调试器\"><a href=\"#附加调试器\" class=\"headerlink\" title=\"附加调试器\"></a>附加调试器</h3><p>及时你没有在调试模式下启动app，你也可以通过以下方式开启调试器。你不需要重新在调试模式下调用app。这是非常有用的。<br>Mouse: 点击图标，选择“ Attach debugger to Android Process”</p>\n<blockquote>\n<p>没有默认的快捷键，如果需要的话，可以创建快捷键。</p>\n</blockquote>\n<h3 id=\"评估表达式（Evaluate-Expression）\"><a href=\"#评估表达式（Evaluate-Expression）\" class=\"headerlink\" title=\"评估表达式（Evaluate Expression）\"></a>评估表达式（Evaluate Expression）</h3><p>快捷键：<strong> Alt+F8 </strong><br>这个功能用来检查变量的内容，评估几乎任何有效的Java表达式。要知道，如果你转变了状态，它会保持下去，当你恢复程序的执行。<br><img src=\"27-evaluateexpression.gif\" alt=\"27-evaluateexpression\"></p>\n<h3 id=\"检查变量（Inspect-Variable）\"><a href=\"#检查变量（Inspect-Variable）\" class=\"headerlink\" title=\"检查变量（Inspect Variable）\"></a>检查变量（Inspect Variable）</h3><p>快捷键：在调试时，在表达式中按住ALT键点击鼠标左键<strong> Alt+LeftClick  </strong><br>不需要打开“Evaluate Expression”对话框，即可查看一个评估一个表达式。</p>\n<p><img src=\"28-mouse_evaluate_expression.gif\" alt=\"28-mouse_evaluate_expression\"></p>\n<h3 id=\"标记对象（Mark-Object）\"><a href=\"#标记对象（Mark-Object）\" class=\"headerlink\" title=\"标记对象（Mark Object）\"></a>标记对象（Mark Object）</h3><ul>\n<li>Mouse: 右击并选择 “Mark Object”  </li>\n<li>OSX : 选中对象，按 F3  </li>\n<li>Windows/Linux: 选中对象，按 F11  </li>\n</ul>\n<p>在调试过程中，你可以使用这个命令给特定的对象添加一个标签，以便于以后识别该对象。</p>\n<p><img src=\"29-markobject.gif\" alt=\"29-markobject\"></p>\n<h3 id=\"分析堆栈信息\"><a href=\"#分析堆栈信息\" class=\"headerlink\" title=\"分析堆栈信息\"></a>分析堆栈信息</h3><ul>\n<li>Menu: Analyze → Analyze Stacktrace</li>\n<li>Find Actions(ctrl+shift+a)输入”analyze stacktrace”即可查看堆栈信息。  </li>\n</ul>\n<p>可以从你的剪切板中加载log的堆栈信息，并且使得他是可点击的。对于我们从bug报告中摘取一段堆栈进行分析非常有利。  </p>\n<p><img src=\"30-analyzestacktrace.gif\" alt=\"30-analyzestacktrace\"></p>\n<blockquote>\n<p>你可以使用”ProGuard Unscramble”插件来分析混淆后的堆栈信息。</p>\n</blockquote>\n<h3 id=\"分析数据流\"><a href=\"#分析数据流\" class=\"headerlink\" title=\"分析数据流\"></a>分析数据流</h3><ul>\n<li>Menu: Analyze → Analyze Data Flow to Here</li>\n<li>Find action: Analyze Data Flow to Here</li>\n</ul>\n<p>可以查看当前变量、参数或field调用的路径！这是非常有用的当你进入到一个你不熟悉的代码环境中，并且你想了解这个参数是怎样传到这里的。<br>这也有一个反向操作“Analyze Data Flow from Here”，它将会显示变量、field或返回类型的被调用的路径。</p>\n<p><img src=\"31-analyzedataflow.gif\" alt=\"31-analyzedataflow\"></p>\n<h2 id=\"显示正在执行的行（Show-Execution-Point）\"><a href=\"#显示正在执行的行（Show-Execution-Point）\" class=\"headerlink\" title=\"显示正在执行的行（Show Execution Point）\"></a>显示正在执行的行（Show Execution Point）</h2><p>快捷键：（debug模式下） : Alt+F10<br>将光标移动到当前正在调试的行。通常用于下列情况：</p>\n<ul>\n<li>你中断的某些地方</li>\n<li>你开始在这个文件查看然后跳到了其它一些文件</li>\n<li>调用这个快捷键可以返回到你正在一步一步的调试会话的地方</li>\n</ul>\n<p><img src=\"36-executionpoint.gif\" alt=\"36-executionpoint\"></p>\n<hr>\n<h2 id=\"多行选择\"><a href=\"#多行选择\" class=\"headerlink\" title=\"多行选择\"></a>多行选择</h2><ul>\n<li>Mac : <strong> Ctrl+G </strong>  </li>\n<li>Windows/Linux: <strong> Alt+J </strong>  </li>\n</ul>\n<p>这一条格外的精彩！它可以同时选择多行，进行编辑。这就意味着你可以在同一个文档中有多个光标。</p>\n<p><img src=\"32-multiselection.gif\" alt=\"32-multiselection\"></p>\n<h2 id=\"多列选择（Column-Selection）\"><a href=\"#多列选择（Column-Selection）\" class=\"headerlink\" title=\"多列选择（Column Selection）\"></a>多列选择（Column Selection）</h2><ul>\n<li>Mouse(ubuntu上无效): Alt+鼠标拖拽  </li>\n<li>Mac : <strong> Cmd+Shift+8 </strong>  </li>\n<li>Windows/Linux: <strong> Shift+Alt+Insert </strong></li>\n</ul>\n<p><img src=\"33-columnselection.gif\" alt=\" 33-columnselection.gif\"></p>\n<blockquote>\n<p>和多行编辑的区别在于，多列编辑只能是每一行的相同列一起编辑。</p>\n</blockquote>\n<h2 id=\"后缀补全（Postfix-Completion）\"><a href=\"#后缀补全（Postfix-Completion）\" class=\"headerlink\" title=\"后缀补全（Postfix Completion）\"></a>后缀补全（Postfix Completion）</h2><p>这个不是非常直观的，但是相当的给力，基本上，它是无需按一连串左键到头部，实现方法的包裹的最好的方式了。<br>比较常用的有：</p>\n<ul>\n<li>.for (for a foreach)</li>\n<li>.format (wraps a string in String.format())</li>\n<li>.cast (wraps a statement in a type cast)</li>\n</ul>\n<p><img src=\"33-postfixcompletion.gif\" alt=\"33-postfixcompletion\"></p>\n<h2 id=\"与剪切板代码进行比较（Compare-With-Clipboard）\"><a href=\"#与剪切板代码进行比较（Compare-With-Clipboard）\" class=\"headerlink\" title=\"与剪切板代码进行比较（Compare With Clipboard）\"></a>与剪切板代码进行比较（Compare With Clipboard）</h2><ul>\n<li>Mouse: right-click the selection and select Compare With Clipboard  </li>\n<li>Find action: compare with clipboard</li>\n</ul>\n<p>用来比较当前你选择的代码和剪切板中的代码有什么区别。个人觉得用处不大。<br><img src=\"34-comparewithclipboard.gif\" alt=\"34-comparewithclipboard\"></p>\n<h2 id=\"停止进程\"><a href=\"#停止进程\" class=\"headerlink\" title=\"停止进程\"></a>停止进程</h2><ul>\n<li>Mac : Cmd+F2</li>\n<li>Windows/Linux: Ctrl+F2</li>\n</ul>\n<p>将会终止正在运行的最近的task或者显示一个可选的可能需要终止的task列表。用于停止调试或者终止一个build。</p>\n<p><img src=\"35-stoprocess.gif\" alt=\"35-stoprocess\"></p>\n<h2 id=\"VCS-操作弹窗\"><a href=\"#VCS-操作弹窗\" class=\"headerlink\" title=\"VCS 操作弹窗\"></a>VCS 操作弹窗</h2><p>Mac: <strong> Ctrl+V </strong><br>Windows/Linux: <strong> Alt+` </strong><br>显示一些常用的版本控制命令。如git commit。  </p>\n<p><img src=\"37-vcspopup.gif\" alt=\"37-vcspopup\"></p>\n<h2 id=\"与分支进行比较（Compare-With-Branch-Git-）\"><a href=\"#与分支进行比较（Compare-With-Branch-Git-）\" class=\"headerlink\" title=\"与分支进行比较（Compare With Branch (Git)）\"></a>与分支进行比较（Compare With Branch (Git)）</h2><p>Menu (for git): <strong> VCS -&gt; Git -&gt; Compare With Branch </strong><br>Find Actions: <strong> Compare With Branch </strong>  </p>\n<p>如果你的项目是在git下，你可以同另一个分支比较你的文件或者文件夹。特别用来比较你的修改和主分支差异多大。</p>\n<p><img src=\"38-comparewithbranch.gif\" alt=\"38-comparewithbranch\"></p>\n<h2 id=\"回车键和TAB键的区别\"><a href=\"#回车键和TAB键的区别\" class=\"headerlink\" title=\"回车键和TAB键的区别\"></a>回车键和TAB键的区别</h2><p>你可以使用Enter或Tab来自动补全代码。它们之间有一个有趣的差异：使用Enter将会自动完成语句。使用Tab将会自动完成删除光标到下一个点号，括号，分号或空格出现前的内容。</p>\n<p><img src=\"45-codecompletionentertab.gif\" alt=\"45-codecompletionentertab\"></p>\n<h2 id=\"跳转到父类的方法\"><a href=\"#跳转到父类的方法\" class=\"headerlink\" title=\"跳转到父类的方法\"></a>跳转到父类的方法</h2><p>Mac: <strong> Cmd+U </strong><br>Windows/Linux: <strong> Ctrl+U </strong>  </p>\n<p>如果光标在一个复写自父类的方法中（例如Activity#onCreate()方法），使用该快捷键，将会到达该方法的父类的实现。如果光标停留在类名上，则跳转到父类。</p>\n<p><img src=\"39-navigatetoparent.gif\" alt=\"39-navigatetoparent\"></p>\n<h2 id=\"返回到编辑器（Return-to-the-Editor）\"><a href=\"#返回到编辑器（Return-to-the-Editor）\" class=\"headerlink\" title=\"返回到编辑器（Return to the Editor）\"></a>返回到编辑器（Return to the Editor）</h2><p>返回并不关闭面板：Escape<br>返回并关闭面板：Shift+Escape</p>\n<p><img src=\"40-returntoeditor.gif\" alt=\"40-returntoeditor\"></p>\n<h2 id=\"跳到最近使用的工具窗口\"><a href=\"#跳到最近使用的工具窗口\" class=\"headerlink\" title=\"跳到最近使用的工具窗口\"></a>跳到最近使用的工具窗口</h2><p>Mac:F12<br>Windows/Linux:F12  </p>\n<p>有时候，你从面板返回到编辑器，但是你发现不得不再返回到这个面板。例如：浏览find usages。使用这个快捷键，你可以不用鼠标返回到这个面板。</p>\n<p><img src=\"41-lasttoolwindow.gif\" alt=\"41-lasttoolwindow\"></p>\n<h2 id=\"隐藏所有面板（Hide-All-Panels）\"><a href=\"#隐藏所有面板（Hide-All-Panels）\" class=\"headerlink\" title=\"隐藏所有面板（Hide All Panels）\"></a>隐藏所有面板（Hide All Panels）</h2><p>Mac: <strong> Cmd+Shift+F12 </strong><br>windows/linux: <strong> Ctrl+Shift+F12 </strong>  </p>\n<p>让编辑器进入某种形式上的全屏模式。再次调用这个快捷键可以返回所有面板到它们之前的状态。</p>\n<p><img src=\"42-hideallwindows.gif\" alt=\"42-hideallwindows\"></p>\n<h2 id=\"通过编号打开面板\"><a href=\"#通过编号打开面板\" class=\"headerlink\" title=\"通过编号打开面板\"></a>通过编号打开面板</h2><p>Mac: <strong> Cmd+Number </strong><br>windows/linux: <strong> Alt+Number </strong>  </p>\n<p>可以通过面板上标签对应的数字打开相应的面板。</p>\n<p><img src=\"43-openpanelbynumber.gif\" alt=\"43-openpanelbynumber\"></p>\n<h2 id=\"参数信息\"><a href=\"#参数信息\" class=\"headerlink\" title=\"参数信息\"></a>参数信息</h2><p>Mac:<strong>  Cmd+P </strong><br>windows/linux: <strong> Ctrl+P </strong>    </p>\n<p><img src=\"44-parameterinfo.gif\" alt=\"44-parameterinfo\"></p>\n<h2 id=\"切换器\"><a href=\"#切换器\" class=\"headerlink\" title=\"切换器\"></a>切换器</h2><p>Shortcut:<strong> Ctrl+Tab </strong></p>\n<p>这个功能和IDE的alt+tab/cmd+tab差不多。它允许你导航到一个tab或一个panel。一旦它被打开，只要你按住ctrl键，你可以使用数字或字母快捷键快速导航。你也可以通过按下backspace关闭一个打开的文件。</p>\n<p><img src=\"46-switcher.gif\" alt=\"46-switcher\"></p>\n<h2 id=\"上下文信息（Context-Info）\"><a href=\"#上下文信息（Context-Info）\" class=\"headerlink\" title=\"上下文信息（Context Info）\"></a>上下文信息（Context Info）</h2><p>Shortcut:<strong> Ctrl+Shift+Q </strong>    </p>\n<p>这个将会显示你当前位置，当你的定义范围超出滚动的区域时。通常，这将会是类或内部类的名称，但它也可能是当前方法名。在我看来，它最好的使用是快速查看当前类继承或实现。 它也可以在xml文件中使用。</p>\n<p><img src=\"47-contextinfo.gif\" alt=\"47-contextinfo\"></p>\n<h2 id=\"代码重构\"><a href=\"#代码重构\" class=\"headerlink\" title=\"代码重构\"></a>代码重构</h2><p>Mac: <strong> Ctrl+T </strong><br>Windows/Linux: <strong> Ctrl+Alt+Shift+T </strong><br>这是一个针对当前选择的代码显示上下文所有可用的重构的快捷键。这个列表可以通过键盘进行检索并且你也可以使用左侧的数字进行快速访问</p>\n<p><img src=\"48-refactorthis.png\" alt=\"48-refactorthis\"></p>\n<h2 id=\"跳转到最近编辑的文件（Recently-Changed-Files）\"><a href=\"#跳转到最近编辑的文件（Recently-Changed-Files）\" class=\"headerlink\" title=\"跳转到最近编辑的文件（Recently Changed Files）\"></a>跳转到最近编辑的文件（Recently Changed Files）</h2><p>Mac: <strong> Cmd+Shift+E </strong><br>Windows/Linux: <strong> Ctrl+Shift+E </strong>  </p>\n<p>这个和“Recents”弹出框有所不同，这个列出是在本地最近被修改的文件。</p>\n<p><img src=\"49-recentlyedited.gif\" alt=\"49-recentlyedited\"></p>\n<h2 id=\"提取变量\"><a href=\"#提取变量\" class=\"headerlink\" title=\"提取变量\"></a>提取变量</h2><p>Mac:<strong> Cmd+Alt+V </strong><br>Windows/Linux:<strong> Ctrl+Alt+V </strong></p>\n<p>这是一个可以不用通过重构菜单，来提取变量的快捷键。  </p>\n<p><img src=\"51-extractvariable.gif\" alt=\"51-extractvariable\"></p>\n<blockquote>\n<p>额外的技巧：<br>如果你想修改声明类型为一些更通用的（如：List而不是ArrayList）,你可以使用Shift+Tab它会给出一个可用类型的列表。</p>\n</blockquote>\n<h2 id=\"提取参数\"><a href=\"#提取参数\" class=\"headerlink\" title=\"提取参数\"></a>提取参数</h2><p>Mac:Cmd+Alt+P<br>Windows/Linux:Ctrl+Alt+P</p>\n<p>这是一个不用通过重构菜单提取参数的快捷键。<br>这个功能是有用的当你意识到一个方法可能是泛型时通过提取一部分做为一个参数。它作用的方式是它会使用当前值作为一个参数然后复制原先的值作为每个调用者的参数。<br><img src=\"52-extractparam.gif\" alt=\"52-extractparam\"></p>\n<blockquote>\n<p>额外的技巧：<br>你也可以保持原来的方法使用它声明一个新方法通过“delegate”选项。  </p>\n</blockquote>\n<h2 id=\"提取方法\"><a href=\"#提取方法\" class=\"headerlink\" title=\"提取方法\"></a>提取方法</h2><p>Mac: Cmd+Alt+M<br>Windows/Linux: Ctrl+Alt+M</p>\n<p>可以提取一个代码块做为一个新的方法。这个功能是相当有用的。无论什么时候你遇到一个开始变得有点复杂的方法，你可以使用这个安全地抽取一部分到另一个方法。我所说的安全是因为IDE不会像我们可能会犯一个愚蠢的复制粘贴错误。</p>\n<p><img src=\"53-extractmethod.gif\" alt=\"53-extractmethod\"></p>\n<blockquote>\n<p>额外的技巧：<br>当你在抽取对话框，你可以修改方法的可见性和参数名称。</p>\n</blockquote>\n<h2 id=\"inline\"><a href=\"#inline\" class=\"headerlink\" title=\"inline\"></a>inline</h2><p>Mac: Cmd+Alt+N<br>Windows/Linux: Ctrl+Alt+N</p>\n<p>你使用提取有一点疯狂并且现在有太多的东西？你可以使用反向操作，它叫做“inline”。<br>它可以作用于方法，Fields，参数和变量。</p>\n<p><img src=\"54-inline.gif\" alt=\"54-inline\"></p>\n<h2 id=\"重命名\"><a href=\"#重命名\" class=\"headerlink\" title=\"重命名\"></a>重命名</h2><p>快捷键：<strong> Shift+F6 </strong><br><img src=\"55-rename.gif\" alt=\"55-rename.gif\"></p>\n<h2 id=\"Pull-Up-Push-Down\"><a href=\"#Pull-Up-Push-Down\" class=\"headerlink\" title=\"Pull Up / Push Down\"></a>Pull Up / Push Down</h2><p>Mac: Ctrl+T 然后选择成员<br>Windows/Linux: Ctrl+Alt+Shift+T 然后选择成员  </p>\n<p>当我们谈论上拉成员，我们的意思是我们将会让当前类的一些成员（通常是方法或field）发送它到父类或接口。</p>\n<p>如果继承于一个类，内容会被移动。如果是实现的一个接口，它将会声明方法作为接口的一部分，在你的类中保持原有的方法并且添加 @Override注解。<br>当我们谈论下推成员，这正好是反向操作，我们会从父类或接口发送一些成员到子类</p>\n<p><img src=\"56-pullupdown.gif\" alt=\"56-pullupdown.gif\"></p>\n<h1 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h1><table>\n<thead>\n<tr>\n<th>按键</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Ctrl(Command)+C</td>\n<td>复制当前行或选中的内容</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+D</td>\n<td>粘贴当前行或选中的内容</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+X</td>\n<td>剪切当前行或选中的内容</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Y</td>\n<td>删除行</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Z</td>\n<td>倒退</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Shift+Z</td>\n<td>向前</td>\n</tr>\n<tr>\n<td>Alt(Option)+Enter</td>\n<td>自动修正</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Alt(Option)+L</td>\n<td>格式化代码</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Alt(Option)+I</td>\n<td>将选中的代码进行自动缩进编排</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Alt(Option)+O</td>\n<td>优化导入的类和包</td>\n</tr>\n<tr>\n<td>Alt(Option)+Insert</td>\n<td>得到一些Intention Action，可以生成构造器、Getter、Setter、将 == 改为equals() 等</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Shift+V</td>\n<td>选最近使用的剪贴板内容并插入</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Alt(Option)+Shift+V</td>\n<td>简单粘贴</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Shift+Insert</td>\n<td>选最近使用的剪贴板内容并插入（同Ctrl(Command)+Shift+V）</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Enter</td>\n<td>在当前行的上面插入新行，并移动光标到新行（此功能光标在行首时有效）</td>\n</tr>\n<tr>\n<td>Shift+Enter</td>\n<td>在当前行的下面插入新行，并移动光标到新行</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+J</td>\n<td>自动代码</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Alt(Option)+T</td>\n<td>把选中的代码放在 try{} 、if{} 、 else{} 里</td>\n</tr>\n<tr>\n<td>Shift+Alt(Option)+Insert</td>\n<td>竖编辑模式</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+ /</td>\n<td>注释 //</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Shift+ /</td>\n<td>注释 /…/</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Shift+J</td>\n<td>合并成一行</td>\n</tr>\n<tr>\n<td>F2/Shift+F2</td>\n<td>跳转到下/上一个错误语句处</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Shift+Back</td>\n<td>跳转到上次编辑的地方</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Alt(Option)+Space</td>\n<td>类名自动完成</td>\n</tr>\n<tr>\n<td>Shift+Alt(Option)+Up/Down</td>\n<td>内容向上/下移动</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Shift+Up/Down</td>\n<td>语句向上/下移动</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Shift+U</td>\n<td>大小写切换</td>\n</tr>\n<tr>\n<td>Tab</td>\n<td>代码标签输入完成后，按 Tab，生成代码</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Backspace</td>\n<td>按单词删除</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Shift+Enter</td>\n<td>语句完成</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Alt(Option)+J</td>\n<td>用动态模板环绕</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"文件\"><a href=\"#文件\" class=\"headerlink\" title=\"文件\"></a>文件</h2><table>\n<thead>\n<tr>\n<th>按键</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Ctrl(Command)+F12</td>\n<td>显示当前文件的结构</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+H</td>\n<td>显示类继承结构图</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Q</td>\n<td>显示注释文档</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+P</td>\n<td>方法参数提示</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+U</td>\n<td>打开当前类的父类或者实现的接口</td>\n</tr>\n<tr>\n<td>Alt(Option)+Left/Right</td>\n<td>切换代码视图</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Alt(Option)+Left/Right</td>\n<td>返回上次编辑的位置</td>\n</tr>\n<tr>\n<td>Alt(Option)+Up/Down</td>\n<td>在方法间快速移动定位</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+B</td>\n<td>快速打开光标处的类或方法</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+W</td>\n<td>选中代码，连续按会有其他效果</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Shift+W</td>\n<td>取消选择光标所在词</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+ - / +</td>\n<td>折叠/展开代码</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Shift+ - / +</td>\n<td>折叠/展开全部代码</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Shift+.</td>\n<td>折叠/展开当前花括号中的代码</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+ ] / [</td>\n<td>跳转到代码块结束/开始处</td>\n</tr>\n<tr>\n<td>F2 或 Shift+F2</td>\n<td>高亮错误或警告快速定位</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Shift+C</td>\n<td>复制路径</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Alt(Option)+Shift+C</td>\n<td>复制引用，必须选择类名</td>\n</tr>\n<tr>\n<td>Alt(Option)+Up/Down</td>\n<td>在方法间快速移动定位</td>\n</tr>\n<tr>\n<td>Shift+F1</td>\n<td>要打开编辑器光标字符处使用的类或者方法 Java 文档的浏览器</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+G</td>\n<td>定位行</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h2><table>\n<thead>\n<tr>\n<th>按键</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Ctrl(Command)+F</td>\n<td>在当前窗口查找文本</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Shift+F</td>\n<td>在指定环境下查找文本</td>\n</tr>\n<tr>\n<td>F3</td>\n<td>向下查找关键字出现位置</td>\n</tr>\n<tr>\n<td>Shift+F3</td>\n<td>向上一个关键字出现位置</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+R</td>\n<td>在当前窗口替换文本</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Shift+R</td>\n<td>在指定窗口替换文本</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+N</td>\n<td>查找类</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Shift+N</td>\n<td>查找文件</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Shift+Alt(Option)+N</td>\n<td>查找项目中的方法或变量</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+B</td>\n<td>查找变量的来源</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Alt(Option)+B</td>\n<td>快速打开光标处的类或方法</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Shift+B</td>\n<td>跳转到类或方法实现处</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+E</td>\n<td>最近打开的文件</td>\n</tr>\n<tr>\n<td>Alt(Option)+F3</td>\n<td>快速查找，效果和Ctrl(Command)+F相同</td>\n</tr>\n<tr>\n<td>F4</td>\n<td>跳转至定义变量的位置</td>\n</tr>\n<tr>\n<td>Alt(Option)+F7</td>\n<td>查询当前元素在工程中的引用</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+F7</td>\n<td>查询当前元素在当前文件中的引用，然后按 F3 可以选择</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Alt(Option)+F7</td>\n<td>选中查询当前元素在工程中的引用</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Shift+F7</td>\n<td>高亮显示匹配的字符，按 Esc 高亮消失</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Alt(Option)+F7</td>\n<td>查找某个方法的所有调用地方</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Shift+Alt(Option)+N</td>\n<td>查找类中的方法或变量</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Shift+O</td>\n<td>弹出显示查找内容</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Alt(Option)+Up/Down</td>\n<td>快速跳转搜索结果</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Shift+S</td>\n<td>高级搜索、搜索结构</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"重构\"><a href=\"#重构\" class=\"headerlink\" title=\"重构\"></a>重构</h2><table>\n<thead>\n<tr>\n<th>按键</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>F5</td>\n<td>复制</td>\n</tr>\n<tr>\n<td>F6</td>\n<td>移动</td>\n</tr>\n<tr>\n<td>Alt(Option)+Delete</td>\n<td>安全删除</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+U</td>\n<td>转到父类</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+O</td>\n<td>重写父类的方法</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+I</td>\n<td>实现方法</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Alt(Option)+N</td>\n<td>内联</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Alt(Option)+Shift+T</td>\n<td>弹出重构菜单</td>\n</tr>\n<tr>\n<td>Shift+F6</td>\n<td>重构-重命名</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Alt(Option)+M</td>\n<td>提取代码组成方法</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Alt(Option)+C</td>\n<td>将变量更改为常量</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Alt(Option)+V</td>\n<td>定义变量引用当前对象或者方法的返回值</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Alt(Option)+F</td>\n<td>将局部变量更改为类的成员变量</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Alt(Option)+P</td>\n<td>将变量更改为方法的参数</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h2><table>\n<thead>\n<tr>\n<th>按键</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>F8</td>\n<td>跳到下一步</td>\n</tr>\n<tr>\n<td>Shift+F8</td>\n<td>跳出函数、跳到下一个断点</td>\n</tr>\n<tr>\n<td>Alt(Option)+Shift+F8</td>\n<td>强制跳出函数</td>\n</tr>\n<tr>\n<td>F7</td>\n<td>进入代码</td>\n</tr>\n<tr>\n<td>Shift+F7</td>\n<td>智能进入代码</td>\n</tr>\n<tr>\n<td>Alt(Option)+Shift+F7</td>\n<td>强制进入代码</td>\n</tr>\n<tr>\n<td>Alt(Option)+F9</td>\n<td>运行至光标处</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Alt(Option)+F9</td>\n<td>强制运行至光标处</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+F2</td>\n<td>停止运行</td>\n</tr>\n<tr>\n<td>Alt(Option)+F8</td>\n<td>计算变量值</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"VCS\"><a href=\"#VCS\" class=\"headerlink\" title=\"VCS\"></a>VCS</h2><table>\n<thead>\n<tr>\n<th>按键</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Alt(Option)+ ~</td>\n<td>VCS 操作菜单</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+K</td>\n<td>提交更改</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+T</td>\n<td>更新项目</td>\n</tr>\n<tr>\n<td>Ctrl(Command)+Alt(Option)+Shift+D</td>\n<td>显示变化</td>\n</tr>\n</tbody>\n</table>\n<p>谢谢阅读完这篇整理的文章，希望从中能够收获知识。<br>转载请注明出处：<a href=\"www.aman.site\">www.aman.site</a></p>\n<blockquote>\n<p>参考文献：<br><a href=\"https://greenrobot.me/android-dev-tool/android-studio-dev-tips-1/\">Android Cool Posts</a><br><a href=\"http://www.developerphil.com/android-studio-tips-of-the-day-roundup-1/\">Android Studio Tips Of the Day - Roundup #1  </a><br><a href=\"http://www.developerphil.com/android-studio-tips-of-the-day-roundup-2/\">Android Studio Tips Of the Day - Roundup #2  </a><br><a href=\"http://www.developerphil.com/android-studio-tips-of-the-day-roundup-3/\">Android Studio Tips Of the Day - Roundup #3  </a><br><a href=\"http://www.developerphil.com/android-studio-tips-of-the-day-roundup-4/\">Android Studio Tips Of the Day - Roundup #4  </a><br><a href=\"http://www.developerphil.com/android-studio-tips-of-the-day-roundup-5/\">Android Studio Tips Of the Day - Roundup #5  </a><br><a href=\"http://www.developerphil.com/android-studio-tips-of-the-day-roundup-6/\">Android Studio Tips Of the Day - Roundup #6  </a>  </p>\n</blockquote>"},{"layout":"post","title":"AndroidStudio VS eclipse","subtitle":" AndroidStudio VS eclipse","date":"2016-04-19T12:26:47.000Z","author":"JianGuo Yang","type":"categories","header-img":"post-bg-2015.jpg","_content":"\n\n## Android Studio VS eclipse\n如果你使用eclipse很长一段时间，你需要了解这两种IDE之间最基本的差异，下面这张表格将详细描述两者在定义上的差别。包括他们的UI，编译工具，快捷键，以及项目配置等等。  \n相信目前大家用Eclipse的还是大多数，那么首先就来说一下Studio的一些优点，比较才能更有说服力，才能说明为什么我们要从Eclipse迁移到Studio。  \n* 1、Google推出的,为Android APP开发量身定制  \n毫无疑问，这个是它的最大优势，Android Stuido是Google推出，专门为Android“量身订做”的，是Google大力支持的一款基于IntelliJ IDEA改造的IDE。\n* 2、速度更快  \nEclipse的启动速度、响应速度、内存占用一直被诟病，相信大家这点应该深有体会，而且经常遇到卡死状态。Studio不管哪一个方面都全面领先Eclipse。\n* 3、UI更漂亮  \nStuido自带的Darcula主题的炫酷黑界面实在是高大上，相比而言Eclipse下的黑色主题太low了\n* 4、更加智能  \n提示补全对于开发来说意义重大， Studio则更加智能，智能保存，从此再也不用每次都 Ctrl + S了。熟悉Studio以后效率会大大提升。\n* 5、整合了Gradle构建工具  \nGradle是一个新的构建工具，自Studio亮相之处就支持Gradle，可以说Gradle集合了Ant和Maven的优点，不管是配置、编译、打包都非常棒。\n* 6、强大的UI编辑器  \nAndroid Studio的编辑器非常的智能，除了吸收Eclipse+ADT的优点之外，还自带了多设备的实时预览，相对这对Android开发者来说简直是神器啊。\n* 7、内置终端  \nStudio内置终端，这对于习惯命令行操作的人来说简直是福音啊，再也不用来回切换了，一个Studio全部搞定。\n* 8、更完善的插件系统  \nStudio下支持各种插件，如Git、Markdown、Gradle等等，你想要什么插件，直接搜索下载。\n* 9、完美整合版本控制系统  \n安装的时候就自带了如GitHub, Git, SVN等流行的版本控制系统，可以直接check out你的项目。\n\n> 不足之处：  \n暂未支持NDK，所以如果你的项目用到了NDK最好也不要使用Studio\n\n\n### UI\n#### 没有WorkSpace的概念\nAndroidStudio和eclipse最大的差别在于，androidstudio并没有WorkSpace的概念，这就意味着，你仅\n可以在同一时间编辑一个项目。AndroidStudio中，一个项目由多个module组成。\n如果你有多个不相关的项目，你也可以在不同的窗口中打开。如果执意想在同一个窗口中打开不相关的项目，也可以\n将这些项目以Module的形式导入。\n\n以下这张图列出了eclipse 和 androidstudio之间的概念性差别。\n\n| eclipse   | AndroidStudio |\n| -------   |---------------|\n| Workspace | Project |\n| Project   | Module  |\n| Facet     | Facet   |  \n| Library   | Library |\n| JRE       |     SDK |\n| Classpath variable | Classpath variable|\n\n#### 没有视角的概念\n第二个比较大的区别在于Andorid Studio没有透视（perspectives），这意味着你不需要像eclipse那样手动的切换不同工作空间的布局。AndroidStudio可以自动的根据你的上下文切换相关的工具。例如，你在调试的时候，会自动切换到Debugger的工具窗口。\n\n![自动显示工作空间](migration_guide_debugger_1.png)\n\n#### 工具窗口\nandroidstudio同样具有工具窗口。打开一个工具窗口，只需要点击相应的工具窗口条即可选择想要打开的窗口。\n如果窗口被隐藏，可以通过点击屏幕坐下角对应的图标。也可以通过ALT键+对应的数字打开。例如：  \n* 打开 Project：Alt+1；\n* 打开 Terminal ： Alt+F12\n\n#### 设置project对应的文件自动滚动\n默认情况下，Andorid Studio 并不支持在切换不同文件的时候，左侧的project文件跟着变动。可以右键点击“project”，在弹出的对话框中勾选\"AutoScrollToSource\" 和 \"AutoScrollFromSource\"，使得在点击左侧的文件名时，右侧窗口自动打开并跳转到对应的文件。点击右侧的文件窗口时，左侧也可以自动跳转。  \n\n![自动跟随](migration_guide_auto_scroll_from_source.png)\n\n#### 显示行号\nsettings/Preferences | Editor | General | Appearance | Show line numbers\n","source":"_posts/AndroidStudio_VS_eclipse.md","raw":"---\nlayout:     post\ntitle: AndroidStudio VS eclipse\nsubtitle:   \" AndroidStudio VS eclipse\"\ndate: 2016-04-19 20:26:47\nauthor:     \"JianGuo Yang\"\ntype: \"categories\"\nheader-img: \"post-bg-2015.jpg\"\ntags: AndroidStudio\n---\n\n\n## Android Studio VS eclipse\n如果你使用eclipse很长一段时间，你需要了解这两种IDE之间最基本的差异，下面这张表格将详细描述两者在定义上的差别。包括他们的UI，编译工具，快捷键，以及项目配置等等。  \n相信目前大家用Eclipse的还是大多数，那么首先就来说一下Studio的一些优点，比较才能更有说服力，才能说明为什么我们要从Eclipse迁移到Studio。  \n* 1、Google推出的,为Android APP开发量身定制  \n毫无疑问，这个是它的最大优势，Android Stuido是Google推出，专门为Android“量身订做”的，是Google大力支持的一款基于IntelliJ IDEA改造的IDE。\n* 2、速度更快  \nEclipse的启动速度、响应速度、内存占用一直被诟病，相信大家这点应该深有体会，而且经常遇到卡死状态。Studio不管哪一个方面都全面领先Eclipse。\n* 3、UI更漂亮  \nStuido自带的Darcula主题的炫酷黑界面实在是高大上，相比而言Eclipse下的黑色主题太low了\n* 4、更加智能  \n提示补全对于开发来说意义重大， Studio则更加智能，智能保存，从此再也不用每次都 Ctrl + S了。熟悉Studio以后效率会大大提升。\n* 5、整合了Gradle构建工具  \nGradle是一个新的构建工具，自Studio亮相之处就支持Gradle，可以说Gradle集合了Ant和Maven的优点，不管是配置、编译、打包都非常棒。\n* 6、强大的UI编辑器  \nAndroid Studio的编辑器非常的智能，除了吸收Eclipse+ADT的优点之外，还自带了多设备的实时预览，相对这对Android开发者来说简直是神器啊。\n* 7、内置终端  \nStudio内置终端，这对于习惯命令行操作的人来说简直是福音啊，再也不用来回切换了，一个Studio全部搞定。\n* 8、更完善的插件系统  \nStudio下支持各种插件，如Git、Markdown、Gradle等等，你想要什么插件，直接搜索下载。\n* 9、完美整合版本控制系统  \n安装的时候就自带了如GitHub, Git, SVN等流行的版本控制系统，可以直接check out你的项目。\n\n> 不足之处：  \n暂未支持NDK，所以如果你的项目用到了NDK最好也不要使用Studio\n\n\n### UI\n#### 没有WorkSpace的概念\nAndroidStudio和eclipse最大的差别在于，androidstudio并没有WorkSpace的概念，这就意味着，你仅\n可以在同一时间编辑一个项目。AndroidStudio中，一个项目由多个module组成。\n如果你有多个不相关的项目，你也可以在不同的窗口中打开。如果执意想在同一个窗口中打开不相关的项目，也可以\n将这些项目以Module的形式导入。\n\n以下这张图列出了eclipse 和 androidstudio之间的概念性差别。\n\n| eclipse   | AndroidStudio |\n| -------   |---------------|\n| Workspace | Project |\n| Project   | Module  |\n| Facet     | Facet   |  \n| Library   | Library |\n| JRE       |     SDK |\n| Classpath variable | Classpath variable|\n\n#### 没有视角的概念\n第二个比较大的区别在于Andorid Studio没有透视（perspectives），这意味着你不需要像eclipse那样手动的切换不同工作空间的布局。AndroidStudio可以自动的根据你的上下文切换相关的工具。例如，你在调试的时候，会自动切换到Debugger的工具窗口。\n\n![自动显示工作空间](migration_guide_debugger_1.png)\n\n#### 工具窗口\nandroidstudio同样具有工具窗口。打开一个工具窗口，只需要点击相应的工具窗口条即可选择想要打开的窗口。\n如果窗口被隐藏，可以通过点击屏幕坐下角对应的图标。也可以通过ALT键+对应的数字打开。例如：  \n* 打开 Project：Alt+1；\n* 打开 Terminal ： Alt+F12\n\n#### 设置project对应的文件自动滚动\n默认情况下，Andorid Studio 并不支持在切换不同文件的时候，左侧的project文件跟着变动。可以右键点击“project”，在弹出的对话框中勾选\"AutoScrollToSource\" 和 \"AutoScrollFromSource\"，使得在点击左侧的文件名时，右侧窗口自动打开并跳转到对应的文件。点击右侧的文件窗口时，左侧也可以自动跳转。  \n\n![自动跟随](migration_guide_auto_scroll_from_source.png)\n\n#### 显示行号\nsettings/Preferences | Editor | General | Appearance | Show line numbers\n","slug":"AndroidStudio_VS_eclipse","published":1,"updated":"2016-07-28T12:15:26.696Z","comments":1,"photos":[],"link":"","_id":"cirdlcvbv0002252nbjxcii1a","content":"<h2 id=\"Android-Studio-VS-eclipse\"><a href=\"#Android-Studio-VS-eclipse\" class=\"headerlink\" title=\"Android Studio VS eclipse\"></a>Android Studio VS eclipse</h2><p>如果你使用eclipse很长一段时间，你需要了解这两种IDE之间最基本的差异，下面这张表格将详细描述两者在定义上的差别。包括他们的UI，编译工具，快捷键，以及项目配置等等。<br>相信目前大家用Eclipse的还是大多数，那么首先就来说一下Studio的一些优点，比较才能更有说服力，才能说明为什么我们要从Eclipse迁移到Studio。  </p>\n<ul>\n<li>1、Google推出的,为Android APP开发量身定制<br>毫无疑问，这个是它的最大优势，Android Stuido是Google推出，专门为Android“量身订做”的，是Google大力支持的一款基于IntelliJ IDEA改造的IDE。</li>\n<li>2、速度更快<br>Eclipse的启动速度、响应速度、内存占用一直被诟病，相信大家这点应该深有体会，而且经常遇到卡死状态。Studio不管哪一个方面都全面领先Eclipse。</li>\n<li>3、UI更漂亮<br>Stuido自带的Darcula主题的炫酷黑界面实在是高大上，相比而言Eclipse下的黑色主题太low了</li>\n<li>4、更加智能<br>提示补全对于开发来说意义重大， Studio则更加智能，智能保存，从此再也不用每次都 Ctrl + S了。熟悉Studio以后效率会大大提升。</li>\n<li>5、整合了Gradle构建工具<br>Gradle是一个新的构建工具，自Studio亮相之处就支持Gradle，可以说Gradle集合了Ant和Maven的优点，不管是配置、编译、打包都非常棒。</li>\n<li>6、强大的UI编辑器<br>Android Studio的编辑器非常的智能，除了吸收Eclipse+ADT的优点之外，还自带了多设备的实时预览，相对这对Android开发者来说简直是神器啊。</li>\n<li>7、内置终端<br>Studio内置终端，这对于习惯命令行操作的人来说简直是福音啊，再也不用来回切换了，一个Studio全部搞定。</li>\n<li>8、更完善的插件系统<br>Studio下支持各种插件，如Git、Markdown、Gradle等等，你想要什么插件，直接搜索下载。</li>\n<li>9、完美整合版本控制系统<br>安装的时候就自带了如GitHub, Git, SVN等流行的版本控制系统，可以直接check out你的项目。</li>\n</ul>\n<blockquote>\n<p>不足之处：<br>暂未支持NDK，所以如果你的项目用到了NDK最好也不要使用Studio</p>\n</blockquote>\n<h3 id=\"UI\"><a href=\"#UI\" class=\"headerlink\" title=\"UI\"></a>UI</h3><h4 id=\"没有WorkSpace的概念\"><a href=\"#没有WorkSpace的概念\" class=\"headerlink\" title=\"没有WorkSpace的概念\"></a>没有WorkSpace的概念</h4><p>AndroidStudio和eclipse最大的差别在于，androidstudio并没有WorkSpace的概念，这就意味着，你仅<br>可以在同一时间编辑一个项目。AndroidStudio中，一个项目由多个module组成。<br>如果你有多个不相关的项目，你也可以在不同的窗口中打开。如果执意想在同一个窗口中打开不相关的项目，也可以<br>将这些项目以Module的形式导入。</p>\n<p>以下这张图列出了eclipse 和 androidstudio之间的概念性差别。</p>\n<table>\n<thead>\n<tr>\n<th>eclipse</th>\n<th>AndroidStudio</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Workspace</td>\n<td>Project</td>\n</tr>\n<tr>\n<td>Project</td>\n<td>Module</td>\n</tr>\n<tr>\n<td>Facet</td>\n<td>Facet</td>\n</tr>\n<tr>\n<td>Library</td>\n<td>Library</td>\n</tr>\n<tr>\n<td>JRE</td>\n<td>SDK</td>\n</tr>\n<tr>\n<td>Classpath variable</td>\n<td>Classpath variable</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"没有视角的概念\"><a href=\"#没有视角的概念\" class=\"headerlink\" title=\"没有视角的概念\"></a>没有视角的概念</h4><p>第二个比较大的区别在于Andorid Studio没有透视（perspectives），这意味着你不需要像eclipse那样手动的切换不同工作空间的布局。AndroidStudio可以自动的根据你的上下文切换相关的工具。例如，你在调试的时候，会自动切换到Debugger的工具窗口。</p>\n<p><img src=\"migration_guide_debugger_1.png\" alt=\"自动显示工作空间\"></p>\n<h4 id=\"工具窗口\"><a href=\"#工具窗口\" class=\"headerlink\" title=\"工具窗口\"></a>工具窗口</h4><p>androidstudio同样具有工具窗口。打开一个工具窗口，只需要点击相应的工具窗口条即可选择想要打开的窗口。<br>如果窗口被隐藏，可以通过点击屏幕坐下角对应的图标。也可以通过ALT键+对应的数字打开。例如：  </p>\n<ul>\n<li>打开 Project：Alt+1；</li>\n<li>打开 Terminal ： Alt+F12</li>\n</ul>\n<h4 id=\"设置project对应的文件自动滚动\"><a href=\"#设置project对应的文件自动滚动\" class=\"headerlink\" title=\"设置project对应的文件自动滚动\"></a>设置project对应的文件自动滚动</h4><p>默认情况下，Andorid Studio 并不支持在切换不同文件的时候，左侧的project文件跟着变动。可以右键点击“project”，在弹出的对话框中勾选”AutoScrollToSource” 和 “AutoScrollFromSource”，使得在点击左侧的文件名时，右侧窗口自动打开并跳转到对应的文件。点击右侧的文件窗口时，左侧也可以自动跳转。  </p>\n<p><img src=\"migration_guide_auto_scroll_from_source.png\" alt=\"自动跟随\"></p>\n<h4 id=\"显示行号\"><a href=\"#显示行号\" class=\"headerlink\" title=\"显示行号\"></a>显示行号</h4><p>settings/Preferences | Editor | General | Appearance | Show line numbers</p>\n","excerpt":"","more":"<h2 id=\"Android-Studio-VS-eclipse\"><a href=\"#Android-Studio-VS-eclipse\" class=\"headerlink\" title=\"Android Studio VS eclipse\"></a>Android Studio VS eclipse</h2><p>如果你使用eclipse很长一段时间，你需要了解这两种IDE之间最基本的差异，下面这张表格将详细描述两者在定义上的差别。包括他们的UI，编译工具，快捷键，以及项目配置等等。<br>相信目前大家用Eclipse的还是大多数，那么首先就来说一下Studio的一些优点，比较才能更有说服力，才能说明为什么我们要从Eclipse迁移到Studio。  </p>\n<ul>\n<li>1、Google推出的,为Android APP开发量身定制<br>毫无疑问，这个是它的最大优势，Android Stuido是Google推出，专门为Android“量身订做”的，是Google大力支持的一款基于IntelliJ IDEA改造的IDE。</li>\n<li>2、速度更快<br>Eclipse的启动速度、响应速度、内存占用一直被诟病，相信大家这点应该深有体会，而且经常遇到卡死状态。Studio不管哪一个方面都全面领先Eclipse。</li>\n<li>3、UI更漂亮<br>Stuido自带的Darcula主题的炫酷黑界面实在是高大上，相比而言Eclipse下的黑色主题太low了</li>\n<li>4、更加智能<br>提示补全对于开发来说意义重大， Studio则更加智能，智能保存，从此再也不用每次都 Ctrl + S了。熟悉Studio以后效率会大大提升。</li>\n<li>5、整合了Gradle构建工具<br>Gradle是一个新的构建工具，自Studio亮相之处就支持Gradle，可以说Gradle集合了Ant和Maven的优点，不管是配置、编译、打包都非常棒。</li>\n<li>6、强大的UI编辑器<br>Android Studio的编辑器非常的智能，除了吸收Eclipse+ADT的优点之外，还自带了多设备的实时预览，相对这对Android开发者来说简直是神器啊。</li>\n<li>7、内置终端<br>Studio内置终端，这对于习惯命令行操作的人来说简直是福音啊，再也不用来回切换了，一个Studio全部搞定。</li>\n<li>8、更完善的插件系统<br>Studio下支持各种插件，如Git、Markdown、Gradle等等，你想要什么插件，直接搜索下载。</li>\n<li>9、完美整合版本控制系统<br>安装的时候就自带了如GitHub, Git, SVN等流行的版本控制系统，可以直接check out你的项目。</li>\n</ul>\n<blockquote>\n<p>不足之处：<br>暂未支持NDK，所以如果你的项目用到了NDK最好也不要使用Studio</p>\n</blockquote>\n<h3 id=\"UI\"><a href=\"#UI\" class=\"headerlink\" title=\"UI\"></a>UI</h3><h4 id=\"没有WorkSpace的概念\"><a href=\"#没有WorkSpace的概念\" class=\"headerlink\" title=\"没有WorkSpace的概念\"></a>没有WorkSpace的概念</h4><p>AndroidStudio和eclipse最大的差别在于，androidstudio并没有WorkSpace的概念，这就意味着，你仅<br>可以在同一时间编辑一个项目。AndroidStudio中，一个项目由多个module组成。<br>如果你有多个不相关的项目，你也可以在不同的窗口中打开。如果执意想在同一个窗口中打开不相关的项目，也可以<br>将这些项目以Module的形式导入。</p>\n<p>以下这张图列出了eclipse 和 androidstudio之间的概念性差别。</p>\n<table>\n<thead>\n<tr>\n<th>eclipse</th>\n<th>AndroidStudio</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Workspace</td>\n<td>Project</td>\n</tr>\n<tr>\n<td>Project</td>\n<td>Module</td>\n</tr>\n<tr>\n<td>Facet</td>\n<td>Facet</td>\n</tr>\n<tr>\n<td>Library</td>\n<td>Library</td>\n</tr>\n<tr>\n<td>JRE</td>\n<td>SDK</td>\n</tr>\n<tr>\n<td>Classpath variable</td>\n<td>Classpath variable</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"没有视角的概念\"><a href=\"#没有视角的概念\" class=\"headerlink\" title=\"没有视角的概念\"></a>没有视角的概念</h4><p>第二个比较大的区别在于Andorid Studio没有透视（perspectives），这意味着你不需要像eclipse那样手动的切换不同工作空间的布局。AndroidStudio可以自动的根据你的上下文切换相关的工具。例如，你在调试的时候，会自动切换到Debugger的工具窗口。</p>\n<p><img src=\"migration_guide_debugger_1.png\" alt=\"自动显示工作空间\"></p>\n<h4 id=\"工具窗口\"><a href=\"#工具窗口\" class=\"headerlink\" title=\"工具窗口\"></a>工具窗口</h4><p>androidstudio同样具有工具窗口。打开一个工具窗口，只需要点击相应的工具窗口条即可选择想要打开的窗口。<br>如果窗口被隐藏，可以通过点击屏幕坐下角对应的图标。也可以通过ALT键+对应的数字打开。例如：  </p>\n<ul>\n<li>打开 Project：Alt+1；</li>\n<li>打开 Terminal ： Alt+F12</li>\n</ul>\n<h4 id=\"设置project对应的文件自动滚动\"><a href=\"#设置project对应的文件自动滚动\" class=\"headerlink\" title=\"设置project对应的文件自动滚动\"></a>设置project对应的文件自动滚动</h4><p>默认情况下，Andorid Studio 并不支持在切换不同文件的时候，左侧的project文件跟着变动。可以右键点击“project”，在弹出的对话框中勾选”AutoScrollToSource” 和 “AutoScrollFromSource”，使得在点击左侧的文件名时，右侧窗口自动打开并跳转到对应的文件。点击右侧的文件窗口时，左侧也可以自动跳转。  </p>\n<p><img src=\"migration_guide_auto_scroll_from_source.png\" alt=\"自动跟随\"></p>\n<h4 id=\"显示行号\"><a href=\"#显示行号\" class=\"headerlink\" title=\"显示行号\"></a>显示行号</h4><p>settings/Preferences | Editor | General | Appearance | Show line numbers</p>\n"},{"layout":"post","title":"Logger开源库刨析","subtitle":"Logger是github上关于Andorid Log打印优化和封装的软件，是一款简洁、优雅、强大的log跟踪器，截止目前已经有4003个star。","author":"JianGuo","header-img":null,"date":"2016-07-21T12:58:29.000Z","_content":"\n> 最近突发奇想，想自己重新封装android的log机制，以便于在以后的开发中简单的使用log进行调试。我们知道，在大多数的情况下我们需要对log的状态进行配置，在user版本中为了安全，某些关键log不能打印出来，同时，可能在调试的时候，我们只需要打印某个级别的log。通常情况下，我们是在每个类中进行log打印的控制（使用DEBUG的全局变量），每次打印log时都需要进行判断，这样的代码显然有点繁琐。所以，就需要通过封装Log完成上面的需求。为了避免重复造轮子，我在Github上检索了一下，果然发现了宝藏。一个名为Logger的开源项目，完美的诠释了什么是轮子。所以直接搬来用了。接下来的内容介绍这个项目如何使用。\n\n<img align=\"right\" src='https://raw.githubusercontent.com/orhanobut/logger/master/images/logger-logo.png' width='128' height='128'/>\n\n# Loger简介\nLogger是github上关于Andorid Log打印优化和封装的开源项目，是一款简洁、优雅、强大的log跟踪器（官方如是说），截止目前已经有4003个star，700多个fork。项目地址为：[https://github.com/orhanobut/logger](https://github.com/orhanobut/logger)。  \n\n它主要提供了以下功能：\n  * 输出线程信息\n  * 输出类信息\n  * 输出方法信息\n  * 格式化输出json数据\n  * 对于log中的“\\n” 换行输出\n  * 清理输出\n  * 直接跳转到代码行\n\n下面来看看打印出的log效果吧：  \n![Log](https://raw.githubusercontent.com/orhanobut/logger/master/images/description.png)\n\n> 同时，从所有的fork列表中，发现了另一个比较好的版本演变，如果感兴趣的话可以异步：[tianzhijiexian/logger](https://github.com/tianzhijiexian/logger)。\n\n# 如何使用\n## 如何添加依赖\n了解到这么强大的功能后，肯定想知道如何使用了。如果你的项目在使用gradle构建的话，最简单，最直接的方式就是添加依赖了。\n```groovy\ncompile 'com.orhanobut:logger:1.15'\n```\n当然，如果不能直接引用的话，就乖乖下载源码，放入到系统，或者编译出jar包，做依赖吧。\n\n## 在代码中使用\nLogger的使用上和Log的区别并不是很大。如下的代码展示了Logger的使用：\n```java\nLogger.d(\"hello\");\nLogger.d(\"hello %s %d\", \"world\", 5);   // String.format\nLogger.e(\"hello\");\nLogger.e(exception,\"message\");\nLogger.w(\"hello\");\nLogger.v(\"hello\");\nLogger.wtf(\"hello\");\nLogger.json(JSON_CONTENT);\nLogger.xml(XML_CONTENT);\nLogger.log(DEBUG, \"tag\", \"message\", throwable);\n```\n同时，Logger还能直接打印Array, Map, Set and List等对象，不需要进行遍历输出。\n```java\nLogger.d(list);\nLogger.d(map);\nLogger.d(set);\nLogger.d(new String[]);\n```\n## 配置Logger\n如果你相对Logger进行更深的定制的话，也可以在Logger的init方法中进行详细的配置：\n```java\nLogger\n  .init(YOUR_TAG)                 // 默认为 PRETTYLOGGER 或者仅使用 init()\n  .methodCount(3)                 // 默认为 2\n  .hideThreadInfo()               // 默认为显示线程信息\n  .logLevel(LogLevel.NONE)        // 默认打印所有级别的log，即参数为：LogLevel.FULL\n  .methodOffset(2)                // 默认为 0\n  .logAdapter(new AndroidLogAdapter()); //默认为 AndroidLogAdapter\n}\n```\n需要注意的是，这个方法只能被调用一次，最好能够在Application类中进行全局设置。所有的设置都是可选的，不设置也无不影响使用。**建议在发布的版本中将logLevel设置为:LogLevel.NONE**\n\n### 添加TAG\n```java\n// 添加全局的TAG\nLogger.init(YOUR_TAG);\n// 添加当前Logger的TAG\nLogger.t(\"mytag\").d(\"hello\");\n```\n效果如下：\n![Logger打印效果](https://github.com/orhanobut/logger/raw/master/images/custom-tag.png)\n其实，在我看来，添加类的tag已经没有什么大的必要了，因为Logger在打印log的时候，会输出类名和方法名，直接检索就可以了。\n\n### 设置打印方法数\n```java\n// 修改全局打印的方法数\nLogger.init().methodCount(1);\n// 修改当前Logger想打印的方法数\nLogger.t(1).d(\"hello\");\n```\n### 设置方法方法堆栈偏移量\n为了避免其他库对logger的使用影响到程序的使用，可以设置类避免其他库的方法：\n```java\nLogger.init().methodOffset(5);\n```\n### 隐藏线程信息\n```java\nLogger.init().methodCount(1).hideThreadInfo();\n```\n### 仅打印消息\n```java\nLogger.init().methodCount(0).hideThreadInfo();\n```\n![只打印信息时的效果](https://github.com/orhanobut/logger/raw/master/images/just-content.png)\n\n### 使用其他Log工具代替android.util.log\n  1. 实现 LogAdapter\n  2. 在init中配置它\n\n具体配置代码可参考下面的例子：\n```java\n.logAdapter(new CustomLogAdapter());\n```\n\n### Timber Integration\n不明觉厉，所以只能把github上的介绍粘贴过来了。\n```java\nTimber.plant(new Timber.DebugTree() {\n  @Override protected void log(int priority, String tag, String message, Throwable t) {\n    Logger.log(priority, tag, message, t);\n  }\n});\n```\n\n# 代码实现原理解析\n整个代码也只有八个类，非常简洁。代码虽少，但是很规范，融入着基本的设计模式和思想，很值得学习。\n  * AndroidLogAdapter.java 其实就是对android.util.Log方法的封装。适配器类的简单应用实例。如果想对这个类进行重新封装，则可以实现自己的adapter，然后通过 ***Logger.logAdapter(new CustomLogAdapter());*** 方法进行设置。\n  * Helper.java helper类提供了一些静态方法用来处理字符串的相关操作，例如判空，判断两个字符串是否相同，取得堆栈字符串，避免空指针。\n  * LogAdapter.java 适配器的接口\n  * LogLevel.java 定义了log的级别，当前只有两种状态： FULL,NONE\n  * Logger.java 主类，\n  * LoggerPrinter.java 负责log的输出格式化，输出json，xml，set等数据。继承字Printer.java\n  * Printer.java Printer接口\n  * Settings.java logger配置的数据结构\n\n下面就针对Logger类和LoggerPrinter的实现进行进一步的分析。\n在Logger.java中，也基本上是完成了Settings和LoggerPrinter的实例化，并且封装了Printer的接口，给外部调用。主要可操作的接口有以下这些：\n * public static Settings init()\n * public static Settings init(String tag)\n * public static void resetSettings()\n * public static Printer t(String tag)\n * public static Printer t(int methodCount)\n * public static Printer t(String tag, int methodCount)\n * public static void log(int priority, String tag, String message, Throwable throwable)\n * public static void d(Object object) //其实可以看出的d方法中，可以直接将对象传入，如果是Array，则可以解析出数据进行打印，其他的则打印object.toString()信息，但是其他级别的log中并不能实现这一点。\n * public static void d(String message, Object... args)\n * public static void e(String message, Object... args)\n * public static void e(Throwable throwable, String message, Object... args)\n * public static void i(String message, Object... args)\n * public static void v(String message, Object... args)\n * public static void w(String message, Object... args)\n * public static void wtf(String message, Object... args)\n * public static void json(String json) //打印json数据\n * public static void xml(String xml) //打印xml信息\n\n在LoggerPrinter.java中，主要的逻辑集中在以下几个方法中：\njson（）方法：\n```java\n/**\n   * Formats the json content and print it\n   *\n   * @param json the json content\n   */\n  @Override public void json(String json) {\n    if (Helper.isEmpty(json)) {\n      d(\"Empty/Null json content\");\n      return;\n    }\n    try {\n      json = json.trim();\n      if (json.startsWith(\"{\")) {\n        JSONObject jsonObject = new JSONObject(json);\n        String message = jsonObject.toString(JSON_INDENT);\n        d(message);\n        return;\n      }\n      if (json.startsWith(\"[\")) {\n        JSONArray jsonArray = new JSONArray(json);\n        String message = jsonArray.toString(JSON_INDENT);\n        d(message);\n        return;\n      }\n      e(\"Invalid Json\");\n    } catch (JSONException e) {\n      e(\"Invalid Json\");\n    }\n  }\n\n```\nxml方法，用来将xml字符串进行简化。\n```java\n/**\n * Formats the json content and print it\n *\n * @param xml the xml content\n */\n@Override public void xml(String xml) {\n  if (Helper.isEmpty(xml)) {\n    d(\"Empty/Null xml content\");\n    return;\n  }\n  try {\n    Source xmlInput = new StreamSource(new StringReader(xml));\n    StreamResult xmlOutput = new StreamResult(new StringWriter());\n    Transformer transformer = TransformerFactory.newInstance().newTransformer();\n    transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n    transformer.setOutputProperty(\"{http://xml.apache.org/xslt}indent-amount\", \"2\");\n    transformer.transform(xmlInput, xmlOutput);\n    d(xmlOutput.getWriter().toString().replaceFirst(\">\", \">\\n\"));\n  } catch (TransformerException e) {\n    e(\"Invalid xml\");\n  }\n}\n```\nlog（）方法：\n```java\n@Override public synchronized void log(int priority, String tag, String message, Throwable throwable) {\n    if (settings.getLogLevel() == LogLevel.NONE) {\n      return;\n    }\n    if (throwable != null && message != null) {\n      message += \" : \" + Helper.getStackTraceString(throwable);\n    }\n    if (throwable != null && message == null) {\n      message = Helper.getStackTraceString(throwable);\n    }\n    if (message == null) {\n      message = \"No message/exception is set\";\n    }\n    int methodCount = getMethodCount();\n    if (Helper.isEmpty(message)) {\n      message = \"Empty/NULL log message\";\n    }\n\n    logTopBorder(priority, tag);\n    logHeaderContent(priority, tag, methodCount);\n\n    //get bytes of message with system's default charset (which is UTF-8 for Android)\n    byte[] bytes = message.getBytes();\n    int length = bytes.length;\n    if (length <= CHUNK_SIZE) {\n      if (methodCount > 0) {\n        logDivider(priority, tag);\n      }\n      logContent(priority, tag, message);\n      logBottomBorder(priority, tag);\n      return;\n    }\n    if (methodCount > 0) {\n      logDivider(priority, tag);\n    }\n    for (int i = 0; i < length; i += CHUNK_SIZE) {\n      int count = Math.min(length - i, CHUNK_SIZE);\n      //create a new String with system's default charset (which is UTF-8 for Android)\n      logContent(priority, tag, new String(bytes, i, count));\n    }\n    logBottomBorder(priority, tag);\n  }\n```\n\n# 功能优化\n这个以后有空再谈，毕竟还没有使用的需求。更谈不上优化了。\n","source":"_posts/Logger_analyse.md","raw":"---\nlayout: post\ntitle: Logger开源库刨析\nsubtitle: Logger是github上关于Andorid Log打印优化和封装的软件，是一款简洁、优雅、强大的log跟踪器，截止目前已经有4003个star。\nauthor: JianGuo\nheader-img:\ntags: 开源项目\ndate: 2016-07-21 20:58:29\n---\n\n> 最近突发奇想，想自己重新封装android的log机制，以便于在以后的开发中简单的使用log进行调试。我们知道，在大多数的情况下我们需要对log的状态进行配置，在user版本中为了安全，某些关键log不能打印出来，同时，可能在调试的时候，我们只需要打印某个级别的log。通常情况下，我们是在每个类中进行log打印的控制（使用DEBUG的全局变量），每次打印log时都需要进行判断，这样的代码显然有点繁琐。所以，就需要通过封装Log完成上面的需求。为了避免重复造轮子，我在Github上检索了一下，果然发现了宝藏。一个名为Logger的开源项目，完美的诠释了什么是轮子。所以直接搬来用了。接下来的内容介绍这个项目如何使用。\n\n<img align=\"right\" src='https://raw.githubusercontent.com/orhanobut/logger/master/images/logger-logo.png' width='128' height='128'/>\n\n# Loger简介\nLogger是github上关于Andorid Log打印优化和封装的开源项目，是一款简洁、优雅、强大的log跟踪器（官方如是说），截止目前已经有4003个star，700多个fork。项目地址为：[https://github.com/orhanobut/logger](https://github.com/orhanobut/logger)。  \n\n它主要提供了以下功能：\n  * 输出线程信息\n  * 输出类信息\n  * 输出方法信息\n  * 格式化输出json数据\n  * 对于log中的“\\n” 换行输出\n  * 清理输出\n  * 直接跳转到代码行\n\n下面来看看打印出的log效果吧：  \n![Log](https://raw.githubusercontent.com/orhanobut/logger/master/images/description.png)\n\n> 同时，从所有的fork列表中，发现了另一个比较好的版本演变，如果感兴趣的话可以异步：[tianzhijiexian/logger](https://github.com/tianzhijiexian/logger)。\n\n# 如何使用\n## 如何添加依赖\n了解到这么强大的功能后，肯定想知道如何使用了。如果你的项目在使用gradle构建的话，最简单，最直接的方式就是添加依赖了。\n```groovy\ncompile 'com.orhanobut:logger:1.15'\n```\n当然，如果不能直接引用的话，就乖乖下载源码，放入到系统，或者编译出jar包，做依赖吧。\n\n## 在代码中使用\nLogger的使用上和Log的区别并不是很大。如下的代码展示了Logger的使用：\n```java\nLogger.d(\"hello\");\nLogger.d(\"hello %s %d\", \"world\", 5);   // String.format\nLogger.e(\"hello\");\nLogger.e(exception,\"message\");\nLogger.w(\"hello\");\nLogger.v(\"hello\");\nLogger.wtf(\"hello\");\nLogger.json(JSON_CONTENT);\nLogger.xml(XML_CONTENT);\nLogger.log(DEBUG, \"tag\", \"message\", throwable);\n```\n同时，Logger还能直接打印Array, Map, Set and List等对象，不需要进行遍历输出。\n```java\nLogger.d(list);\nLogger.d(map);\nLogger.d(set);\nLogger.d(new String[]);\n```\n## 配置Logger\n如果你相对Logger进行更深的定制的话，也可以在Logger的init方法中进行详细的配置：\n```java\nLogger\n  .init(YOUR_TAG)                 // 默认为 PRETTYLOGGER 或者仅使用 init()\n  .methodCount(3)                 // 默认为 2\n  .hideThreadInfo()               // 默认为显示线程信息\n  .logLevel(LogLevel.NONE)        // 默认打印所有级别的log，即参数为：LogLevel.FULL\n  .methodOffset(2)                // 默认为 0\n  .logAdapter(new AndroidLogAdapter()); //默认为 AndroidLogAdapter\n}\n```\n需要注意的是，这个方法只能被调用一次，最好能够在Application类中进行全局设置。所有的设置都是可选的，不设置也无不影响使用。**建议在发布的版本中将logLevel设置为:LogLevel.NONE**\n\n### 添加TAG\n```java\n// 添加全局的TAG\nLogger.init(YOUR_TAG);\n// 添加当前Logger的TAG\nLogger.t(\"mytag\").d(\"hello\");\n```\n效果如下：\n![Logger打印效果](https://github.com/orhanobut/logger/raw/master/images/custom-tag.png)\n其实，在我看来，添加类的tag已经没有什么大的必要了，因为Logger在打印log的时候，会输出类名和方法名，直接检索就可以了。\n\n### 设置打印方法数\n```java\n// 修改全局打印的方法数\nLogger.init().methodCount(1);\n// 修改当前Logger想打印的方法数\nLogger.t(1).d(\"hello\");\n```\n### 设置方法方法堆栈偏移量\n为了避免其他库对logger的使用影响到程序的使用，可以设置类避免其他库的方法：\n```java\nLogger.init().methodOffset(5);\n```\n### 隐藏线程信息\n```java\nLogger.init().methodCount(1).hideThreadInfo();\n```\n### 仅打印消息\n```java\nLogger.init().methodCount(0).hideThreadInfo();\n```\n![只打印信息时的效果](https://github.com/orhanobut/logger/raw/master/images/just-content.png)\n\n### 使用其他Log工具代替android.util.log\n  1. 实现 LogAdapter\n  2. 在init中配置它\n\n具体配置代码可参考下面的例子：\n```java\n.logAdapter(new CustomLogAdapter());\n```\n\n### Timber Integration\n不明觉厉，所以只能把github上的介绍粘贴过来了。\n```java\nTimber.plant(new Timber.DebugTree() {\n  @Override protected void log(int priority, String tag, String message, Throwable t) {\n    Logger.log(priority, tag, message, t);\n  }\n});\n```\n\n# 代码实现原理解析\n整个代码也只有八个类，非常简洁。代码虽少，但是很规范，融入着基本的设计模式和思想，很值得学习。\n  * AndroidLogAdapter.java 其实就是对android.util.Log方法的封装。适配器类的简单应用实例。如果想对这个类进行重新封装，则可以实现自己的adapter，然后通过 ***Logger.logAdapter(new CustomLogAdapter());*** 方法进行设置。\n  * Helper.java helper类提供了一些静态方法用来处理字符串的相关操作，例如判空，判断两个字符串是否相同，取得堆栈字符串，避免空指针。\n  * LogAdapter.java 适配器的接口\n  * LogLevel.java 定义了log的级别，当前只有两种状态： FULL,NONE\n  * Logger.java 主类，\n  * LoggerPrinter.java 负责log的输出格式化，输出json，xml，set等数据。继承字Printer.java\n  * Printer.java Printer接口\n  * Settings.java logger配置的数据结构\n\n下面就针对Logger类和LoggerPrinter的实现进行进一步的分析。\n在Logger.java中，也基本上是完成了Settings和LoggerPrinter的实例化，并且封装了Printer的接口，给外部调用。主要可操作的接口有以下这些：\n * public static Settings init()\n * public static Settings init(String tag)\n * public static void resetSettings()\n * public static Printer t(String tag)\n * public static Printer t(int methodCount)\n * public static Printer t(String tag, int methodCount)\n * public static void log(int priority, String tag, String message, Throwable throwable)\n * public static void d(Object object) //其实可以看出的d方法中，可以直接将对象传入，如果是Array，则可以解析出数据进行打印，其他的则打印object.toString()信息，但是其他级别的log中并不能实现这一点。\n * public static void d(String message, Object... args)\n * public static void e(String message, Object... args)\n * public static void e(Throwable throwable, String message, Object... args)\n * public static void i(String message, Object... args)\n * public static void v(String message, Object... args)\n * public static void w(String message, Object... args)\n * public static void wtf(String message, Object... args)\n * public static void json(String json) //打印json数据\n * public static void xml(String xml) //打印xml信息\n\n在LoggerPrinter.java中，主要的逻辑集中在以下几个方法中：\njson（）方法：\n```java\n/**\n   * Formats the json content and print it\n   *\n   * @param json the json content\n   */\n  @Override public void json(String json) {\n    if (Helper.isEmpty(json)) {\n      d(\"Empty/Null json content\");\n      return;\n    }\n    try {\n      json = json.trim();\n      if (json.startsWith(\"{\")) {\n        JSONObject jsonObject = new JSONObject(json);\n        String message = jsonObject.toString(JSON_INDENT);\n        d(message);\n        return;\n      }\n      if (json.startsWith(\"[\")) {\n        JSONArray jsonArray = new JSONArray(json);\n        String message = jsonArray.toString(JSON_INDENT);\n        d(message);\n        return;\n      }\n      e(\"Invalid Json\");\n    } catch (JSONException e) {\n      e(\"Invalid Json\");\n    }\n  }\n\n```\nxml方法，用来将xml字符串进行简化。\n```java\n/**\n * Formats the json content and print it\n *\n * @param xml the xml content\n */\n@Override public void xml(String xml) {\n  if (Helper.isEmpty(xml)) {\n    d(\"Empty/Null xml content\");\n    return;\n  }\n  try {\n    Source xmlInput = new StreamSource(new StringReader(xml));\n    StreamResult xmlOutput = new StreamResult(new StringWriter());\n    Transformer transformer = TransformerFactory.newInstance().newTransformer();\n    transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n    transformer.setOutputProperty(\"{http://xml.apache.org/xslt}indent-amount\", \"2\");\n    transformer.transform(xmlInput, xmlOutput);\n    d(xmlOutput.getWriter().toString().replaceFirst(\">\", \">\\n\"));\n  } catch (TransformerException e) {\n    e(\"Invalid xml\");\n  }\n}\n```\nlog（）方法：\n```java\n@Override public synchronized void log(int priority, String tag, String message, Throwable throwable) {\n    if (settings.getLogLevel() == LogLevel.NONE) {\n      return;\n    }\n    if (throwable != null && message != null) {\n      message += \" : \" + Helper.getStackTraceString(throwable);\n    }\n    if (throwable != null && message == null) {\n      message = Helper.getStackTraceString(throwable);\n    }\n    if (message == null) {\n      message = \"No message/exception is set\";\n    }\n    int methodCount = getMethodCount();\n    if (Helper.isEmpty(message)) {\n      message = \"Empty/NULL log message\";\n    }\n\n    logTopBorder(priority, tag);\n    logHeaderContent(priority, tag, methodCount);\n\n    //get bytes of message with system's default charset (which is UTF-8 for Android)\n    byte[] bytes = message.getBytes();\n    int length = bytes.length;\n    if (length <= CHUNK_SIZE) {\n      if (methodCount > 0) {\n        logDivider(priority, tag);\n      }\n      logContent(priority, tag, message);\n      logBottomBorder(priority, tag);\n      return;\n    }\n    if (methodCount > 0) {\n      logDivider(priority, tag);\n    }\n    for (int i = 0; i < length; i += CHUNK_SIZE) {\n      int count = Math.min(length - i, CHUNK_SIZE);\n      //create a new String with system's default charset (which is UTF-8 for Android)\n      logContent(priority, tag, new String(bytes, i, count));\n    }\n    logBottomBorder(priority, tag);\n  }\n```\n\n# 功能优化\n这个以后有空再谈，毕竟还没有使用的需求。更谈不上优化了。\n","slug":"Logger_analyse","published":1,"updated":"2016-07-29T02:22:28.994Z","comments":1,"photos":[],"link":"","_id":"cirdlcvbz0004252na1tcr5uq","content":"<blockquote>\n<p>最近突发奇想，想自己重新封装android的log机制，以便于在以后的开发中简单的使用log进行调试。我们知道，在大多数的情况下我们需要对log的状态进行配置，在user版本中为了安全，某些关键log不能打印出来，同时，可能在调试的时候，我们只需要打印某个级别的log。通常情况下，我们是在每个类中进行log打印的控制（使用DEBUG的全局变量），每次打印log时都需要进行判断，这样的代码显然有点繁琐。所以，就需要通过封装Log完成上面的需求。为了避免重复造轮子，我在Github上检索了一下，果然发现了宝藏。一个名为Logger的开源项目，完美的诠释了什么是轮子。所以直接搬来用了。接下来的内容介绍这个项目如何使用。</p>\n</blockquote>\n<p><img align=\"right\" src=\"https://raw.githubusercontent.com/orhanobut/logger/master/images/logger-logo.png\" width=\"128\" height=\"128\"></p>\n<h1 id=\"Loger简介\"><a href=\"#Loger简介\" class=\"headerlink\" title=\"Loger简介\"></a>Loger简介</h1><p>Logger是github上关于Andorid Log打印优化和封装的开源项目，是一款简洁、优雅、强大的log跟踪器（官方如是说），截止目前已经有4003个star，700多个fork。项目地址为：<a href=\"https://github.com/orhanobut/logger\" target=\"_blank\" rel=\"external\">https://github.com/orhanobut/logger</a>。  </p>\n<p>它主要提供了以下功能：</p>\n<ul>\n<li>输出线程信息</li>\n<li>输出类信息</li>\n<li>输出方法信息</li>\n<li>格式化输出json数据</li>\n<li>对于log中的“\\n” 换行输出</li>\n<li>清理输出</li>\n<li>直接跳转到代码行</li>\n</ul>\n<p>下面来看看打印出的log效果吧：<br><img src=\"https://raw.githubusercontent.com/orhanobut/logger/master/images/description.png\" alt=\"Log\"></p>\n<blockquote>\n<p>同时，从所有的fork列表中，发现了另一个比较好的版本演变，如果感兴趣的话可以异步：<a href=\"https://github.com/tianzhijiexian/logger\" target=\"_blank\" rel=\"external\">tianzhijiexian/logger</a>。</p>\n</blockquote>\n<h1 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h1><h2 id=\"如何添加依赖\"><a href=\"#如何添加依赖\" class=\"headerlink\" title=\"如何添加依赖\"></a>如何添加依赖</h2><p>了解到这么强大的功能后，肯定想知道如何使用了。如果你的项目在使用gradle构建的话，最简单，最直接的方式就是添加依赖了。</p>\n<pre><code class=\"groovy\">compile &#39;com.orhanobut:logger:1.15&#39;\n</code></pre>\n<p>当然，如果不能直接引用的话，就乖乖下载源码，放入到系统，或者编译出jar包，做依赖吧。</p>\n<h2 id=\"在代码中使用\"><a href=\"#在代码中使用\" class=\"headerlink\" title=\"在代码中使用\"></a>在代码中使用</h2><p>Logger的使用上和Log的区别并不是很大。如下的代码展示了Logger的使用：</p>\n<pre><code class=\"java\">Logger.d(&quot;hello&quot;);\nLogger.d(&quot;hello %s %d&quot;, &quot;world&quot;, 5);   // String.format\nLogger.e(&quot;hello&quot;);\nLogger.e(exception,&quot;message&quot;);\nLogger.w(&quot;hello&quot;);\nLogger.v(&quot;hello&quot;);\nLogger.wtf(&quot;hello&quot;);\nLogger.json(JSON_CONTENT);\nLogger.xml(XML_CONTENT);\nLogger.log(DEBUG, &quot;tag&quot;, &quot;message&quot;, throwable);\n</code></pre>\n<p>同时，Logger还能直接打印Array, Map, Set and List等对象，不需要进行遍历输出。</p>\n<pre><code class=\"java\">Logger.d(list);\nLogger.d(map);\nLogger.d(set);\nLogger.d(new String[]);\n</code></pre>\n<h2 id=\"配置Logger\"><a href=\"#配置Logger\" class=\"headerlink\" title=\"配置Logger\"></a>配置Logger</h2><p>如果你相对Logger进行更深的定制的话，也可以在Logger的init方法中进行详细的配置：</p>\n<pre><code class=\"java\">Logger\n  .init(YOUR_TAG)                 // 默认为 PRETTYLOGGER 或者仅使用 init()\n  .methodCount(3)                 // 默认为 2\n  .hideThreadInfo()               // 默认为显示线程信息\n  .logLevel(LogLevel.NONE)        // 默认打印所有级别的log，即参数为：LogLevel.FULL\n  .methodOffset(2)                // 默认为 0\n  .logAdapter(new AndroidLogAdapter()); //默认为 AndroidLogAdapter\n}\n</code></pre>\n<p>需要注意的是，这个方法只能被调用一次，最好能够在Application类中进行全局设置。所有的设置都是可选的，不设置也无不影响使用。<strong>建议在发布的版本中将logLevel设置为:LogLevel.NONE</strong></p>\n<h3 id=\"添加TAG\"><a href=\"#添加TAG\" class=\"headerlink\" title=\"添加TAG\"></a>添加TAG</h3><pre><code class=\"java\">// 添加全局的TAG\nLogger.init(YOUR_TAG);\n// 添加当前Logger的TAG\nLogger.t(&quot;mytag&quot;).d(&quot;hello&quot;);\n</code></pre>\n<p>效果如下：<br><img src=\"https://github.com/orhanobut/logger/raw/master/images/custom-tag.png\" alt=\"Logger打印效果\"><br>其实，在我看来，添加类的tag已经没有什么大的必要了，因为Logger在打印log的时候，会输出类名和方法名，直接检索就可以了。</p>\n<h3 id=\"设置打印方法数\"><a href=\"#设置打印方法数\" class=\"headerlink\" title=\"设置打印方法数\"></a>设置打印方法数</h3><pre><code class=\"java\">// 修改全局打印的方法数\nLogger.init().methodCount(1);\n// 修改当前Logger想打印的方法数\nLogger.t(1).d(&quot;hello&quot;);\n</code></pre>\n<h3 id=\"设置方法方法堆栈偏移量\"><a href=\"#设置方法方法堆栈偏移量\" class=\"headerlink\" title=\"设置方法方法堆栈偏移量\"></a>设置方法方法堆栈偏移量</h3><p>为了避免其他库对logger的使用影响到程序的使用，可以设置类避免其他库的方法：</p>\n<pre><code class=\"java\">Logger.init().methodOffset(5);\n</code></pre>\n<h3 id=\"隐藏线程信息\"><a href=\"#隐藏线程信息\" class=\"headerlink\" title=\"隐藏线程信息\"></a>隐藏线程信息</h3><pre><code class=\"java\">Logger.init().methodCount(1).hideThreadInfo();\n</code></pre>\n<h3 id=\"仅打印消息\"><a href=\"#仅打印消息\" class=\"headerlink\" title=\"仅打印消息\"></a>仅打印消息</h3><pre><code class=\"java\">Logger.init().methodCount(0).hideThreadInfo();\n</code></pre>\n<p><img src=\"https://github.com/orhanobut/logger/raw/master/images/just-content.png\" alt=\"只打印信息时的效果\"></p>\n<h3 id=\"使用其他Log工具代替android-util-log\"><a href=\"#使用其他Log工具代替android-util-log\" class=\"headerlink\" title=\"使用其他Log工具代替android.util.log\"></a>使用其他Log工具代替android.util.log</h3><ol>\n<li>实现 LogAdapter</li>\n<li>在init中配置它</li>\n</ol>\n<p>具体配置代码可参考下面的例子：</p>\n<pre><code class=\"java\">.logAdapter(new CustomLogAdapter());\n</code></pre>\n<h3 id=\"Timber-Integration\"><a href=\"#Timber-Integration\" class=\"headerlink\" title=\"Timber Integration\"></a>Timber Integration</h3><p>不明觉厉，所以只能把github上的介绍粘贴过来了。</p>\n<pre><code class=\"java\">Timber.plant(new Timber.DebugTree() {\n  @Override protected void log(int priority, String tag, String message, Throwable t) {\n    Logger.log(priority, tag, message, t);\n  }\n});\n</code></pre>\n<h1 id=\"代码实现原理解析\"><a href=\"#代码实现原理解析\" class=\"headerlink\" title=\"代码实现原理解析\"></a>代码实现原理解析</h1><p>整个代码也只有八个类，非常简洁。代码虽少，但是很规范，融入着基本的设计模式和思想，很值得学习。</p>\n<ul>\n<li>AndroidLogAdapter.java 其实就是对android.util.Log方法的封装。适配器类的简单应用实例。如果想对这个类进行重新封装，则可以实现自己的adapter，然后通过 <strong><em>Logger.logAdapter(new CustomLogAdapter());</em></strong> 方法进行设置。</li>\n<li>Helper.java helper类提供了一些静态方法用来处理字符串的相关操作，例如判空，判断两个字符串是否相同，取得堆栈字符串，避免空指针。</li>\n<li>LogAdapter.java 适配器的接口</li>\n<li>LogLevel.java 定义了log的级别，当前只有两种状态： FULL,NONE</li>\n<li>Logger.java 主类，</li>\n<li>LoggerPrinter.java 负责log的输出格式化，输出json，xml，set等数据。继承字Printer.java</li>\n<li>Printer.java Printer接口</li>\n<li>Settings.java logger配置的数据结构</li>\n</ul>\n<p>下面就针对Logger类和LoggerPrinter的实现进行进一步的分析。<br>在Logger.java中，也基本上是完成了Settings和LoggerPrinter的实例化，并且封装了Printer的接口，给外部调用。主要可操作的接口有以下这些：</p>\n<ul>\n<li>public static Settings init()</li>\n<li>public static Settings init(String tag)</li>\n<li>public static void resetSettings()</li>\n<li>public static Printer t(String tag)</li>\n<li>public static Printer t(int methodCount)</li>\n<li>public static Printer t(String tag, int methodCount)</li>\n<li>public static void log(int priority, String tag, String message, Throwable throwable)</li>\n<li>public static void d(Object object) //其实可以看出的d方法中，可以直接将对象传入，如果是Array，则可以解析出数据进行打印，其他的则打印object.toString()信息，但是其他级别的log中并不能实现这一点。</li>\n<li>public static void d(String message, Object… args)</li>\n<li>public static void e(String message, Object… args)</li>\n<li>public static void e(Throwable throwable, String message, Object… args)</li>\n<li>public static void i(String message, Object… args)</li>\n<li>public static void v(String message, Object… args)</li>\n<li>public static void w(String message, Object… args)</li>\n<li>public static void wtf(String message, Object… args)</li>\n<li>public static void json(String json) //打印json数据</li>\n<li>public static void xml(String xml) //打印xml信息</li>\n</ul>\n<p>在LoggerPrinter.java中，主要的逻辑集中在以下几个方法中：<br>json（）方法：</p>\n<pre><code class=\"java\">/**\n   * Formats the json content and print it\n   *\n   * @param json the json content\n   */\n  @Override public void json(String json) {\n    if (Helper.isEmpty(json)) {\n      d(&quot;Empty/Null json content&quot;);\n      return;\n    }\n    try {\n      json = json.trim();\n      if (json.startsWith(&quot;{&quot;)) {\n        JSONObject jsonObject = new JSONObject(json);\n        String message = jsonObject.toString(JSON_INDENT);\n        d(message);\n        return;\n      }\n      if (json.startsWith(&quot;[&quot;)) {\n        JSONArray jsonArray = new JSONArray(json);\n        String message = jsonArray.toString(JSON_INDENT);\n        d(message);\n        return;\n      }\n      e(&quot;Invalid Json&quot;);\n    } catch (JSONException e) {\n      e(&quot;Invalid Json&quot;);\n    }\n  }\n</code></pre>\n<p>xml方法，用来将xml字符串进行简化。</p>\n<pre><code class=\"java\">/**\n * Formats the json content and print it\n *\n * @param xml the xml content\n */\n@Override public void xml(String xml) {\n  if (Helper.isEmpty(xml)) {\n    d(&quot;Empty/Null xml content&quot;);\n    return;\n  }\n  try {\n    Source xmlInput = new StreamSource(new StringReader(xml));\n    StreamResult xmlOutput = new StreamResult(new StringWriter());\n    Transformer transformer = TransformerFactory.newInstance().newTransformer();\n    transformer.setOutputProperty(OutputKeys.INDENT, &quot;yes&quot;);\n    transformer.setOutputProperty(&quot;{http://xml.apache.org/xslt}indent-amount&quot;, &quot;2&quot;);\n    transformer.transform(xmlInput, xmlOutput);\n    d(xmlOutput.getWriter().toString().replaceFirst(&quot;&gt;&quot;, &quot;&gt;\\n&quot;));\n  } catch (TransformerException e) {\n    e(&quot;Invalid xml&quot;);\n  }\n}\n</code></pre>\n<p>log（）方法：</p>\n<pre><code class=\"java\">@Override public synchronized void log(int priority, String tag, String message, Throwable throwable) {\n    if (settings.getLogLevel() == LogLevel.NONE) {\n      return;\n    }\n    if (throwable != null &amp;&amp; message != null) {\n      message += &quot; : &quot; + Helper.getStackTraceString(throwable);\n    }\n    if (throwable != null &amp;&amp; message == null) {\n      message = Helper.getStackTraceString(throwable);\n    }\n    if (message == null) {\n      message = &quot;No message/exception is set&quot;;\n    }\n    int methodCount = getMethodCount();\n    if (Helper.isEmpty(message)) {\n      message = &quot;Empty/NULL log message&quot;;\n    }\n\n    logTopBorder(priority, tag);\n    logHeaderContent(priority, tag, methodCount);\n\n    //get bytes of message with system&#39;s default charset (which is UTF-8 for Android)\n    byte[] bytes = message.getBytes();\n    int length = bytes.length;\n    if (length &lt;= CHUNK_SIZE) {\n      if (methodCount &gt; 0) {\n        logDivider(priority, tag);\n      }\n      logContent(priority, tag, message);\n      logBottomBorder(priority, tag);\n      return;\n    }\n    if (methodCount &gt; 0) {\n      logDivider(priority, tag);\n    }\n    for (int i = 0; i &lt; length; i += CHUNK_SIZE) {\n      int count = Math.min(length - i, CHUNK_SIZE);\n      //create a new String with system&#39;s default charset (which is UTF-8 for Android)\n      logContent(priority, tag, new String(bytes, i, count));\n    }\n    logBottomBorder(priority, tag);\n  }\n</code></pre>\n<h1 id=\"功能优化\"><a href=\"#功能优化\" class=\"headerlink\" title=\"功能优化\"></a>功能优化</h1><p>这个以后有空再谈，毕竟还没有使用的需求。更谈不上优化了。</p>\n","excerpt":"","more":"<blockquote>\n<p>最近突发奇想，想自己重新封装android的log机制，以便于在以后的开发中简单的使用log进行调试。我们知道，在大多数的情况下我们需要对log的状态进行配置，在user版本中为了安全，某些关键log不能打印出来，同时，可能在调试的时候，我们只需要打印某个级别的log。通常情况下，我们是在每个类中进行log打印的控制（使用DEBUG的全局变量），每次打印log时都需要进行判断，这样的代码显然有点繁琐。所以，就需要通过封装Log完成上面的需求。为了避免重复造轮子，我在Github上检索了一下，果然发现了宝藏。一个名为Logger的开源项目，完美的诠释了什么是轮子。所以直接搬来用了。接下来的内容介绍这个项目如何使用。</p>\n</blockquote>\n<p><img align=\"right\" src='https://raw.githubusercontent.com/orhanobut/logger/master/images/logger-logo.png' width='128' height='128'/></p>\n<h1 id=\"Loger简介\"><a href=\"#Loger简介\" class=\"headerlink\" title=\"Loger简介\"></a>Loger简介</h1><p>Logger是github上关于Andorid Log打印优化和封装的开源项目，是一款简洁、优雅、强大的log跟踪器（官方如是说），截止目前已经有4003个star，700多个fork。项目地址为：<a href=\"https://github.com/orhanobut/logger\">https://github.com/orhanobut/logger</a>。  </p>\n<p>它主要提供了以下功能：</p>\n<ul>\n<li>输出线程信息</li>\n<li>输出类信息</li>\n<li>输出方法信息</li>\n<li>格式化输出json数据</li>\n<li>对于log中的“\\n” 换行输出</li>\n<li>清理输出</li>\n<li>直接跳转到代码行</li>\n</ul>\n<p>下面来看看打印出的log效果吧：<br><img src=\"https://raw.githubusercontent.com/orhanobut/logger/master/images/description.png\" alt=\"Log\"></p>\n<blockquote>\n<p>同时，从所有的fork列表中，发现了另一个比较好的版本演变，如果感兴趣的话可以异步：<a href=\"https://github.com/tianzhijiexian/logger\">tianzhijiexian/logger</a>。</p>\n</blockquote>\n<h1 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h1><h2 id=\"如何添加依赖\"><a href=\"#如何添加依赖\" class=\"headerlink\" title=\"如何添加依赖\"></a>如何添加依赖</h2><p>了解到这么强大的功能后，肯定想知道如何使用了。如果你的项目在使用gradle构建的话，最简单，最直接的方式就是添加依赖了。</p>\n<pre><code class=\"groovy\">compile &#39;com.orhanobut:logger:1.15&#39;\n</code></pre>\n<p>当然，如果不能直接引用的话，就乖乖下载源码，放入到系统，或者编译出jar包，做依赖吧。</p>\n<h2 id=\"在代码中使用\"><a href=\"#在代码中使用\" class=\"headerlink\" title=\"在代码中使用\"></a>在代码中使用</h2><p>Logger的使用上和Log的区别并不是很大。如下的代码展示了Logger的使用：</p>\n<pre><code class=\"java\">Logger.d(&quot;hello&quot;);\nLogger.d(&quot;hello %s %d&quot;, &quot;world&quot;, 5);   // String.format\nLogger.e(&quot;hello&quot;);\nLogger.e(exception,&quot;message&quot;);\nLogger.w(&quot;hello&quot;);\nLogger.v(&quot;hello&quot;);\nLogger.wtf(&quot;hello&quot;);\nLogger.json(JSON_CONTENT);\nLogger.xml(XML_CONTENT);\nLogger.log(DEBUG, &quot;tag&quot;, &quot;message&quot;, throwable);\n</code></pre>\n<p>同时，Logger还能直接打印Array, Map, Set and List等对象，不需要进行遍历输出。</p>\n<pre><code class=\"java\">Logger.d(list);\nLogger.d(map);\nLogger.d(set);\nLogger.d(new String[]);\n</code></pre>\n<h2 id=\"配置Logger\"><a href=\"#配置Logger\" class=\"headerlink\" title=\"配置Logger\"></a>配置Logger</h2><p>如果你相对Logger进行更深的定制的话，也可以在Logger的init方法中进行详细的配置：</p>\n<pre><code class=\"java\">Logger\n  .init(YOUR_TAG)                 // 默认为 PRETTYLOGGER 或者仅使用 init()\n  .methodCount(3)                 // 默认为 2\n  .hideThreadInfo()               // 默认为显示线程信息\n  .logLevel(LogLevel.NONE)        // 默认打印所有级别的log，即参数为：LogLevel.FULL\n  .methodOffset(2)                // 默认为 0\n  .logAdapter(new AndroidLogAdapter()); //默认为 AndroidLogAdapter\n}\n</code></pre>\n<p>需要注意的是，这个方法只能被调用一次，最好能够在Application类中进行全局设置。所有的设置都是可选的，不设置也无不影响使用。<strong>建议在发布的版本中将logLevel设置为:LogLevel.NONE</strong></p>\n<h3 id=\"添加TAG\"><a href=\"#添加TAG\" class=\"headerlink\" title=\"添加TAG\"></a>添加TAG</h3><pre><code class=\"java\">// 添加全局的TAG\nLogger.init(YOUR_TAG);\n// 添加当前Logger的TAG\nLogger.t(&quot;mytag&quot;).d(&quot;hello&quot;);\n</code></pre>\n<p>效果如下：<br><img src=\"https://github.com/orhanobut/logger/raw/master/images/custom-tag.png\" alt=\"Logger打印效果\"><br>其实，在我看来，添加类的tag已经没有什么大的必要了，因为Logger在打印log的时候，会输出类名和方法名，直接检索就可以了。</p>\n<h3 id=\"设置打印方法数\"><a href=\"#设置打印方法数\" class=\"headerlink\" title=\"设置打印方法数\"></a>设置打印方法数</h3><pre><code class=\"java\">// 修改全局打印的方法数\nLogger.init().methodCount(1);\n// 修改当前Logger想打印的方法数\nLogger.t(1).d(&quot;hello&quot;);\n</code></pre>\n<h3 id=\"设置方法方法堆栈偏移量\"><a href=\"#设置方法方法堆栈偏移量\" class=\"headerlink\" title=\"设置方法方法堆栈偏移量\"></a>设置方法方法堆栈偏移量</h3><p>为了避免其他库对logger的使用影响到程序的使用，可以设置类避免其他库的方法：</p>\n<pre><code class=\"java\">Logger.init().methodOffset(5);\n</code></pre>\n<h3 id=\"隐藏线程信息\"><a href=\"#隐藏线程信息\" class=\"headerlink\" title=\"隐藏线程信息\"></a>隐藏线程信息</h3><pre><code class=\"java\">Logger.init().methodCount(1).hideThreadInfo();\n</code></pre>\n<h3 id=\"仅打印消息\"><a href=\"#仅打印消息\" class=\"headerlink\" title=\"仅打印消息\"></a>仅打印消息</h3><pre><code class=\"java\">Logger.init().methodCount(0).hideThreadInfo();\n</code></pre>\n<p><img src=\"https://github.com/orhanobut/logger/raw/master/images/just-content.png\" alt=\"只打印信息时的效果\"></p>\n<h3 id=\"使用其他Log工具代替android-util-log\"><a href=\"#使用其他Log工具代替android-util-log\" class=\"headerlink\" title=\"使用其他Log工具代替android.util.log\"></a>使用其他Log工具代替android.util.log</h3><ol>\n<li>实现 LogAdapter</li>\n<li>在init中配置它</li>\n</ol>\n<p>具体配置代码可参考下面的例子：</p>\n<pre><code class=\"java\">.logAdapter(new CustomLogAdapter());\n</code></pre>\n<h3 id=\"Timber-Integration\"><a href=\"#Timber-Integration\" class=\"headerlink\" title=\"Timber Integration\"></a>Timber Integration</h3><p>不明觉厉，所以只能把github上的介绍粘贴过来了。</p>\n<pre><code class=\"java\">Timber.plant(new Timber.DebugTree() {\n  @Override protected void log(int priority, String tag, String message, Throwable t) {\n    Logger.log(priority, tag, message, t);\n  }\n});\n</code></pre>\n<h1 id=\"代码实现原理解析\"><a href=\"#代码实现原理解析\" class=\"headerlink\" title=\"代码实现原理解析\"></a>代码实现原理解析</h1><p>整个代码也只有八个类，非常简洁。代码虽少，但是很规范，融入着基本的设计模式和思想，很值得学习。</p>\n<ul>\n<li>AndroidLogAdapter.java 其实就是对android.util.Log方法的封装。适配器类的简单应用实例。如果想对这个类进行重新封装，则可以实现自己的adapter，然后通过 <strong><em>Logger.logAdapter(new CustomLogAdapter());</em></strong> 方法进行设置。</li>\n<li>Helper.java helper类提供了一些静态方法用来处理字符串的相关操作，例如判空，判断两个字符串是否相同，取得堆栈字符串，避免空指针。</li>\n<li>LogAdapter.java 适配器的接口</li>\n<li>LogLevel.java 定义了log的级别，当前只有两种状态： FULL,NONE</li>\n<li>Logger.java 主类，</li>\n<li>LoggerPrinter.java 负责log的输出格式化，输出json，xml，set等数据。继承字Printer.java</li>\n<li>Printer.java Printer接口</li>\n<li>Settings.java logger配置的数据结构</li>\n</ul>\n<p>下面就针对Logger类和LoggerPrinter的实现进行进一步的分析。<br>在Logger.java中，也基本上是完成了Settings和LoggerPrinter的实例化，并且封装了Printer的接口，给外部调用。主要可操作的接口有以下这些：</p>\n<ul>\n<li>public static Settings init()</li>\n<li>public static Settings init(String tag)</li>\n<li>public static void resetSettings()</li>\n<li>public static Printer t(String tag)</li>\n<li>public static Printer t(int methodCount)</li>\n<li>public static Printer t(String tag, int methodCount)</li>\n<li>public static void log(int priority, String tag, String message, Throwable throwable)</li>\n<li>public static void d(Object object) //其实可以看出的d方法中，可以直接将对象传入，如果是Array，则可以解析出数据进行打印，其他的则打印object.toString()信息，但是其他级别的log中并不能实现这一点。</li>\n<li>public static void d(String message, Object… args)</li>\n<li>public static void e(String message, Object… args)</li>\n<li>public static void e(Throwable throwable, String message, Object… args)</li>\n<li>public static void i(String message, Object… args)</li>\n<li>public static void v(String message, Object… args)</li>\n<li>public static void w(String message, Object… args)</li>\n<li>public static void wtf(String message, Object… args)</li>\n<li>public static void json(String json) //打印json数据</li>\n<li>public static void xml(String xml) //打印xml信息</li>\n</ul>\n<p>在LoggerPrinter.java中，主要的逻辑集中在以下几个方法中：<br>json（）方法：</p>\n<pre><code class=\"java\">/**\n   * Formats the json content and print it\n   *\n   * @param json the json content\n   */\n  @Override public void json(String json) {\n    if (Helper.isEmpty(json)) {\n      d(&quot;Empty/Null json content&quot;);\n      return;\n    }\n    try {\n      json = json.trim();\n      if (json.startsWith(&quot;{&quot;)) {\n        JSONObject jsonObject = new JSONObject(json);\n        String message = jsonObject.toString(JSON_INDENT);\n        d(message);\n        return;\n      }\n      if (json.startsWith(&quot;[&quot;)) {\n        JSONArray jsonArray = new JSONArray(json);\n        String message = jsonArray.toString(JSON_INDENT);\n        d(message);\n        return;\n      }\n      e(&quot;Invalid Json&quot;);\n    } catch (JSONException e) {\n      e(&quot;Invalid Json&quot;);\n    }\n  }\n</code></pre>\n<p>xml方法，用来将xml字符串进行简化。</p>\n<pre><code class=\"java\">/**\n * Formats the json content and print it\n *\n * @param xml the xml content\n */\n@Override public void xml(String xml) {\n  if (Helper.isEmpty(xml)) {\n    d(&quot;Empty/Null xml content&quot;);\n    return;\n  }\n  try {\n    Source xmlInput = new StreamSource(new StringReader(xml));\n    StreamResult xmlOutput = new StreamResult(new StringWriter());\n    Transformer transformer = TransformerFactory.newInstance().newTransformer();\n    transformer.setOutputProperty(OutputKeys.INDENT, &quot;yes&quot;);\n    transformer.setOutputProperty(&quot;{http://xml.apache.org/xslt}indent-amount&quot;, &quot;2&quot;);\n    transformer.transform(xmlInput, xmlOutput);\n    d(xmlOutput.getWriter().toString().replaceFirst(&quot;&gt;&quot;, &quot;&gt;\\n&quot;));\n  } catch (TransformerException e) {\n    e(&quot;Invalid xml&quot;);\n  }\n}\n</code></pre>\n<p>log（）方法：</p>\n<pre><code class=\"java\">@Override public synchronized void log(int priority, String tag, String message, Throwable throwable) {\n    if (settings.getLogLevel() == LogLevel.NONE) {\n      return;\n    }\n    if (throwable != null &amp;&amp; message != null) {\n      message += &quot; : &quot; + Helper.getStackTraceString(throwable);\n    }\n    if (throwable != null &amp;&amp; message == null) {\n      message = Helper.getStackTraceString(throwable);\n    }\n    if (message == null) {\n      message = &quot;No message/exception is set&quot;;\n    }\n    int methodCount = getMethodCount();\n    if (Helper.isEmpty(message)) {\n      message = &quot;Empty/NULL log message&quot;;\n    }\n\n    logTopBorder(priority, tag);\n    logHeaderContent(priority, tag, methodCount);\n\n    //get bytes of message with system&#39;s default charset (which is UTF-8 for Android)\n    byte[] bytes = message.getBytes();\n    int length = bytes.length;\n    if (length &lt;= CHUNK_SIZE) {\n      if (methodCount &gt; 0) {\n        logDivider(priority, tag);\n      }\n      logContent(priority, tag, message);\n      logBottomBorder(priority, tag);\n      return;\n    }\n    if (methodCount &gt; 0) {\n      logDivider(priority, tag);\n    }\n    for (int i = 0; i &lt; length; i += CHUNK_SIZE) {\n      int count = Math.min(length - i, CHUNK_SIZE);\n      //create a new String with system&#39;s default charset (which is UTF-8 for Android)\n      logContent(priority, tag, new String(bytes, i, count));\n    }\n    logBottomBorder(priority, tag);\n  }\n</code></pre>\n<h1 id=\"功能优化\"><a href=\"#功能优化\" class=\"headerlink\" title=\"功能优化\"></a>功能优化</h1><p>这个以后有空再谈，毕竟还没有使用的需求。更谈不上优化了。</p>\n"},{"layout":"post","title":"Android学习资源推荐","subtitle":"为大家整理了一些Android领域的学习资料","author":"JianGuo","header-img":"android-study-source-bg1.jpeg","date":"2016-06-20T08:32:29.000Z","_content":"\n\n> 俗话说工欲善其事必先利其器，要想在android应用程序开发的道路上走的更长，更远，就需要不断的学习新的知识和思想，多看看官方提供的文档，在闲暇之余关注开源网站，开源项目，甚至贡献自己的代码，都会有很大的提升。有了得心应手的工具，会使得你的工作事半功倍。  \n同样，三人行，必有我师，学习的过程也是分享和交流的过程。所以，关注同领域技术大牛的博客，关注技术的动态，才能不被技术淘汰。因此，我将平时学习的时候积累下来的一些值得推荐的网站和经验推荐给大家，由于篇幅有限，没有展开说明。希望大家，通过查找，多多了解这些资源。其中有一部分的网站需要翻墙打开，做技术的，相信大家手里都备好了梯子。加油！\n\n## 一、官方文档\n\n1. android源代码官方文档：https://source.android.com/source/index.html\n2. android应用开发官方文档：http://developer.android.com/intl/zh-cn/index.html\n3. android studio中文社区：http://www.android-studio.org/\n4. gradle官方文档：https://docs.gradle.org/current/dsl/org.gradle.api.tasks.SourceSet.html\n5. andorid 设计中文翻译：http://adchs.github.io/get-started/create-vistion.html\n\n## 二、开源网站：\n\n1. android开源镜像站：http://mirrors.neusoft.edu.cn/\n2. github：https://github.com/\n3. 开源中国：http://www.oschina.net/\n4. 第三方rom项目开源地址：https://wiki.cyanogenmod.org/w/Main_Page/zh-cn\n\n## 三、工具推荐\n1. 好用的模拟器：https://www.genymotion.com/\n2. 查看API网站：http://grepcode.com/\n3. 技术问题集结地：http://stackoverflow.com/\n\n## 四、大牛博客\n1. CoderRobin：http://coderrobin.com/\n2. 码农明明桑：http://blog.isming.me/\n3. stormzhang:http://stormzhang.com/posts.html\n4. Trinea:http://www.trinea.cn/\n5. 农民伯伯：http://www.cnblogs.com/over140/\n6. 胡凯：http://hukai.me/\n7. world hello :http://www.worldhello.net/\n8. 老罗的android之旅：http://blog.csdn.net/luoshengyang\n9. 阿拉神农的博客：http://blog.csdn.net/innost\n10. Gracker：http://androidperformance.com/\n\n## 五、优秀的开源项目\n1. android开源项目汇总：https://github.com/kesenhoo/android-open-project\n2. android开源项目解析：https://github.com/android-cn/android-open-project-analysis\n3. 强大的图片异步加载库Universal Image Loader：https://github.com/nostra13/Android-Universal-Image-Loader\n4. 好看的进度条实现：https://github.com/tangqi92/WaveLoadingView\n5. Glide：https://github.com/bumptech/glide\n6. 没有找不到的开源项目（开源项目集结地）：https://github.com/\n7. 开源app整理：http://www.jcodecraeer.com/plus/list.php?tid=31&codecategory=22000\n\n## 六、学习建议\n1. 尽量在google官方文档中找答案\n2. 搜索引擎一定要使用google\n3. 尽量去看一些英文的文档，帮助理解\n4. 了解Android最基础的进程间通讯。知道AIDL如何使用, 也要知道如何手写Binder接口。这对你理解Android的Application和System services如何交互有非常重要的作用。\n5. 学会使用UML语言交流\n\n## 六、最佳实践\n1. 善用mmm编译项目\n2. 了解工具的使用会让你的工作事半功倍\n3. 了解21种设计模式\n4. 分模块学习\n\n……\n\n> （以后在学习过程中会不断完善这份资料，如果有好的建议，也希望大家能给出你的想法）\n","source":"_posts/AndroidStudySource.md","raw":"---\nlayout: post\ntitle: Android学习资源推荐\nsubtitle: 为大家整理了一些Android领域的学习资料\nauthor: JianGuo\nheader-img: android-study-source-bg1.jpeg\ntags: Android\ndate: 2016-06-20 16:32:29\n---\n\n\n> 俗话说工欲善其事必先利其器，要想在android应用程序开发的道路上走的更长，更远，就需要不断的学习新的知识和思想，多看看官方提供的文档，在闲暇之余关注开源网站，开源项目，甚至贡献自己的代码，都会有很大的提升。有了得心应手的工具，会使得你的工作事半功倍。  \n同样，三人行，必有我师，学习的过程也是分享和交流的过程。所以，关注同领域技术大牛的博客，关注技术的动态，才能不被技术淘汰。因此，我将平时学习的时候积累下来的一些值得推荐的网站和经验推荐给大家，由于篇幅有限，没有展开说明。希望大家，通过查找，多多了解这些资源。其中有一部分的网站需要翻墙打开，做技术的，相信大家手里都备好了梯子。加油！\n\n## 一、官方文档\n\n1. android源代码官方文档：https://source.android.com/source/index.html\n2. android应用开发官方文档：http://developer.android.com/intl/zh-cn/index.html\n3. android studio中文社区：http://www.android-studio.org/\n4. gradle官方文档：https://docs.gradle.org/current/dsl/org.gradle.api.tasks.SourceSet.html\n5. andorid 设计中文翻译：http://adchs.github.io/get-started/create-vistion.html\n\n## 二、开源网站：\n\n1. android开源镜像站：http://mirrors.neusoft.edu.cn/\n2. github：https://github.com/\n3. 开源中国：http://www.oschina.net/\n4. 第三方rom项目开源地址：https://wiki.cyanogenmod.org/w/Main_Page/zh-cn\n\n## 三、工具推荐\n1. 好用的模拟器：https://www.genymotion.com/\n2. 查看API网站：http://grepcode.com/\n3. 技术问题集结地：http://stackoverflow.com/\n\n## 四、大牛博客\n1. CoderRobin：http://coderrobin.com/\n2. 码农明明桑：http://blog.isming.me/\n3. stormzhang:http://stormzhang.com/posts.html\n4. Trinea:http://www.trinea.cn/\n5. 农民伯伯：http://www.cnblogs.com/over140/\n6. 胡凯：http://hukai.me/\n7. world hello :http://www.worldhello.net/\n8. 老罗的android之旅：http://blog.csdn.net/luoshengyang\n9. 阿拉神农的博客：http://blog.csdn.net/innost\n10. Gracker：http://androidperformance.com/\n\n## 五、优秀的开源项目\n1. android开源项目汇总：https://github.com/kesenhoo/android-open-project\n2. android开源项目解析：https://github.com/android-cn/android-open-project-analysis\n3. 强大的图片异步加载库Universal Image Loader：https://github.com/nostra13/Android-Universal-Image-Loader\n4. 好看的进度条实现：https://github.com/tangqi92/WaveLoadingView\n5. Glide：https://github.com/bumptech/glide\n6. 没有找不到的开源项目（开源项目集结地）：https://github.com/\n7. 开源app整理：http://www.jcodecraeer.com/plus/list.php?tid=31&codecategory=22000\n\n## 六、学习建议\n1. 尽量在google官方文档中找答案\n2. 搜索引擎一定要使用google\n3. 尽量去看一些英文的文档，帮助理解\n4. 了解Android最基础的进程间通讯。知道AIDL如何使用, 也要知道如何手写Binder接口。这对你理解Android的Application和System services如何交互有非常重要的作用。\n5. 学会使用UML语言交流\n\n## 六、最佳实践\n1. 善用mmm编译项目\n2. 了解工具的使用会让你的工作事半功倍\n3. 了解21种设计模式\n4. 分模块学习\n\n……\n\n> （以后在学习过程中会不断完善这份资料，如果有好的建议，也希望大家能给出你的想法）\n","slug":"AndroidStudySource","published":1,"updated":"2016-07-28T12:15:26.820Z","comments":1,"photos":[],"link":"","_id":"cirdlcvc00005252n0ef0rm7e","content":"<blockquote>\n<p>俗话说工欲善其事必先利其器，要想在android应用程序开发的道路上走的更长，更远，就需要不断的学习新的知识和思想，多看看官方提供的文档，在闲暇之余关注开源网站，开源项目，甚至贡献自己的代码，都会有很大的提升。有了得心应手的工具，会使得你的工作事半功倍。<br>同样，三人行，必有我师，学习的过程也是分享和交流的过程。所以，关注同领域技术大牛的博客，关注技术的动态，才能不被技术淘汰。因此，我将平时学习的时候积累下来的一些值得推荐的网站和经验推荐给大家，由于篇幅有限，没有展开说明。希望大家，通过查找，多多了解这些资源。其中有一部分的网站需要翻墙打开，做技术的，相信大家手里都备好了梯子。加油！</p>\n</blockquote>\n<h2 id=\"一、官方文档\"><a href=\"#一、官方文档\" class=\"headerlink\" title=\"一、官方文档\"></a>一、官方文档</h2><ol>\n<li>android源代码官方文档：<a href=\"https://source.android.com/source/index.html\" target=\"_blank\" rel=\"external\">https://source.android.com/source/index.html</a></li>\n<li>android应用开发官方文档：<a href=\"http://developer.android.com/intl/zh-cn/index.html\" target=\"_blank\" rel=\"external\">http://developer.android.com/intl/zh-cn/index.html</a></li>\n<li>android studio中文社区：<a href=\"http://www.android-studio.org/\" target=\"_blank\" rel=\"external\">http://www.android-studio.org/</a></li>\n<li>gradle官方文档：<a href=\"https://docs.gradle.org/current/dsl/org.gradle.api.tasks.SourceSet.html\" target=\"_blank\" rel=\"external\">https://docs.gradle.org/current/dsl/org.gradle.api.tasks.SourceSet.html</a></li>\n<li>andorid 设计中文翻译：<a href=\"http://adchs.github.io/get-started/create-vistion.html\" target=\"_blank\" rel=\"external\">http://adchs.github.io/get-started/create-vistion.html</a></li>\n</ol>\n<h2 id=\"二、开源网站：\"><a href=\"#二、开源网站：\" class=\"headerlink\" title=\"二、开源网站：\"></a>二、开源网站：</h2><ol>\n<li>android开源镜像站：<a href=\"http://mirrors.neusoft.edu.cn/\" target=\"_blank\" rel=\"external\">http://mirrors.neusoft.edu.cn/</a></li>\n<li>github：<a href=\"https://github.com/\" target=\"_blank\" rel=\"external\">https://github.com/</a></li>\n<li>开源中国：<a href=\"http://www.oschina.net/\" target=\"_blank\" rel=\"external\">http://www.oschina.net/</a></li>\n<li>第三方rom项目开源地址：<a href=\"https://wiki.cyanogenmod.org/w/Main_Page/zh-cn\" target=\"_blank\" rel=\"external\">https://wiki.cyanogenmod.org/w/Main_Page/zh-cn</a></li>\n</ol>\n<h2 id=\"三、工具推荐\"><a href=\"#三、工具推荐\" class=\"headerlink\" title=\"三、工具推荐\"></a>三、工具推荐</h2><ol>\n<li>好用的模拟器：<a href=\"https://www.genymotion.com/\" target=\"_blank\" rel=\"external\">https://www.genymotion.com/</a></li>\n<li>查看API网站：<a href=\"http://grepcode.com/\" target=\"_blank\" rel=\"external\">http://grepcode.com/</a></li>\n<li>技术问题集结地：<a href=\"http://stackoverflow.com/\" target=\"_blank\" rel=\"external\">http://stackoverflow.com/</a></li>\n</ol>\n<h2 id=\"四、大牛博客\"><a href=\"#四、大牛博客\" class=\"headerlink\" title=\"四、大牛博客\"></a>四、大牛博客</h2><ol>\n<li>CoderRobin：<a href=\"http://coderrobin.com/\" target=\"_blank\" rel=\"external\">http://coderrobin.com/</a></li>\n<li>码农明明桑：<a href=\"http://blog.isming.me/\" target=\"_blank\" rel=\"external\">http://blog.isming.me/</a></li>\n<li>stormzhang:<a href=\"http://stormzhang.com/posts.html\" target=\"_blank\" rel=\"external\">http://stormzhang.com/posts.html</a></li>\n<li>Trinea:<a href=\"http://www.trinea.cn/\" target=\"_blank\" rel=\"external\">http://www.trinea.cn/</a></li>\n<li>农民伯伯：<a href=\"http://www.cnblogs.com/over140/\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/over140/</a></li>\n<li>胡凯：<a href=\"http://hukai.me/\" target=\"_blank\" rel=\"external\">http://hukai.me/</a></li>\n<li>world hello :<a href=\"http://www.worldhello.net/\" target=\"_blank\" rel=\"external\">http://www.worldhello.net/</a></li>\n<li>老罗的android之旅：<a href=\"http://blog.csdn.net/luoshengyang\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/luoshengyang</a></li>\n<li>阿拉神农的博客：<a href=\"http://blog.csdn.net/innost\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/innost</a></li>\n<li>Gracker：<a href=\"http://androidperformance.com/\" target=\"_blank\" rel=\"external\">http://androidperformance.com/</a></li>\n</ol>\n<h2 id=\"五、优秀的开源项目\"><a href=\"#五、优秀的开源项目\" class=\"headerlink\" title=\"五、优秀的开源项目\"></a>五、优秀的开源项目</h2><ol>\n<li>android开源项目汇总：<a href=\"https://github.com/kesenhoo/android-open-project\" target=\"_blank\" rel=\"external\">https://github.com/kesenhoo/android-open-project</a></li>\n<li>android开源项目解析：<a href=\"https://github.com/android-cn/android-open-project-analysis\" target=\"_blank\" rel=\"external\">https://github.com/android-cn/android-open-project-analysis</a></li>\n<li>强大的图片异步加载库Universal Image Loader：<a href=\"https://github.com/nostra13/Android-Universal-Image-Loader\" target=\"_blank\" rel=\"external\">https://github.com/nostra13/Android-Universal-Image-Loader</a></li>\n<li>好看的进度条实现：<a href=\"https://github.com/tangqi92/WaveLoadingView\" target=\"_blank\" rel=\"external\">https://github.com/tangqi92/WaveLoadingView</a></li>\n<li>Glide：<a href=\"https://github.com/bumptech/glide\" target=\"_blank\" rel=\"external\">https://github.com/bumptech/glide</a></li>\n<li>没有找不到的开源项目（开源项目集结地）：<a href=\"https://github.com/\" target=\"_blank\" rel=\"external\">https://github.com/</a></li>\n<li>开源app整理：<a href=\"http://www.jcodecraeer.com/plus/list.php?tid=31&amp;codecategory=22000\" target=\"_blank\" rel=\"external\">http://www.jcodecraeer.com/plus/list.php?tid=31&amp;codecategory=22000</a></li>\n</ol>\n<h2 id=\"六、学习建议\"><a href=\"#六、学习建议\" class=\"headerlink\" title=\"六、学习建议\"></a>六、学习建议</h2><ol>\n<li>尽量在google官方文档中找答案</li>\n<li>搜索引擎一定要使用google</li>\n<li>尽量去看一些英文的文档，帮助理解</li>\n<li>了解Android最基础的进程间通讯。知道AIDL如何使用, 也要知道如何手写Binder接口。这对你理解Android的Application和System services如何交互有非常重要的作用。</li>\n<li>学会使用UML语言交流</li>\n</ol>\n<h2 id=\"六、最佳实践\"><a href=\"#六、最佳实践\" class=\"headerlink\" title=\"六、最佳实践\"></a>六、最佳实践</h2><ol>\n<li>善用mmm编译项目</li>\n<li>了解工具的使用会让你的工作事半功倍</li>\n<li>了解21种设计模式</li>\n<li>分模块学习</li>\n</ol>\n<p>……</p>\n<blockquote>\n<p>（以后在学习过程中会不断完善这份资料，如果有好的建议，也希望大家能给出你的想法）</p>\n</blockquote>\n","excerpt":"","more":"<blockquote>\n<p>俗话说工欲善其事必先利其器，要想在android应用程序开发的道路上走的更长，更远，就需要不断的学习新的知识和思想，多看看官方提供的文档，在闲暇之余关注开源网站，开源项目，甚至贡献自己的代码，都会有很大的提升。有了得心应手的工具，会使得你的工作事半功倍。<br>同样，三人行，必有我师，学习的过程也是分享和交流的过程。所以，关注同领域技术大牛的博客，关注技术的动态，才能不被技术淘汰。因此，我将平时学习的时候积累下来的一些值得推荐的网站和经验推荐给大家，由于篇幅有限，没有展开说明。希望大家，通过查找，多多了解这些资源。其中有一部分的网站需要翻墙打开，做技术的，相信大家手里都备好了梯子。加油！</p>\n</blockquote>\n<h2 id=\"一、官方文档\"><a href=\"#一、官方文档\" class=\"headerlink\" title=\"一、官方文档\"></a>一、官方文档</h2><ol>\n<li>android源代码官方文档：<a href=\"https://source.android.com/source/index.html\">https://source.android.com/source/index.html</a></li>\n<li>android应用开发官方文档：<a href=\"http://developer.android.com/intl/zh-cn/index.html\">http://developer.android.com/intl/zh-cn/index.html</a></li>\n<li>android studio中文社区：<a href=\"http://www.android-studio.org/\">http://www.android-studio.org/</a></li>\n<li>gradle官方文档：<a href=\"https://docs.gradle.org/current/dsl/org.gradle.api.tasks.SourceSet.html\">https://docs.gradle.org/current/dsl/org.gradle.api.tasks.SourceSet.html</a></li>\n<li>andorid 设计中文翻译：<a href=\"http://adchs.github.io/get-started/create-vistion.html\">http://adchs.github.io/get-started/create-vistion.html</a></li>\n</ol>\n<h2 id=\"二、开源网站：\"><a href=\"#二、开源网站：\" class=\"headerlink\" title=\"二、开源网站：\"></a>二、开源网站：</h2><ol>\n<li>android开源镜像站：<a href=\"http://mirrors.neusoft.edu.cn/\">http://mirrors.neusoft.edu.cn/</a></li>\n<li>github：<a href=\"https://github.com/\">https://github.com/</a></li>\n<li>开源中国：<a href=\"http://www.oschina.net/\">http://www.oschina.net/</a></li>\n<li>第三方rom项目开源地址：<a href=\"https://wiki.cyanogenmod.org/w/Main_Page/zh-cn\">https://wiki.cyanogenmod.org/w/Main_Page/zh-cn</a></li>\n</ol>\n<h2 id=\"三、工具推荐\"><a href=\"#三、工具推荐\" class=\"headerlink\" title=\"三、工具推荐\"></a>三、工具推荐</h2><ol>\n<li>好用的模拟器：<a href=\"https://www.genymotion.com/\">https://www.genymotion.com/</a></li>\n<li>查看API网站：<a href=\"http://grepcode.com/\">http://grepcode.com/</a></li>\n<li>技术问题集结地：<a href=\"http://stackoverflow.com/\">http://stackoverflow.com/</a></li>\n</ol>\n<h2 id=\"四、大牛博客\"><a href=\"#四、大牛博客\" class=\"headerlink\" title=\"四、大牛博客\"></a>四、大牛博客</h2><ol>\n<li>CoderRobin：<a href=\"http://coderrobin.com/\">http://coderrobin.com/</a></li>\n<li>码农明明桑：<a href=\"http://blog.isming.me/\">http://blog.isming.me/</a></li>\n<li>stormzhang:<a href=\"http://stormzhang.com/posts.html\">http://stormzhang.com/posts.html</a></li>\n<li>Trinea:<a href=\"http://www.trinea.cn/\">http://www.trinea.cn/</a></li>\n<li>农民伯伯：<a href=\"http://www.cnblogs.com/over140/\">http://www.cnblogs.com/over140/</a></li>\n<li>胡凯：<a href=\"http://hukai.me/\">http://hukai.me/</a></li>\n<li>world hello :<a href=\"http://www.worldhello.net/\">http://www.worldhello.net/</a></li>\n<li>老罗的android之旅：<a href=\"http://blog.csdn.net/luoshengyang\">http://blog.csdn.net/luoshengyang</a></li>\n<li>阿拉神农的博客：<a href=\"http://blog.csdn.net/innost\">http://blog.csdn.net/innost</a></li>\n<li>Gracker：<a href=\"http://androidperformance.com/\">http://androidperformance.com/</a></li>\n</ol>\n<h2 id=\"五、优秀的开源项目\"><a href=\"#五、优秀的开源项目\" class=\"headerlink\" title=\"五、优秀的开源项目\"></a>五、优秀的开源项目</h2><ol>\n<li>android开源项目汇总：<a href=\"https://github.com/kesenhoo/android-open-project\">https://github.com/kesenhoo/android-open-project</a></li>\n<li>android开源项目解析：<a href=\"https://github.com/android-cn/android-open-project-analysis\">https://github.com/android-cn/android-open-project-analysis</a></li>\n<li>强大的图片异步加载库Universal Image Loader：<a href=\"https://github.com/nostra13/Android-Universal-Image-Loader\">https://github.com/nostra13/Android-Universal-Image-Loader</a></li>\n<li>好看的进度条实现：<a href=\"https://github.com/tangqi92/WaveLoadingView\">https://github.com/tangqi92/WaveLoadingView</a></li>\n<li>Glide：<a href=\"https://github.com/bumptech/glide\">https://github.com/bumptech/glide</a></li>\n<li>没有找不到的开源项目（开源项目集结地）：<a href=\"https://github.com/\">https://github.com/</a></li>\n<li>开源app整理：<a href=\"http://www.jcodecraeer.com/plus/list.php?tid=31&amp;codecategory=22000\">http://www.jcodecraeer.com/plus/list.php?tid=31&amp;codecategory=22000</a></li>\n</ol>\n<h2 id=\"六、学习建议\"><a href=\"#六、学习建议\" class=\"headerlink\" title=\"六、学习建议\"></a>六、学习建议</h2><ol>\n<li>尽量在google官方文档中找答案</li>\n<li>搜索引擎一定要使用google</li>\n<li>尽量去看一些英文的文档，帮助理解</li>\n<li>了解Android最基础的进程间通讯。知道AIDL如何使用, 也要知道如何手写Binder接口。这对你理解Android的Application和System services如何交互有非常重要的作用。</li>\n<li>学会使用UML语言交流</li>\n</ol>\n<h2 id=\"六、最佳实践\"><a href=\"#六、最佳实践\" class=\"headerlink\" title=\"六、最佳实践\"></a>六、最佳实践</h2><ol>\n<li>善用mmm编译项目</li>\n<li>了解工具的使用会让你的工作事半功倍</li>\n<li>了解21种设计模式</li>\n<li>分模块学习</li>\n</ol>\n<p>……</p>\n<blockquote>\n<p>（以后在学习过程中会不断完善这份资料，如果有好的建议，也希望大家能给出你的想法）</p>\n</blockquote>\n"},{"layout":"post","title":"Markdown使用总结","subtitle":"Markdown 是一种轻量级标记语言，它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档”","author":"JianGuo","header-img":"markdown-guide-1.jpg","date":"2016-07-12T11:48:29.000Z","_content":"\n\n## 什么是Markdown\nMarkdown 是一种[轻量级标记语言](https://zh.wikipedia.org/wiki/%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80)，创始人为[约翰·格鲁伯（John Gruber）](https://zh.wikipedia.org/wiki/%E7%B4%84%E7%BF%B0%C2%B7%E6%A0%BC%E9%AD%AF%E4%BC%AF)。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档”。[3]这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。  \n\nMarkdown同时还是一个由Gruber编写的Perl脚本：Markdown.pl。它把用markdown语法编写的内容转换成有效的、结构良好的XHTML或HTML内容，并将左尖括号('<')和&号替换成它们各自的字符实体引用。它可以用作单独的脚本，Blosxom和Movable Type的插件又或者BBEdit的文本过滤器。\n\n### Markdown的优点\n* 纯文本，所以兼容性极强，可以用所有文本编辑器打开。\n* 让你专注于文字而不是排版。\n* 格式转换方便，Markdown 的文本你可以轻松转换为 html、电子书等。\n* Markdown 的标记语法有极好的可读性。\n\n## linux下使用工具的推荐\n### Atom\n#### Atom的介绍\n[Atom](https://atom.io/) 是 Github 专门为程序员推出的一款开源的免费的多平台跨平台文本编辑器。同时，还拥有活跃的 [中文社区](https://atom-china.org/)。\n\n#### Atom的安装\n可以到官方网站https://atom.io/ 进行下载deb包，并安装即可。\n\n#### Atom的个性配置\n##### 命令面板\n当你按下 cmd-shift-P 并且当前焦点在一个窗格上的时候，命令面板就会弹出来。你可以使用命令面板完成\n大多数的命令。\n\n##### 偏好设置\n在设置界面中，你可以修改主题、修改文本折行的行为（wrapping）、字体大小、缩进宽度、滚动速度等选项。你也可以用这个界面安装新的插件和主题。你可以通过菜单栏中 Atom 下的 Preferences 菜单项打开设置界面。你也可以在命令面板中搜索 settings-view:open 或使用快捷键 cmd-,打开。\n###### 修改主题\n你可以在设置界面中修改 Atom 的主题，Atom 内建了 4 个不同的 UI 主题，分别是亮色和暗色版本的名为 Atom 和 One 的主题。以及 8 个不同的语法着色主题。你可以通过点击左边栏的 Themes 选项卡来改变当前主题，或安装新的主题。\n\n![](https://atom-china.org/uploads/default/_optimized/f67/38e/5fd8580ee2_690x479.png)  \n\nUI 主题会修改标签栏、左侧目录树（tree view）等 UI 元素的颜色；而语法着色主题修改编辑器中文字的语法高亮方案。你只需要简单地在下拉框中选择另一项，即可修改主题。\n\n在 Atom.io 上有很多种主题供你选择，下面会介绍如何安装主题。\n\n##### 插件的安装  \n###### 安装 markdown-scroll-sync\n不幸的是，atom虽然支持markdown格式的预览，但是却不能跟随滚动预览，我们可以通过安装插件实现相应的功能。安装步骤如下：\n  1. 主页面键入 Ctrl+Shift+P 后输入install packages and thmes\n  2. 搜索：“markdown-scroll-sync”\n  3. 点击安装  \n\n或者使用命令：\n```bash\n$ apm install\n```\n\n效果如下：  \n![](https://cloud.githubusercontent.com/assets/811455/11317259/c5b9b0c2-8fdc-11e5-8f85-b7deefb525c5.gif)\n\n\n###### 安装Markdown转pdf插件\n我们在使用Atom时，需要安装插件实现md文件转pdf的功能  \n安装过程同上，搜索“markdown-scroll-sync”\n\n安装命令：\n``` bash\napm install markdown-pdf\n```\n\n![](https://raw.githubusercontent.com/travs/markdown-pdf/master/assets/testpdf.png)  \n\n###### 安装目录自动生成插件：Markdown-toc\n在生成目录结构的时候显得非常有用。安装过程同上，搜索“Markdown-toc”或者使用命令安装：\n``` bash\napm install markdown-toc\n```\n\n###### 安装文件图标（可选）\n在文件名前添加文件类型相关的图标，以便于识别。详情请移步[https://atom.io/packages/file-icons](https://atom.io/packages/file-icons)  \n安装过程同上，搜索“apm install file-icons”  \n或者使用安装命令：\n```bash\napm install file-icons\n```\n\n###### 安装公式支持（可选）\nAtom的markdown预览同样不支持公式的渲染，需要安装对应的插件。\n安装：\n``` bash\napm install markdown-preview-plus\n```\n\n### cmd Markdown\n[cmd markdown](https://www.zybuluo.com/mdeditor)是作业部落出品的一款笔记编辑器，提供了网页，windows，linux，mac OS的软件。\n 主要优点是样式好看，功能非常强大，支持流程图，公式等。带有大纲功能！可以调转到你的各个章节很方便啊！但需要注册才能使用高级功能。同步功能一年要 99RMB。 =。= 故不推荐使用。  \n 客户端下载地址：[https://www.zybuluo.com/cmd/](https://www.zybuluo.com/cmd/)\n\n\n### FarboxApp\n[FarboxApp](https://www.farbox.com/service/app/desktop_editor)样式不错，功能强大。 下载本地客户端也可使用。\n\n### google chrome插件\n[马克飞象](www.maxiang.io)是针对印象笔记开发的markdown笔记插件，有网页版和chrome插件。\n同样需要注册，付费才能使用高级功能。\n\n\n## Markdown语法示例\n具体语法可参考：[http://wowubuntu.com/markdown/](http://wowubuntu.com/markdown/)\n\n### 标题\n 在 Markdown 中，你只需要在文本前面加上 # 即可完成标题，同理、你还可以增加二级标题、三级标题、四级标题、五级标题和六级标题，总共六级。如下：\n\n```html\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n```  \n效果预览：  \n\n----\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n----\n> 注：# 和「一级标题」之间建议保留一个字符的空格，这是最标准的 Markdown 写法。\n\n### 列表\n列表格式也很常用，在 Markdown 中，你只需要在文字前面加上 - 就可以了，例如：\n```html\n- 文本1\n- 文本2\n- 文本3\n```\n如果你希望有序列表，也可以在文字前面加上 1. 2. 3. 就可以了，例如：\n```html\n1. 文本1\n2. 文本2\n3. 文本3\n```\n> 注：-、1.和文本之间要保留一个字符的空格。\n\n### 链接和图片\n在 Markdown 中，插入链接不需要其他按钮，你只需要使用 \\[显示文本\\]\\(链接地址\\) 这样的语法即可，例如：\n```html\n[测试链接](http://www.test.com)\n```\n在 Markdown 中，插入图片不需要其他按钮，你只需要使用 \\!\\[\\]\\(图片链接地址\\) 这样的语法即可，例如：\n```html\n![图片介绍](http://ww4.sinaimg.cn/bmiddle/aa397b7fjw1dzplsgpdw5j.jpg)\n```\n> 注：插入图片的语法和链接的语法很像，只是前面多了一个 ！。  \n\n### 引用\n在我们写作的时候经常需要引用他人的文字，这个时候引用这个格式就很有必要了，在 Markdown 中，你只需要在你希望引用的文字前面加上 > 就好了\n\n### 强调\n语法：\n``` html\n~~删除线~~ <s>删除线（开启识别HTML标签时）</s>  \n*斜体字*      _斜体字_  \n**粗体**  __粗体__  \n***粗斜体*** ___粗斜体___  \n上标：X<sub>2</sub>  \n下标：O<sup>2</sup>\n```  \n效果：\n~~删除线~~ <s>删除线（开启识别HTML标签时）</s>  \n*斜体字*      _斜体字_  \n**粗体**  __粗体__  \n***粗斜体*** ___粗斜体___  \n上标：X<sub>2</sub>  \n下标：O<sup>2</sup>  \n\n\n效果如下：  \n *一盏灯*， 一片昏黄；**一本书**， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 **保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。**\n\n### 表格\n相关代码：\n\n```html\n| Tables        | Are           | Cool  |\n| ------------- |:-------------:| -----:|\n| col 3 is      | right-aligned | $1600 |\n| col 2 is      | centered      |   $12 |\n| zebra stripes | are neat      |    $1 |\n```\n显示效果：\n\n| Tables        | Are           | Cool  |\n| ------------- |:-------------:| -----:|\n| col 3 is      | right-aligned | $1600 |\n| col 2 is      | centered      |   $12 |\n| zebra stripes | are neat      |    $1 |\n\n\n### 引用代码\nmarkdown支持多种编程语言的代码引用。例如java 、c++等。\n\n格式：  \n> \\`\\`\\`+语言名称，如java  \n引用的代码  \n\\`\\`\\`  \n\n### 换行\n在文本中输入的换行会从最终生成的结果中删除，浏览器会根据可用空间自动换行。如果想强迫换行，可以在行尾插入至少两个空格。\n\n> Markdown的使用还是很简单的，总之一句话，孰能生巧，这些语法也没必要背，平时用的时候用模板写几次就记住了。\n","source":"_posts/Markdown_user_guide.md","raw":"---\nlayout: post\ntitle: Markdown使用总结\nsubtitle: Markdown 是一种轻量级标记语言，它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档”\nauthor: JianGuo\nheader-img: markdown-guide-1.jpg\ntags: Markdown\ndate: 2016-07-12 19:48:29\n---\n\n\n## 什么是Markdown\nMarkdown 是一种[轻量级标记语言](https://zh.wikipedia.org/wiki/%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80)，创始人为[约翰·格鲁伯（John Gruber）](https://zh.wikipedia.org/wiki/%E7%B4%84%E7%BF%B0%C2%B7%E6%A0%BC%E9%AD%AF%E4%BC%AF)。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档”。[3]这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。  \n\nMarkdown同时还是一个由Gruber编写的Perl脚本：Markdown.pl。它把用markdown语法编写的内容转换成有效的、结构良好的XHTML或HTML内容，并将左尖括号('<')和&号替换成它们各自的字符实体引用。它可以用作单独的脚本，Blosxom和Movable Type的插件又或者BBEdit的文本过滤器。\n\n### Markdown的优点\n* 纯文本，所以兼容性极强，可以用所有文本编辑器打开。\n* 让你专注于文字而不是排版。\n* 格式转换方便，Markdown 的文本你可以轻松转换为 html、电子书等。\n* Markdown 的标记语法有极好的可读性。\n\n## linux下使用工具的推荐\n### Atom\n#### Atom的介绍\n[Atom](https://atom.io/) 是 Github 专门为程序员推出的一款开源的免费的多平台跨平台文本编辑器。同时，还拥有活跃的 [中文社区](https://atom-china.org/)。\n\n#### Atom的安装\n可以到官方网站https://atom.io/ 进行下载deb包，并安装即可。\n\n#### Atom的个性配置\n##### 命令面板\n当你按下 cmd-shift-P 并且当前焦点在一个窗格上的时候，命令面板就会弹出来。你可以使用命令面板完成\n大多数的命令。\n\n##### 偏好设置\n在设置界面中，你可以修改主题、修改文本折行的行为（wrapping）、字体大小、缩进宽度、滚动速度等选项。你也可以用这个界面安装新的插件和主题。你可以通过菜单栏中 Atom 下的 Preferences 菜单项打开设置界面。你也可以在命令面板中搜索 settings-view:open 或使用快捷键 cmd-,打开。\n###### 修改主题\n你可以在设置界面中修改 Atom 的主题，Atom 内建了 4 个不同的 UI 主题，分别是亮色和暗色版本的名为 Atom 和 One 的主题。以及 8 个不同的语法着色主题。你可以通过点击左边栏的 Themes 选项卡来改变当前主题，或安装新的主题。\n\n![](https://atom-china.org/uploads/default/_optimized/f67/38e/5fd8580ee2_690x479.png)  \n\nUI 主题会修改标签栏、左侧目录树（tree view）等 UI 元素的颜色；而语法着色主题修改编辑器中文字的语法高亮方案。你只需要简单地在下拉框中选择另一项，即可修改主题。\n\n在 Atom.io 上有很多种主题供你选择，下面会介绍如何安装主题。\n\n##### 插件的安装  \n###### 安装 markdown-scroll-sync\n不幸的是，atom虽然支持markdown格式的预览，但是却不能跟随滚动预览，我们可以通过安装插件实现相应的功能。安装步骤如下：\n  1. 主页面键入 Ctrl+Shift+P 后输入install packages and thmes\n  2. 搜索：“markdown-scroll-sync”\n  3. 点击安装  \n\n或者使用命令：\n```bash\n$ apm install\n```\n\n效果如下：  \n![](https://cloud.githubusercontent.com/assets/811455/11317259/c5b9b0c2-8fdc-11e5-8f85-b7deefb525c5.gif)\n\n\n###### 安装Markdown转pdf插件\n我们在使用Atom时，需要安装插件实现md文件转pdf的功能  \n安装过程同上，搜索“markdown-scroll-sync”\n\n安装命令：\n``` bash\napm install markdown-pdf\n```\n\n![](https://raw.githubusercontent.com/travs/markdown-pdf/master/assets/testpdf.png)  \n\n###### 安装目录自动生成插件：Markdown-toc\n在生成目录结构的时候显得非常有用。安装过程同上，搜索“Markdown-toc”或者使用命令安装：\n``` bash\napm install markdown-toc\n```\n\n###### 安装文件图标（可选）\n在文件名前添加文件类型相关的图标，以便于识别。详情请移步[https://atom.io/packages/file-icons](https://atom.io/packages/file-icons)  \n安装过程同上，搜索“apm install file-icons”  \n或者使用安装命令：\n```bash\napm install file-icons\n```\n\n###### 安装公式支持（可选）\nAtom的markdown预览同样不支持公式的渲染，需要安装对应的插件。\n安装：\n``` bash\napm install markdown-preview-plus\n```\n\n### cmd Markdown\n[cmd markdown](https://www.zybuluo.com/mdeditor)是作业部落出品的一款笔记编辑器，提供了网页，windows，linux，mac OS的软件。\n 主要优点是样式好看，功能非常强大，支持流程图，公式等。带有大纲功能！可以调转到你的各个章节很方便啊！但需要注册才能使用高级功能。同步功能一年要 99RMB。 =。= 故不推荐使用。  \n 客户端下载地址：[https://www.zybuluo.com/cmd/](https://www.zybuluo.com/cmd/)\n\n\n### FarboxApp\n[FarboxApp](https://www.farbox.com/service/app/desktop_editor)样式不错，功能强大。 下载本地客户端也可使用。\n\n### google chrome插件\n[马克飞象](www.maxiang.io)是针对印象笔记开发的markdown笔记插件，有网页版和chrome插件。\n同样需要注册，付费才能使用高级功能。\n\n\n## Markdown语法示例\n具体语法可参考：[http://wowubuntu.com/markdown/](http://wowubuntu.com/markdown/)\n\n### 标题\n 在 Markdown 中，你只需要在文本前面加上 # 即可完成标题，同理、你还可以增加二级标题、三级标题、四级标题、五级标题和六级标题，总共六级。如下：\n\n```html\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n```  \n效果预览：  \n\n----\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n----\n> 注：# 和「一级标题」之间建议保留一个字符的空格，这是最标准的 Markdown 写法。\n\n### 列表\n列表格式也很常用，在 Markdown 中，你只需要在文字前面加上 - 就可以了，例如：\n```html\n- 文本1\n- 文本2\n- 文本3\n```\n如果你希望有序列表，也可以在文字前面加上 1. 2. 3. 就可以了，例如：\n```html\n1. 文本1\n2. 文本2\n3. 文本3\n```\n> 注：-、1.和文本之间要保留一个字符的空格。\n\n### 链接和图片\n在 Markdown 中，插入链接不需要其他按钮，你只需要使用 \\[显示文本\\]\\(链接地址\\) 这样的语法即可，例如：\n```html\n[测试链接](http://www.test.com)\n```\n在 Markdown 中，插入图片不需要其他按钮，你只需要使用 \\!\\[\\]\\(图片链接地址\\) 这样的语法即可，例如：\n```html\n![图片介绍](http://ww4.sinaimg.cn/bmiddle/aa397b7fjw1dzplsgpdw5j.jpg)\n```\n> 注：插入图片的语法和链接的语法很像，只是前面多了一个 ！。  \n\n### 引用\n在我们写作的时候经常需要引用他人的文字，这个时候引用这个格式就很有必要了，在 Markdown 中，你只需要在你希望引用的文字前面加上 > 就好了\n\n### 强调\n语法：\n``` html\n~~删除线~~ <s>删除线（开启识别HTML标签时）</s>  \n*斜体字*      _斜体字_  \n**粗体**  __粗体__  \n***粗斜体*** ___粗斜体___  \n上标：X<sub>2</sub>  \n下标：O<sup>2</sup>\n```  \n效果：\n~~删除线~~ <s>删除线（开启识别HTML标签时）</s>  \n*斜体字*      _斜体字_  \n**粗体**  __粗体__  \n***粗斜体*** ___粗斜体___  \n上标：X<sub>2</sub>  \n下标：O<sup>2</sup>  \n\n\n效果如下：  \n *一盏灯*， 一片昏黄；**一本书**， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 **保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。**\n\n### 表格\n相关代码：\n\n```html\n| Tables        | Are           | Cool  |\n| ------------- |:-------------:| -----:|\n| col 3 is      | right-aligned | $1600 |\n| col 2 is      | centered      |   $12 |\n| zebra stripes | are neat      |    $1 |\n```\n显示效果：\n\n| Tables        | Are           | Cool  |\n| ------------- |:-------------:| -----:|\n| col 3 is      | right-aligned | $1600 |\n| col 2 is      | centered      |   $12 |\n| zebra stripes | are neat      |    $1 |\n\n\n### 引用代码\nmarkdown支持多种编程语言的代码引用。例如java 、c++等。\n\n格式：  \n> \\`\\`\\`+语言名称，如java  \n引用的代码  \n\\`\\`\\`  \n\n### 换行\n在文本中输入的换行会从最终生成的结果中删除，浏览器会根据可用空间自动换行。如果想强迫换行，可以在行尾插入至少两个空格。\n\n> Markdown的使用还是很简单的，总之一句话，孰能生巧，这些语法也没必要背，平时用的时候用模板写几次就记住了。\n","slug":"Markdown_user_guide","published":1,"updated":"2016-07-28T12:15:26.868Z","comments":1,"photos":[],"link":"","_id":"cirdlcvc10007252n4a9b3izd","content":"<h2 id=\"什么是Markdown\"><a href=\"#什么是Markdown\" class=\"headerlink\" title=\"什么是Markdown\"></a>什么是Markdown</h2><p>Markdown 是一种<a href=\"https://zh.wikipedia.org/wiki/%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80\" target=\"_blank\" rel=\"external\">轻量级标记语言</a>，创始人为<a href=\"https://zh.wikipedia.org/wiki/%E7%B4%84%E7%BF%B0%C2%B7%E6%A0%BC%E9%AD%AF%E4%BC%AF\" target=\"_blank\" rel=\"external\">约翰·格鲁伯（John Gruber）</a>。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档”。[3]这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。  </p>\n<p>Markdown同时还是一个由Gruber编写的Perl脚本：Markdown.pl。它把用markdown语法编写的内容转换成有效的、结构良好的XHTML或HTML内容，并将左尖括号(‘&lt;’)和&amp;号替换成它们各自的字符实体引用。它可以用作单独的脚本，Blosxom和Movable Type的插件又或者BBEdit的文本过滤器。</p>\n<h3 id=\"Markdown的优点\"><a href=\"#Markdown的优点\" class=\"headerlink\" title=\"Markdown的优点\"></a>Markdown的优点</h3><ul>\n<li>纯文本，所以兼容性极强，可以用所有文本编辑器打开。</li>\n<li>让你专注于文字而不是排版。</li>\n<li>格式转换方便，Markdown 的文本你可以轻松转换为 html、电子书等。</li>\n<li>Markdown 的标记语法有极好的可读性。</li>\n</ul>\n<h2 id=\"linux下使用工具的推荐\"><a href=\"#linux下使用工具的推荐\" class=\"headerlink\" title=\"linux下使用工具的推荐\"></a>linux下使用工具的推荐</h2><h3 id=\"Atom\"><a href=\"#Atom\" class=\"headerlink\" title=\"Atom\"></a>Atom</h3><h4 id=\"Atom的介绍\"><a href=\"#Atom的介绍\" class=\"headerlink\" title=\"Atom的介绍\"></a>Atom的介绍</h4><p><a href=\"https://atom.io/\" target=\"_blank\" rel=\"external\">Atom</a> 是 Github 专门为程序员推出的一款开源的免费的多平台跨平台文本编辑器。同时，还拥有活跃的 <a href=\"https://atom-china.org/\" target=\"_blank\" rel=\"external\">中文社区</a>。</p>\n<h4 id=\"Atom的安装\"><a href=\"#Atom的安装\" class=\"headerlink\" title=\"Atom的安装\"></a>Atom的安装</h4><p>可以到官方网站<a href=\"https://atom.io/\" target=\"_blank\" rel=\"external\">https://atom.io/</a> 进行下载deb包，并安装即可。</p>\n<h4 id=\"Atom的个性配置\"><a href=\"#Atom的个性配置\" class=\"headerlink\" title=\"Atom的个性配置\"></a>Atom的个性配置</h4><h5 id=\"命令面板\"><a href=\"#命令面板\" class=\"headerlink\" title=\"命令面板\"></a>命令面板</h5><p>当你按下 cmd-shift-P 并且当前焦点在一个窗格上的时候，命令面板就会弹出来。你可以使用命令面板完成<br>大多数的命令。</p>\n<h5 id=\"偏好设置\"><a href=\"#偏好设置\" class=\"headerlink\" title=\"偏好设置\"></a>偏好设置</h5><p>在设置界面中，你可以修改主题、修改文本折行的行为（wrapping）、字体大小、缩进宽度、滚动速度等选项。你也可以用这个界面安装新的插件和主题。你可以通过菜单栏中 Atom 下的 Preferences 菜单项打开设置界面。你也可以在命令面板中搜索 settings-view:open 或使用快捷键 cmd-,打开。</p>\n<h6 id=\"修改主题\"><a href=\"#修改主题\" class=\"headerlink\" title=\"修改主题\"></a>修改主题</h6><p>你可以在设置界面中修改 Atom 的主题，Atom 内建了 4 个不同的 UI 主题，分别是亮色和暗色版本的名为 Atom 和 One 的主题。以及 8 个不同的语法着色主题。你可以通过点击左边栏的 Themes 选项卡来改变当前主题，或安装新的主题。</p>\n<p><img src=\"https://atom-china.org/uploads/default/_optimized/f67/38e/5fd8580ee2_690x479.png\" alt=\"\">  </p>\n<p>UI 主题会修改标签栏、左侧目录树（tree view）等 UI 元素的颜色；而语法着色主题修改编辑器中文字的语法高亮方案。你只需要简单地在下拉框中选择另一项，即可修改主题。</p>\n<p>在 Atom.io 上有很多种主题供你选择，下面会介绍如何安装主题。</p>\n<h5 id=\"插件的安装\"><a href=\"#插件的安装\" class=\"headerlink\" title=\"插件的安装\"></a>插件的安装</h5><h6 id=\"安装-markdown-scroll-sync\"><a href=\"#安装-markdown-scroll-sync\" class=\"headerlink\" title=\"安装 markdown-scroll-sync\"></a>安装 markdown-scroll-sync</h6><p>不幸的是，atom虽然支持markdown格式的预览，但是却不能跟随滚动预览，我们可以通过安装插件实现相应的功能。安装步骤如下：</p>\n<ol>\n<li>主页面键入 Ctrl+Shift+P 后输入install packages and thmes</li>\n<li>搜索：“markdown-scroll-sync”</li>\n<li>点击安装  </li>\n</ol>\n<p>或者使用命令：</p>\n<pre><code class=\"bash\">$ apm install\n</code></pre>\n<p>效果如下：<br><img src=\"https://cloud.githubusercontent.com/assets/811455/11317259/c5b9b0c2-8fdc-11e5-8f85-b7deefb525c5.gif\" alt=\"\"></p>\n<h6 id=\"安装Markdown转pdf插件\"><a href=\"#安装Markdown转pdf插件\" class=\"headerlink\" title=\"安装Markdown转pdf插件\"></a>安装Markdown转pdf插件</h6><p>我们在使用Atom时，需要安装插件实现md文件转pdf的功能<br>安装过程同上，搜索“markdown-scroll-sync”</p>\n<p>安装命令：</p>\n<pre><code class=\"bash\">apm install markdown-pdf\n</code></pre>\n<p><img src=\"https://raw.githubusercontent.com/travs/markdown-pdf/master/assets/testpdf.png\" alt=\"\">  </p>\n<h6 id=\"安装目录自动生成插件：Markdown-toc\"><a href=\"#安装目录自动生成插件：Markdown-toc\" class=\"headerlink\" title=\"安装目录自动生成插件：Markdown-toc\"></a>安装目录自动生成插件：Markdown-toc</h6><p>在生成目录结构的时候显得非常有用。安装过程同上，搜索“Markdown-toc”或者使用命令安装：</p>\n<pre><code class=\"bash\">apm install markdown-toc\n</code></pre>\n<h6 id=\"安装文件图标（可选）\"><a href=\"#安装文件图标（可选）\" class=\"headerlink\" title=\"安装文件图标（可选）\"></a>安装文件图标（可选）</h6><p>在文件名前添加文件类型相关的图标，以便于识别。详情请移步<a href=\"https://atom.io/packages/file-icons\" target=\"_blank\" rel=\"external\">https://atom.io/packages/file-icons</a><br>安装过程同上，搜索“apm install file-icons”<br>或者使用安装命令：</p>\n<pre><code class=\"bash\">apm install file-icons\n</code></pre>\n<h6 id=\"安装公式支持（可选）\"><a href=\"#安装公式支持（可选）\" class=\"headerlink\" title=\"安装公式支持（可选）\"></a>安装公式支持（可选）</h6><p>Atom的markdown预览同样不支持公式的渲染，需要安装对应的插件。<br>安装：</p>\n<pre><code class=\"bash\">apm install markdown-preview-plus\n</code></pre>\n<h3 id=\"cmd-Markdown\"><a href=\"#cmd-Markdown\" class=\"headerlink\" title=\"cmd Markdown\"></a>cmd Markdown</h3><p><a href=\"https://www.zybuluo.com/mdeditor\" target=\"_blank\" rel=\"external\">cmd markdown</a>是作业部落出品的一款笔记编辑器，提供了网页，windows，linux，mac OS的软件。<br> 主要优点是样式好看，功能非常强大，支持流程图，公式等。带有大纲功能！可以调转到你的各个章节很方便啊！但需要注册才能使用高级功能。同步功能一年要 99RMB。 =。= 故不推荐使用。<br> 客户端下载地址：<a href=\"https://www.zybuluo.com/cmd/\" target=\"_blank\" rel=\"external\">https://www.zybuluo.com/cmd/</a></p>\n<h3 id=\"FarboxApp\"><a href=\"#FarboxApp\" class=\"headerlink\" title=\"FarboxApp\"></a>FarboxApp</h3><p><a href=\"https://www.farbox.com/service/app/desktop_editor\" target=\"_blank\" rel=\"external\">FarboxApp</a>样式不错，功能强大。 下载本地客户端也可使用。</p>\n<h3 id=\"google-chrome插件\"><a href=\"#google-chrome插件\" class=\"headerlink\" title=\"google chrome插件\"></a>google chrome插件</h3><p><a href=\"www.maxiang.io\">马克飞象</a>是针对印象笔记开发的markdown笔记插件，有网页版和chrome插件。<br>同样需要注册，付费才能使用高级功能。</p>\n<h2 id=\"Markdown语法示例\"><a href=\"#Markdown语法示例\" class=\"headerlink\" title=\"Markdown语法示例\"></a>Markdown语法示例</h2><p>具体语法可参考：<a href=\"http://wowubuntu.com/markdown/\" target=\"_blank\" rel=\"external\">http://wowubuntu.com/markdown/</a></p>\n<h3 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h3><p> 在 Markdown 中，你只需要在文本前面加上 # 即可完成标题，同理、你还可以增加二级标题、三级标题、四级标题、五级标题和六级标题，总共六级。如下：</p>\n<pre><code class=\"html\"># 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n</code></pre>\n<p>效果预览：  </p>\n<hr>\n<h1 id=\"一级标题\"><a href=\"#一级标题\" class=\"headerlink\" title=\"一级标题\"></a>一级标题</h1><h2 id=\"二级标题\"><a href=\"#二级标题\" class=\"headerlink\" title=\"二级标题\"></a>二级标题</h2><h3 id=\"三级标题\"><a href=\"#三级标题\" class=\"headerlink\" title=\"三级标题\"></a>三级标题</h3><h4 id=\"四级标题\"><a href=\"#四级标题\" class=\"headerlink\" title=\"四级标题\"></a>四级标题</h4><h5 id=\"五级标题\"><a href=\"#五级标题\" class=\"headerlink\" title=\"五级标题\"></a>五级标题</h5><h6 id=\"六级标题\"><a href=\"#六级标题\" class=\"headerlink\" title=\"六级标题\"></a>六级标题</h6><hr>\n<blockquote>\n<p>注：# 和「一级标题」之间建议保留一个字符的空格，这是最标准的 Markdown 写法。</p>\n</blockquote>\n<h3 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h3><p>列表格式也很常用，在 Markdown 中，你只需要在文字前面加上 - 就可以了，例如：</p>\n<pre><code class=\"html\">- 文本1\n- 文本2\n- 文本3\n</code></pre>\n<p>如果你希望有序列表，也可以在文字前面加上 1. 2. 3. 就可以了，例如：</p>\n<pre><code class=\"html\">1. 文本1\n2. 文本2\n3. 文本3\n</code></pre>\n<blockquote>\n<p>注：-、1.和文本之间要保留一个字符的空格。</p>\n</blockquote>\n<h3 id=\"链接和图片\"><a href=\"#链接和图片\" class=\"headerlink\" title=\"链接和图片\"></a>链接和图片</h3><p>在 Markdown 中，插入链接不需要其他按钮，你只需要使用 [显示文本](链接地址) 这样的语法即可，例如：</p>\n<pre><code class=\"html\">[测试链接](http://www.test.com)\n</code></pre>\n<p>在 Markdown 中，插入图片不需要其他按钮，你只需要使用 ![](图片链接地址) 这样的语法即可，例如：</p>\n<pre><code class=\"html\">![图片介绍](http://ww4.sinaimg.cn/bmiddle/aa397b7fjw1dzplsgpdw5j.jpg)\n</code></pre>\n<blockquote>\n<p>注：插入图片的语法和链接的语法很像，只是前面多了一个 ！。  </p>\n</blockquote>\n<h3 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h3><p>在我们写作的时候经常需要引用他人的文字，这个时候引用这个格式就很有必要了，在 Markdown 中，你只需要在你希望引用的文字前面加上 &gt; 就好了</p>\n<h3 id=\"强调\"><a href=\"#强调\" class=\"headerlink\" title=\"强调\"></a>强调</h3><p>语法：</p>\n<pre><code class=\"html\">~~删除线~~ &lt;s&gt;删除线（开启识别HTML标签时）&lt;/s&gt;  \n*斜体字*      _斜体字_  \n**粗体**  __粗体__  \n***粗斜体*** ___粗斜体___  \n上标：X&lt;sub&gt;2&lt;/sub&gt;  \n下标：O&lt;sup&gt;2&lt;/sup&gt;\n</code></pre>\n<p>效果：<br><del>删除线</del> <s>删除线（开启识别HTML标签时）</s><br><em>斜体字</em>      <em>斜体字</em><br><strong>粗体</strong>  <strong>粗体</strong><br><strong><em>粗斜体</em></strong> <strong><em>粗斜体</em></strong><br>上标：X<sub>2</sub><br>下标：O<sup>2</sup>  </p>\n<p>效果如下：<br> <em>一盏灯</em>， 一片昏黄；<strong>一本书</strong>， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 <strong>保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。</strong></p>\n<h3 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h3><p>相关代码：</p>\n<pre><code class=\"html\">| Tables        | Are           | Cool  |\n| ------------- |:-------------:| -----:|\n| col 3 is      | right-aligned | $1600 |\n| col 2 is      | centered      |   $12 |\n| zebra stripes | are neat      |    $1 |\n</code></pre>\n<p>显示效果：</p>\n<table>\n<thead>\n<tr>\n<th>Tables</th>\n<th style=\"text-align:center\">Are</th>\n<th style=\"text-align:right\">Cool</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>col 3 is</td>\n<td style=\"text-align:center\">right-aligned</td>\n<td style=\"text-align:right\">$1600</td>\n</tr>\n<tr>\n<td>col 2 is</td>\n<td style=\"text-align:center\">centered</td>\n<td style=\"text-align:right\">$12</td>\n</tr>\n<tr>\n<td>zebra stripes</td>\n<td style=\"text-align:center\">are neat</td>\n<td style=\"text-align:right\">$1</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"引用代码\"><a href=\"#引用代码\" class=\"headerlink\" title=\"引用代码\"></a>引用代码</h3><p>markdown支持多种编程语言的代码引用。例如java 、c++等。</p>\n<p>格式：  </p>\n<blockquote>\n<p>```+语言名称，如java<br>引用的代码<br>```  </p>\n</blockquote>\n<h3 id=\"换行\"><a href=\"#换行\" class=\"headerlink\" title=\"换行\"></a>换行</h3><p>在文本中输入的换行会从最终生成的结果中删除，浏览器会根据可用空间自动换行。如果想强迫换行，可以在行尾插入至少两个空格。</p>\n<blockquote>\n<p>Markdown的使用还是很简单的，总之一句话，孰能生巧，这些语法也没必要背，平时用的时候用模板写几次就记住了。</p>\n</blockquote>\n","excerpt":"","more":"<h2 id=\"什么是Markdown\"><a href=\"#什么是Markdown\" class=\"headerlink\" title=\"什么是Markdown\"></a>什么是Markdown</h2><p>Markdown 是一种<a href=\"https://zh.wikipedia.org/wiki/%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80\">轻量级标记语言</a>，创始人为<a href=\"https://zh.wikipedia.org/wiki/%E7%B4%84%E7%BF%B0%C2%B7%E6%A0%BC%E9%AD%AF%E4%BC%AF\">约翰·格鲁伯（John Gruber）</a>。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档”。[3]这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。  </p>\n<p>Markdown同时还是一个由Gruber编写的Perl脚本：Markdown.pl。它把用markdown语法编写的内容转换成有效的、结构良好的XHTML或HTML内容，并将左尖括号(‘&lt;’)和&amp;号替换成它们各自的字符实体引用。它可以用作单独的脚本，Blosxom和Movable Type的插件又或者BBEdit的文本过滤器。</p>\n<h3 id=\"Markdown的优点\"><a href=\"#Markdown的优点\" class=\"headerlink\" title=\"Markdown的优点\"></a>Markdown的优点</h3><ul>\n<li>纯文本，所以兼容性极强，可以用所有文本编辑器打开。</li>\n<li>让你专注于文字而不是排版。</li>\n<li>格式转换方便，Markdown 的文本你可以轻松转换为 html、电子书等。</li>\n<li>Markdown 的标记语法有极好的可读性。</li>\n</ul>\n<h2 id=\"linux下使用工具的推荐\"><a href=\"#linux下使用工具的推荐\" class=\"headerlink\" title=\"linux下使用工具的推荐\"></a>linux下使用工具的推荐</h2><h3 id=\"Atom\"><a href=\"#Atom\" class=\"headerlink\" title=\"Atom\"></a>Atom</h3><h4 id=\"Atom的介绍\"><a href=\"#Atom的介绍\" class=\"headerlink\" title=\"Atom的介绍\"></a>Atom的介绍</h4><p><a href=\"https://atom.io/\">Atom</a> 是 Github 专门为程序员推出的一款开源的免费的多平台跨平台文本编辑器。同时，还拥有活跃的 <a href=\"https://atom-china.org/\">中文社区</a>。</p>\n<h4 id=\"Atom的安装\"><a href=\"#Atom的安装\" class=\"headerlink\" title=\"Atom的安装\"></a>Atom的安装</h4><p>可以到官方网站<a href=\"https://atom.io/\">https://atom.io/</a> 进行下载deb包，并安装即可。</p>\n<h4 id=\"Atom的个性配置\"><a href=\"#Atom的个性配置\" class=\"headerlink\" title=\"Atom的个性配置\"></a>Atom的个性配置</h4><h5 id=\"命令面板\"><a href=\"#命令面板\" class=\"headerlink\" title=\"命令面板\"></a>命令面板</h5><p>当你按下 cmd-shift-P 并且当前焦点在一个窗格上的时候，命令面板就会弹出来。你可以使用命令面板完成<br>大多数的命令。</p>\n<h5 id=\"偏好设置\"><a href=\"#偏好设置\" class=\"headerlink\" title=\"偏好设置\"></a>偏好设置</h5><p>在设置界面中，你可以修改主题、修改文本折行的行为（wrapping）、字体大小、缩进宽度、滚动速度等选项。你也可以用这个界面安装新的插件和主题。你可以通过菜单栏中 Atom 下的 Preferences 菜单项打开设置界面。你也可以在命令面板中搜索 settings-view:open 或使用快捷键 cmd-,打开。</p>\n<h6 id=\"修改主题\"><a href=\"#修改主题\" class=\"headerlink\" title=\"修改主题\"></a>修改主题</h6><p>你可以在设置界面中修改 Atom 的主题，Atom 内建了 4 个不同的 UI 主题，分别是亮色和暗色版本的名为 Atom 和 One 的主题。以及 8 个不同的语法着色主题。你可以通过点击左边栏的 Themes 选项卡来改变当前主题，或安装新的主题。</p>\n<p><img src=\"https://atom-china.org/uploads/default/_optimized/f67/38e/5fd8580ee2_690x479.png\" alt=\"\">  </p>\n<p>UI 主题会修改标签栏、左侧目录树（tree view）等 UI 元素的颜色；而语法着色主题修改编辑器中文字的语法高亮方案。你只需要简单地在下拉框中选择另一项，即可修改主题。</p>\n<p>在 Atom.io 上有很多种主题供你选择，下面会介绍如何安装主题。</p>\n<h5 id=\"插件的安装\"><a href=\"#插件的安装\" class=\"headerlink\" title=\"插件的安装\"></a>插件的安装</h5><h6 id=\"安装-markdown-scroll-sync\"><a href=\"#安装-markdown-scroll-sync\" class=\"headerlink\" title=\"安装 markdown-scroll-sync\"></a>安装 markdown-scroll-sync</h6><p>不幸的是，atom虽然支持markdown格式的预览，但是却不能跟随滚动预览，我们可以通过安装插件实现相应的功能。安装步骤如下：</p>\n<ol>\n<li>主页面键入 Ctrl+Shift+P 后输入install packages and thmes</li>\n<li>搜索：“markdown-scroll-sync”</li>\n<li>点击安装  </li>\n</ol>\n<p>或者使用命令：</p>\n<pre><code class=\"bash\">$ apm install\n</code></pre>\n<p>效果如下：<br><img src=\"https://cloud.githubusercontent.com/assets/811455/11317259/c5b9b0c2-8fdc-11e5-8f85-b7deefb525c5.gif\" alt=\"\"></p>\n<h6 id=\"安装Markdown转pdf插件\"><a href=\"#安装Markdown转pdf插件\" class=\"headerlink\" title=\"安装Markdown转pdf插件\"></a>安装Markdown转pdf插件</h6><p>我们在使用Atom时，需要安装插件实现md文件转pdf的功能<br>安装过程同上，搜索“markdown-scroll-sync”</p>\n<p>安装命令：</p>\n<pre><code class=\"bash\">apm install markdown-pdf\n</code></pre>\n<p><img src=\"https://raw.githubusercontent.com/travs/markdown-pdf/master/assets/testpdf.png\" alt=\"\">  </p>\n<h6 id=\"安装目录自动生成插件：Markdown-toc\"><a href=\"#安装目录自动生成插件：Markdown-toc\" class=\"headerlink\" title=\"安装目录自动生成插件：Markdown-toc\"></a>安装目录自动生成插件：Markdown-toc</h6><p>在生成目录结构的时候显得非常有用。安装过程同上，搜索“Markdown-toc”或者使用命令安装：</p>\n<pre><code class=\"bash\">apm install markdown-toc\n</code></pre>\n<h6 id=\"安装文件图标（可选）\"><a href=\"#安装文件图标（可选）\" class=\"headerlink\" title=\"安装文件图标（可选）\"></a>安装文件图标（可选）</h6><p>在文件名前添加文件类型相关的图标，以便于识别。详情请移步<a href=\"https://atom.io/packages/file-icons\">https://atom.io/packages/file-icons</a><br>安装过程同上，搜索“apm install file-icons”<br>或者使用安装命令：</p>\n<pre><code class=\"bash\">apm install file-icons\n</code></pre>\n<h6 id=\"安装公式支持（可选）\"><a href=\"#安装公式支持（可选）\" class=\"headerlink\" title=\"安装公式支持（可选）\"></a>安装公式支持（可选）</h6><p>Atom的markdown预览同样不支持公式的渲染，需要安装对应的插件。<br>安装：</p>\n<pre><code class=\"bash\">apm install markdown-preview-plus\n</code></pre>\n<h3 id=\"cmd-Markdown\"><a href=\"#cmd-Markdown\" class=\"headerlink\" title=\"cmd Markdown\"></a>cmd Markdown</h3><p><a href=\"https://www.zybuluo.com/mdeditor\">cmd markdown</a>是作业部落出品的一款笔记编辑器，提供了网页，windows，linux，mac OS的软件。<br> 主要优点是样式好看，功能非常强大，支持流程图，公式等。带有大纲功能！可以调转到你的各个章节很方便啊！但需要注册才能使用高级功能。同步功能一年要 99RMB。 =。= 故不推荐使用。<br> 客户端下载地址：<a href=\"https://www.zybuluo.com/cmd/\">https://www.zybuluo.com/cmd/</a></p>\n<h3 id=\"FarboxApp\"><a href=\"#FarboxApp\" class=\"headerlink\" title=\"FarboxApp\"></a>FarboxApp</h3><p><a href=\"https://www.farbox.com/service/app/desktop_editor\">FarboxApp</a>样式不错，功能强大。 下载本地客户端也可使用。</p>\n<h3 id=\"google-chrome插件\"><a href=\"#google-chrome插件\" class=\"headerlink\" title=\"google chrome插件\"></a>google chrome插件</h3><p><a href=\"www.maxiang.io\">马克飞象</a>是针对印象笔记开发的markdown笔记插件，有网页版和chrome插件。<br>同样需要注册，付费才能使用高级功能。</p>\n<h2 id=\"Markdown语法示例\"><a href=\"#Markdown语法示例\" class=\"headerlink\" title=\"Markdown语法示例\"></a>Markdown语法示例</h2><p>具体语法可参考：<a href=\"http://wowubuntu.com/markdown/\">http://wowubuntu.com/markdown/</a></p>\n<h3 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h3><p> 在 Markdown 中，你只需要在文本前面加上 # 即可完成标题，同理、你还可以增加二级标题、三级标题、四级标题、五级标题和六级标题，总共六级。如下：</p>\n<pre><code class=\"html\"># 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n</code></pre>\n<p>效果预览：  </p>\n<hr>\n<h1 id=\"一级标题\"><a href=\"#一级标题\" class=\"headerlink\" title=\"一级标题\"></a>一级标题</h1><h2 id=\"二级标题\"><a href=\"#二级标题\" class=\"headerlink\" title=\"二级标题\"></a>二级标题</h2><h3 id=\"三级标题\"><a href=\"#三级标题\" class=\"headerlink\" title=\"三级标题\"></a>三级标题</h3><h4 id=\"四级标题\"><a href=\"#四级标题\" class=\"headerlink\" title=\"四级标题\"></a>四级标题</h4><h5 id=\"五级标题\"><a href=\"#五级标题\" class=\"headerlink\" title=\"五级标题\"></a>五级标题</h5><h6 id=\"六级标题\"><a href=\"#六级标题\" class=\"headerlink\" title=\"六级标题\"></a>六级标题</h6><hr>\n<blockquote>\n<p>注：# 和「一级标题」之间建议保留一个字符的空格，这是最标准的 Markdown 写法。</p>\n</blockquote>\n<h3 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h3><p>列表格式也很常用，在 Markdown 中，你只需要在文字前面加上 - 就可以了，例如：</p>\n<pre><code class=\"html\">- 文本1\n- 文本2\n- 文本3\n</code></pre>\n<p>如果你希望有序列表，也可以在文字前面加上 1. 2. 3. 就可以了，例如：</p>\n<pre><code class=\"html\">1. 文本1\n2. 文本2\n3. 文本3\n</code></pre>\n<blockquote>\n<p>注：-、1.和文本之间要保留一个字符的空格。</p>\n</blockquote>\n<h3 id=\"链接和图片\"><a href=\"#链接和图片\" class=\"headerlink\" title=\"链接和图片\"></a>链接和图片</h3><p>在 Markdown 中，插入链接不需要其他按钮，你只需要使用 [显示文本](链接地址) 这样的语法即可，例如：</p>\n<pre><code class=\"html\">[测试链接](http://www.test.com)\n</code></pre>\n<p>在 Markdown 中，插入图片不需要其他按钮，你只需要使用 ![](图片链接地址) 这样的语法即可，例如：</p>\n<pre><code class=\"html\">![图片介绍](http://ww4.sinaimg.cn/bmiddle/aa397b7fjw1dzplsgpdw5j.jpg)\n</code></pre>\n<blockquote>\n<p>注：插入图片的语法和链接的语法很像，只是前面多了一个 ！。  </p>\n</blockquote>\n<h3 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h3><p>在我们写作的时候经常需要引用他人的文字，这个时候引用这个格式就很有必要了，在 Markdown 中，你只需要在你希望引用的文字前面加上 &gt; 就好了</p>\n<h3 id=\"强调\"><a href=\"#强调\" class=\"headerlink\" title=\"强调\"></a>强调</h3><p>语法：</p>\n<pre><code class=\"html\">~~删除线~~ &lt;s&gt;删除线（开启识别HTML标签时）&lt;/s&gt;  \n*斜体字*      _斜体字_  \n**粗体**  __粗体__  \n***粗斜体*** ___粗斜体___  \n上标：X&lt;sub&gt;2&lt;/sub&gt;  \n下标：O&lt;sup&gt;2&lt;/sup&gt;\n</code></pre>\n<p>效果：<br><del>删除线</del> <s>删除线（开启识别HTML标签时）</s><br><em>斜体字</em>      <em>斜体字</em><br><strong>粗体</strong>  <strong>粗体</strong><br><strong><em>粗斜体</em></strong> <strong><em>粗斜体</em></strong><br>上标：X<sub>2</sub><br>下标：O<sup>2</sup>  </p>\n<p>效果如下：<br> <em>一盏灯</em>， 一片昏黄；<strong>一本书</strong>， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 <strong>保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。</strong></p>\n<h3 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h3><p>相关代码：</p>\n<pre><code class=\"html\">| Tables        | Are           | Cool  |\n| ------------- |:-------------:| -----:|\n| col 3 is      | right-aligned | $1600 |\n| col 2 is      | centered      |   $12 |\n| zebra stripes | are neat      |    $1 |\n</code></pre>\n<p>显示效果：</p>\n<table>\n<thead>\n<tr>\n<th>Tables</th>\n<th style=\"text-align:center\">Are</th>\n<th style=\"text-align:right\">Cool</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>col 3 is</td>\n<td style=\"text-align:center\">right-aligned</td>\n<td style=\"text-align:right\">$1600</td>\n</tr>\n<tr>\n<td>col 2 is</td>\n<td style=\"text-align:center\">centered</td>\n<td style=\"text-align:right\">$12</td>\n</tr>\n<tr>\n<td>zebra stripes</td>\n<td style=\"text-align:center\">are neat</td>\n<td style=\"text-align:right\">$1</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"引用代码\"><a href=\"#引用代码\" class=\"headerlink\" title=\"引用代码\"></a>引用代码</h3><p>markdown支持多种编程语言的代码引用。例如java 、c++等。</p>\n<p>格式：  </p>\n<blockquote>\n<p>```+语言名称，如java<br>引用的代码<br>```  </p>\n</blockquote>\n<h3 id=\"换行\"><a href=\"#换行\" class=\"headerlink\" title=\"换行\"></a>换行</h3><p>在文本中输入的换行会从最终生成的结果中删除，浏览器会根据可用空间自动换行。如果想强迫换行，可以在行尾插入至少两个空格。</p>\n<blockquote>\n<p>Markdown的使用还是很简单的，总之一句话，孰能生巧，这些语法也没必要背，平时用的时候用模板写几次就记住了。</p>\n</blockquote>\n"},{"layout":"post","title":"纪念毕业一周年","subtitle":"To commemorate the first anniversary of graduation","author":"JianGuo","header-img":"graduation.jpg","date":"2016-07-14T19:28:29.000Z","_content":"\n> 前记：不知道为何，最近写东西不管长短，习惯性的喜欢加个前记，这篇文章也免为其难了。我很少写非技术的文章，每当提起笔想写点关于某件事的深刻感受时，总会觉得难以落笔，这大概也是“技术宅”的一种通病吧，或许也是因为懒得去写，给自己找个借口罢了。回想起那个高中的自己，老师布置一篇小说作文，硬是把一本作文本写完了还没有的了结的写作水平大概也就我人生的巅峰了。废话少说，今天终于下定决心要写点什么了，主要也是为了纪念毕业一周年。把这一年的经历和感悟捋一遍。给自己一个新的开始。\n\n### 毕业的离殇\n我想从页首的那张图说起。恩，很俗气的一张照片，大概每一个毕业生都经历过扔帽子的场景吧。当把压在头上的帽子抛向天空的时候，似乎在向世界宣告着独立。终于卸掉了一身铠甲，凯旋而归了。我很想知道一起经历四年同窗的你们当时的感受。那些曾经朝夕相处了四年的老同学，老朋友你们还好吗？\n@脑残，@小訾，@二哥，@叶玲，@凤姐，@小彦，@所有人，好久不见，也很少联系，但是我的回忆里还有你们的身影。\n![聚餐](jucan.JPG)\n\n在大学最幸运的事莫过于三件。\n\n一是认识了一帮逗逼哥们@华仔，@骚明，@老仲，@攀仔，@华超，我们哭过，闹过，一起醉过，一起疯过，一起去旅行过，一起为了期末的考试写过小纸条，一起经历过太多太多让人怀念的事儿...\n![旅行似乎从来没有凑齐过](qiqihaer.jpg)\n\n即便是现在我们经常有事没事微信上开个小视频“会议”，彼此调侃一番，问问都过得怎么样，每个人都为自己的理想努力着，这就够了；\n\n\n二是学了自己想学的东西，遇到了志同道合的@超哥，@志哥，@嘉伟，一起度过了不少闲暇的写代码时光，好让自己觉得没有白白浪费大学的美好时光；\n![曾经呆的时间最长的地方](shiyanshi.jpg)\n\n\n三是遇到了那个陪我度过大半个大学时光的她。虽然因为种种原因，没有走在一起，但是，那段时光会一直珍藏在心中。谈到大学的时光，每个人的回忆里都会有那么一段终身难忘的经历，我也一样。不管结果如何，感谢能在青春年华里给我那么一段难忘而又美好的记忆。\n\n\n回想起毕业的最后的那段时光，想想当时的自己，那段日子也许是我人生中最痛彻心扉的一段时光了。有太多的遗憾留在了校园。那几个烂醉痛哭的夜晚还是历历在目，已然记不清当初说过什么煽情的话语了，只记得嘶声裂肺的痛哭。\n\n\n很多人都羡慕我能找到自己喜欢的工作，其实，我并不是不喜欢化学，高中的时候，痴迷于化学。那一切都像是现在对于计算机的迷恋一样的让人沉醉。我毫不犹豫的选了高分子化学的专业。可后来，我被现实的教育体制打败了。那种激情慢慢被消磨下去。再到后来，我开始疯狂的迷恋上了编程。这可能和我的性格有关。我喜欢有挑战的事物，喜欢每个想干的事儿完成后的欣喜和满足感。这激励着我，一直没停的追逐着自己喜欢的东西。\n\n\n### “北京不仅是一座城”\n\n![北京的夜景](beijing.jpg)\n\n去年的今天，我来到了北京，这个让无数人向往而敬畏的地方。想想当时的自己，毫无畏惧，从来没有想过在北京怎么生活，也没有为自己的将来考虑得太深。有幸的是，现在的公司给了我一个学化学的人拥抱自己热爱的事儿的机会，我想这大概就是“青春不老的秘诀是和热爱的事儿待在一起”的意义吧。\n\n最近在看一本书：《何必等来生》。美得让人窒息的句子背后，我想燕子也曾经历过像我现在这样的感悟。来北京整整一年了，这里让我体会最深的就是在这个城市里每个人都在为生活拼搏的那种顽强的生命力。“北京给我们梦境和风雨，也孕育着友谊和爱情”，没人不因为高昂的房价而感到压抑也绝望，同时，在这个城市里，每个人充满斗志，似乎北京就是整个世界。\n\n很喜欢燕子的这段话：\n> 如果你愿意去北京的火车站蹲守，你会看见无数年轻又热血的生命，背着沉重的行李刚刚抵达，他们大口呼吸，攥紧拳头，充满斗志，觉得北京就是全世界，全世界最值得付出年华的地方就是北京。北京长满了最好看的梦想之花，那花儿曲曲折折也密密麻麻地开在川流不息的城市中的每一个犄角旮旯。那些迷幻的花朵，在每个毕业季的夏末秋初，变成天使一样的人形，向那些心里存着微光的人们漏出最复杂的笑容。轻轻的说，来吧，北京。\n\n这一年里，从刚来北京的员工宿舍的群居生活，到开始追求生活，一个人在北三环租了2500一个月房租的卧室过上自己所谓的“小资生活”。从一个职场新人到被更多的人认可。从一个轻浮的脾气有点倔的愤青还是变得有点成熟。这中间又有多少悲欢离合的故事。\n\n刚来北京的时候，我认识了现在的同事，@太白金星，@雷总，@涛涛，@小红，@小马哥，@隔壁老王，一起住了大半年的群居生活，似乎给人一种错觉，是不是还没有毕业？每天下班，回来扯上几句，总是让人觉得酣畅淋漓，高兴的不高兴的全抛到脑后了。大家都是非常拼命的工作。每天跑跑步，打打球，热热闹闹的吃火锅，看电影，这样的日子总会让人觉得很充实。后来大家各自租房了，就很少有机会见面了。\n\n在员工宿舍住的那段日子，有时候，下班很晚，一个人走在下班的路上，空旷的道路上漆黑一片，偶尔会有一辆汽车从你身边飞驰而过，打破那片平静。我时常在这样的环境下会听一些舒缓的歌，慢慢悠悠的走着，仿佛整个世界都变慢了。每天拖着疲倦的身躯回家的时候，总会有那么一丝的忧伤和孤单。好几次听汪峰的歌差点流泪了。抬头看看天空，小时候看到的满天银河却变成了笼罩在城市上空的乌烟瘴气般的死寂。\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=210 src=\"http://music.163.com/outchain/player?type=0&id=422143332&auto=0&height=430\"></iframe>\n（遗憾的是最喜欢的《北京，北京》由于版权限制，不能在我的博客里播放了）\n> 《北京北京》\n>\n> 当我走在这里的每一条街道\n> 我的心似乎从来都不能平静\n> 除了发动机的轰鸣和电气之音\n> 我似乎听到了他烛骨般的心跳\n> 我在这里欢笑我在这里哭泣\n> 我在这里活着也在这死去\n> 我在这里祈祷 我在这里迷惘\n> 我在这里寻找 在这里失去\n> 北京 北京\n> ……\n\n再到后来，我一个人在北京北三环最繁华的地方租了不到15平米的小卧室，心里想，贵就贵点儿吧，只要不让自己孤单，能给自己舒适的环境就好。每天一个人蜗居在这小房子里，无时无刻体会着蜗居的意义。\n\n都说年轻的时候喜欢群体生活，我就是一个离不开群体的人。总是渴望着身边有那么几个形影不离的朋友，每天陪你奋斗，陪你聊天，陪你开心，陪你忧伤。但是，谁有何尝没有自己的事呢？我们总是忙于工作，却忽略了生活的意义。\n\n我喜欢摄影，总想着有空能拍拍属于北京的风景，去三里屯拍姑娘，去郊区野营拍星空，早起爬山拍日出，在景山公园的山顶拍落日……可到现在，我一样也没有拍过。有时候在想，我真的还喜欢着摄影吗？难道只是拍几张好看点的图片给人显摆显摆？不是，我理解它的意义不在于让别人了解你拍摄的东西。而在于自己欣赏你眼前的美景。这些看似很容易做到的事情，却成了奢望。\n\n在北京也当过几次东道主，忽悠最想见的朋友来北京，那种亲切感，很难用言语表达。每次的相逢的喜悦和离别的伤感都会让人觉得北京这个城市带给我们的东西。\n\n北京不仅是一座城，它承载了我太多的梦想，汗水，友谊，还有感情。\n\n### “青春不老的秘诀是和热爱的事儿待在一起”\n\n说起青春，我估计我的青春也所剩无几了，都已经被拉入晚婚晚育人群了。但是我的青春仍然未老，我仍为我喜欢的工作开启着百分百的热情，我深知我热爱这份工作。几遍每天付出几乎所有的时间，从来没有觉得疲倦过。这样的状态不知道还能持续多久，我想，我该为我自己的职业发展好好想想了。\n\n有时候，我发现自己是一个只有想法，很难付诸行动的人。似乎少了一些动力，将我的想法实现。比如说，想开发的apk很多，有些自认为还是很有商业价值，但是，总是没有坚持下去把它开发出来。到了现在工作了，就没有时间做这些事了\n\n### 谁说我没有资格拥有梦想\n待续。。。\n\n### 谈谈自己的规划\n\n没想到写了很多，还是个烂尾的文章，本来打算写完的，但是半夜三点了，再写的话，明天的工作没法做了，所以还是要收个尾，等以后有空的时候，静下心好好给自己规划下未来，也写在这儿，让我的朋友们鞭策我，共同监督我。\n\n> 写于16年7月15日\n> 纪念工作一周年\n","source":"_posts/To_Commemorate_The_First_Anniversary_Of_Graduation.md","raw":"---\nlayout: post\ntitle: 纪念毕业一周年\nsubtitle: To commemorate the first anniversary of graduation\nauthor: JianGuo\nheader-img: graduation.jpg\ntags: 感悟\ndate: 2016-07-15 03:28:29\n---\n\n> 前记：不知道为何，最近写东西不管长短，习惯性的喜欢加个前记，这篇文章也免为其难了。我很少写非技术的文章，每当提起笔想写点关于某件事的深刻感受时，总会觉得难以落笔，这大概也是“技术宅”的一种通病吧，或许也是因为懒得去写，给自己找个借口罢了。回想起那个高中的自己，老师布置一篇小说作文，硬是把一本作文本写完了还没有的了结的写作水平大概也就我人生的巅峰了。废话少说，今天终于下定决心要写点什么了，主要也是为了纪念毕业一周年。把这一年的经历和感悟捋一遍。给自己一个新的开始。\n\n### 毕业的离殇\n我想从页首的那张图说起。恩，很俗气的一张照片，大概每一个毕业生都经历过扔帽子的场景吧。当把压在头上的帽子抛向天空的时候，似乎在向世界宣告着独立。终于卸掉了一身铠甲，凯旋而归了。我很想知道一起经历四年同窗的你们当时的感受。那些曾经朝夕相处了四年的老同学，老朋友你们还好吗？\n@脑残，@小訾，@二哥，@叶玲，@凤姐，@小彦，@所有人，好久不见，也很少联系，但是我的回忆里还有你们的身影。\n![聚餐](jucan.JPG)\n\n在大学最幸运的事莫过于三件。\n\n一是认识了一帮逗逼哥们@华仔，@骚明，@老仲，@攀仔，@华超，我们哭过，闹过，一起醉过，一起疯过，一起去旅行过，一起为了期末的考试写过小纸条，一起经历过太多太多让人怀念的事儿...\n![旅行似乎从来没有凑齐过](qiqihaer.jpg)\n\n即便是现在我们经常有事没事微信上开个小视频“会议”，彼此调侃一番，问问都过得怎么样，每个人都为自己的理想努力着，这就够了；\n\n\n二是学了自己想学的东西，遇到了志同道合的@超哥，@志哥，@嘉伟，一起度过了不少闲暇的写代码时光，好让自己觉得没有白白浪费大学的美好时光；\n![曾经呆的时间最长的地方](shiyanshi.jpg)\n\n\n三是遇到了那个陪我度过大半个大学时光的她。虽然因为种种原因，没有走在一起，但是，那段时光会一直珍藏在心中。谈到大学的时光，每个人的回忆里都会有那么一段终身难忘的经历，我也一样。不管结果如何，感谢能在青春年华里给我那么一段难忘而又美好的记忆。\n\n\n回想起毕业的最后的那段时光，想想当时的自己，那段日子也许是我人生中最痛彻心扉的一段时光了。有太多的遗憾留在了校园。那几个烂醉痛哭的夜晚还是历历在目，已然记不清当初说过什么煽情的话语了，只记得嘶声裂肺的痛哭。\n\n\n很多人都羡慕我能找到自己喜欢的工作，其实，我并不是不喜欢化学，高中的时候，痴迷于化学。那一切都像是现在对于计算机的迷恋一样的让人沉醉。我毫不犹豫的选了高分子化学的专业。可后来，我被现实的教育体制打败了。那种激情慢慢被消磨下去。再到后来，我开始疯狂的迷恋上了编程。这可能和我的性格有关。我喜欢有挑战的事物，喜欢每个想干的事儿完成后的欣喜和满足感。这激励着我，一直没停的追逐着自己喜欢的东西。\n\n\n### “北京不仅是一座城”\n\n![北京的夜景](beijing.jpg)\n\n去年的今天，我来到了北京，这个让无数人向往而敬畏的地方。想想当时的自己，毫无畏惧，从来没有想过在北京怎么生活，也没有为自己的将来考虑得太深。有幸的是，现在的公司给了我一个学化学的人拥抱自己热爱的事儿的机会，我想这大概就是“青春不老的秘诀是和热爱的事儿待在一起”的意义吧。\n\n最近在看一本书：《何必等来生》。美得让人窒息的句子背后，我想燕子也曾经历过像我现在这样的感悟。来北京整整一年了，这里让我体会最深的就是在这个城市里每个人都在为生活拼搏的那种顽强的生命力。“北京给我们梦境和风雨，也孕育着友谊和爱情”，没人不因为高昂的房价而感到压抑也绝望，同时，在这个城市里，每个人充满斗志，似乎北京就是整个世界。\n\n很喜欢燕子的这段话：\n> 如果你愿意去北京的火车站蹲守，你会看见无数年轻又热血的生命，背着沉重的行李刚刚抵达，他们大口呼吸，攥紧拳头，充满斗志，觉得北京就是全世界，全世界最值得付出年华的地方就是北京。北京长满了最好看的梦想之花，那花儿曲曲折折也密密麻麻地开在川流不息的城市中的每一个犄角旮旯。那些迷幻的花朵，在每个毕业季的夏末秋初，变成天使一样的人形，向那些心里存着微光的人们漏出最复杂的笑容。轻轻的说，来吧，北京。\n\n这一年里，从刚来北京的员工宿舍的群居生活，到开始追求生活，一个人在北三环租了2500一个月房租的卧室过上自己所谓的“小资生活”。从一个职场新人到被更多的人认可。从一个轻浮的脾气有点倔的愤青还是变得有点成熟。这中间又有多少悲欢离合的故事。\n\n刚来北京的时候，我认识了现在的同事，@太白金星，@雷总，@涛涛，@小红，@小马哥，@隔壁老王，一起住了大半年的群居生活，似乎给人一种错觉，是不是还没有毕业？每天下班，回来扯上几句，总是让人觉得酣畅淋漓，高兴的不高兴的全抛到脑后了。大家都是非常拼命的工作。每天跑跑步，打打球，热热闹闹的吃火锅，看电影，这样的日子总会让人觉得很充实。后来大家各自租房了，就很少有机会见面了。\n\n在员工宿舍住的那段日子，有时候，下班很晚，一个人走在下班的路上，空旷的道路上漆黑一片，偶尔会有一辆汽车从你身边飞驰而过，打破那片平静。我时常在这样的环境下会听一些舒缓的歌，慢慢悠悠的走着，仿佛整个世界都变慢了。每天拖着疲倦的身躯回家的时候，总会有那么一丝的忧伤和孤单。好几次听汪峰的歌差点流泪了。抬头看看天空，小时候看到的满天银河却变成了笼罩在城市上空的乌烟瘴气般的死寂。\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=210 src=\"http://music.163.com/outchain/player?type=0&id=422143332&auto=0&height=430\"></iframe>\n（遗憾的是最喜欢的《北京，北京》由于版权限制，不能在我的博客里播放了）\n> 《北京北京》\n>\n> 当我走在这里的每一条街道\n> 我的心似乎从来都不能平静\n> 除了发动机的轰鸣和电气之音\n> 我似乎听到了他烛骨般的心跳\n> 我在这里欢笑我在这里哭泣\n> 我在这里活着也在这死去\n> 我在这里祈祷 我在这里迷惘\n> 我在这里寻找 在这里失去\n> 北京 北京\n> ……\n\n再到后来，我一个人在北京北三环最繁华的地方租了不到15平米的小卧室，心里想，贵就贵点儿吧，只要不让自己孤单，能给自己舒适的环境就好。每天一个人蜗居在这小房子里，无时无刻体会着蜗居的意义。\n\n都说年轻的时候喜欢群体生活，我就是一个离不开群体的人。总是渴望着身边有那么几个形影不离的朋友，每天陪你奋斗，陪你聊天，陪你开心，陪你忧伤。但是，谁有何尝没有自己的事呢？我们总是忙于工作，却忽略了生活的意义。\n\n我喜欢摄影，总想着有空能拍拍属于北京的风景，去三里屯拍姑娘，去郊区野营拍星空，早起爬山拍日出，在景山公园的山顶拍落日……可到现在，我一样也没有拍过。有时候在想，我真的还喜欢着摄影吗？难道只是拍几张好看点的图片给人显摆显摆？不是，我理解它的意义不在于让别人了解你拍摄的东西。而在于自己欣赏你眼前的美景。这些看似很容易做到的事情，却成了奢望。\n\n在北京也当过几次东道主，忽悠最想见的朋友来北京，那种亲切感，很难用言语表达。每次的相逢的喜悦和离别的伤感都会让人觉得北京这个城市带给我们的东西。\n\n北京不仅是一座城，它承载了我太多的梦想，汗水，友谊，还有感情。\n\n### “青春不老的秘诀是和热爱的事儿待在一起”\n\n说起青春，我估计我的青春也所剩无几了，都已经被拉入晚婚晚育人群了。但是我的青春仍然未老，我仍为我喜欢的工作开启着百分百的热情，我深知我热爱这份工作。几遍每天付出几乎所有的时间，从来没有觉得疲倦过。这样的状态不知道还能持续多久，我想，我该为我自己的职业发展好好想想了。\n\n有时候，我发现自己是一个只有想法，很难付诸行动的人。似乎少了一些动力，将我的想法实现。比如说，想开发的apk很多，有些自认为还是很有商业价值，但是，总是没有坚持下去把它开发出来。到了现在工作了，就没有时间做这些事了\n\n### 谁说我没有资格拥有梦想\n待续。。。\n\n### 谈谈自己的规划\n\n没想到写了很多，还是个烂尾的文章，本来打算写完的，但是半夜三点了，再写的话，明天的工作没法做了，所以还是要收个尾，等以后有空的时候，静下心好好给自己规划下未来，也写在这儿，让我的朋友们鞭策我，共同监督我。\n\n> 写于16年7月15日\n> 纪念工作一周年\n","slug":"To_Commemorate_The_First_Anniversary_Of_Graduation","published":1,"updated":"2016-07-28T12:15:26.880Z","comments":1,"photos":[],"link":"","_id":"cirdlcvc20009252nwtdi7q5g","content":"<blockquote>\n<p>前记：不知道为何，最近写东西不管长短，习惯性的喜欢加个前记，这篇文章也免为其难了。我很少写非技术的文章，每当提起笔想写点关于某件事的深刻感受时，总会觉得难以落笔，这大概也是“技术宅”的一种通病吧，或许也是因为懒得去写，给自己找个借口罢了。回想起那个高中的自己，老师布置一篇小说作文，硬是把一本作文本写完了还没有的了结的写作水平大概也就我人生的巅峰了。废话少说，今天终于下定决心要写点什么了，主要也是为了纪念毕业一周年。把这一年的经历和感悟捋一遍。给自己一个新的开始。</p>\n</blockquote>\n<h3 id=\"毕业的离殇\"><a href=\"#毕业的离殇\" class=\"headerlink\" title=\"毕业的离殇\"></a>毕业的离殇</h3><p>我想从页首的那张图说起。恩，很俗气的一张照片，大概每一个毕业生都经历过扔帽子的场景吧。当把压在头上的帽子抛向天空的时候，似乎在向世界宣告着独立。终于卸掉了一身铠甲，凯旋而归了。我很想知道一起经历四年同窗的你们当时的感受。那些曾经朝夕相处了四年的老同学，老朋友你们还好吗？<br>@脑残，@小訾，@二哥，@叶玲，@凤姐，@小彦，@所有人，好久不见，也很少联系，但是我的回忆里还有你们的身影。<br><img src=\"jucan.JPG\" alt=\"聚餐\"></p>\n<p>在大学最幸运的事莫过于三件。</p>\n<p>一是认识了一帮逗逼哥们@华仔，@骚明，@老仲，@攀仔，@华超，我们哭过，闹过，一起醉过，一起疯过，一起去旅行过，一起为了期末的考试写过小纸条，一起经历过太多太多让人怀念的事儿…<br><img src=\"qiqihaer.jpg\" alt=\"旅行似乎从来没有凑齐过\"></p>\n<p>即便是现在我们经常有事没事微信上开个小视频“会议”，彼此调侃一番，问问都过得怎么样，每个人都为自己的理想努力着，这就够了；</p>\n<p>二是学了自己想学的东西，遇到了志同道合的@超哥，@志哥，@嘉伟，一起度过了不少闲暇的写代码时光，好让自己觉得没有白白浪费大学的美好时光；<br><img src=\"shiyanshi.jpg\" alt=\"曾经呆的时间最长的地方\"></p>\n<p>三是遇到了那个陪我度过大半个大学时光的她。虽然因为种种原因，没有走在一起，但是，那段时光会一直珍藏在心中。谈到大学的时光，每个人的回忆里都会有那么一段终身难忘的经历，我也一样。不管结果如何，感谢能在青春年华里给我那么一段难忘而又美好的记忆。</p>\n<p>回想起毕业的最后的那段时光，想想当时的自己，那段日子也许是我人生中最痛彻心扉的一段时光了。有太多的遗憾留在了校园。那几个烂醉痛哭的夜晚还是历历在目，已然记不清当初说过什么煽情的话语了，只记得嘶声裂肺的痛哭。</p>\n<p>很多人都羡慕我能找到自己喜欢的工作，其实，我并不是不喜欢化学，高中的时候，痴迷于化学。那一切都像是现在对于计算机的迷恋一样的让人沉醉。我毫不犹豫的选了高分子化学的专业。可后来，我被现实的教育体制打败了。那种激情慢慢被消磨下去。再到后来，我开始疯狂的迷恋上了编程。这可能和我的性格有关。我喜欢有挑战的事物，喜欢每个想干的事儿完成后的欣喜和满足感。这激励着我，一直没停的追逐着自己喜欢的东西。</p>\n<h3 id=\"“北京不仅是一座城”\"><a href=\"#“北京不仅是一座城”\" class=\"headerlink\" title=\"“北京不仅是一座城”\"></a>“北京不仅是一座城”</h3><p><img src=\"beijing.jpg\" alt=\"北京的夜景\"></p>\n<p>去年的今天，我来到了北京，这个让无数人向往而敬畏的地方。想想当时的自己，毫无畏惧，从来没有想过在北京怎么生活，也没有为自己的将来考虑得太深。有幸的是，现在的公司给了我一个学化学的人拥抱自己热爱的事儿的机会，我想这大概就是“青春不老的秘诀是和热爱的事儿待在一起”的意义吧。</p>\n<p>最近在看一本书：《何必等来生》。美得让人窒息的句子背后，我想燕子也曾经历过像我现在这样的感悟。来北京整整一年了，这里让我体会最深的就是在这个城市里每个人都在为生活拼搏的那种顽强的生命力。“北京给我们梦境和风雨，也孕育着友谊和爱情”，没人不因为高昂的房价而感到压抑也绝望，同时，在这个城市里，每个人充满斗志，似乎北京就是整个世界。</p>\n<p>很喜欢燕子的这段话：</p>\n<blockquote>\n<p>如果你愿意去北京的火车站蹲守，你会看见无数年轻又热血的生命，背着沉重的行李刚刚抵达，他们大口呼吸，攥紧拳头，充满斗志，觉得北京就是全世界，全世界最值得付出年华的地方就是北京。北京长满了最好看的梦想之花，那花儿曲曲折折也密密麻麻地开在川流不息的城市中的每一个犄角旮旯。那些迷幻的花朵，在每个毕业季的夏末秋初，变成天使一样的人形，向那些心里存着微光的人们漏出最复杂的笑容。轻轻的说，来吧，北京。</p>\n</blockquote>\n<p>这一年里，从刚来北京的员工宿舍的群居生活，到开始追求生活，一个人在北三环租了2500一个月房租的卧室过上自己所谓的“小资生活”。从一个职场新人到被更多的人认可。从一个轻浮的脾气有点倔的愤青还是变得有点成熟。这中间又有多少悲欢离合的故事。</p>\n<p>刚来北京的时候，我认识了现在的同事，@太白金星，@雷总，@涛涛，@小红，@小马哥，@隔壁老王，一起住了大半年的群居生活，似乎给人一种错觉，是不是还没有毕业？每天下班，回来扯上几句，总是让人觉得酣畅淋漓，高兴的不高兴的全抛到脑后了。大家都是非常拼命的工作。每天跑跑步，打打球，热热闹闹的吃火锅，看电影，这样的日子总会让人觉得很充实。后来大家各自租房了，就很少有机会见面了。</p>\n<p>在员工宿舍住的那段日子，有时候，下班很晚，一个人走在下班的路上，空旷的道路上漆黑一片，偶尔会有一辆汽车从你身边飞驰而过，打破那片平静。我时常在这样的环境下会听一些舒缓的歌，慢慢悠悠的走着，仿佛整个世界都变慢了。每天拖着疲倦的身躯回家的时候，总会有那么一丝的忧伤和孤单。好几次听汪峰的歌差点流泪了。抬头看看天空，小时候看到的满天银河却变成了笼罩在城市上空的乌烟瘴气般的死寂。</p>\n<p><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"210\" src=\"http://music.163.com/outchain/player?type=0&id=422143332&auto=0&height=430\"></iframe><br>（遗憾的是最喜欢的《北京，北京》由于版权限制，不能在我的博客里播放了）</p>\n<blockquote>\n<p>《北京北京》</p>\n<p>当我走在这里的每一条街道<br>我的心似乎从来都不能平静<br>除了发动机的轰鸣和电气之音<br>我似乎听到了他烛骨般的心跳<br>我在这里欢笑我在这里哭泣<br>我在这里活着也在这死去<br>我在这里祈祷 我在这里迷惘<br>我在这里寻找 在这里失去<br>北京 北京<br>……</p>\n</blockquote>\n<p>再到后来，我一个人在北京北三环最繁华的地方租了不到15平米的小卧室，心里想，贵就贵点儿吧，只要不让自己孤单，能给自己舒适的环境就好。每天一个人蜗居在这小房子里，无时无刻体会着蜗居的意义。</p>\n<p>都说年轻的时候喜欢群体生活，我就是一个离不开群体的人。总是渴望着身边有那么几个形影不离的朋友，每天陪你奋斗，陪你聊天，陪你开心，陪你忧伤。但是，谁有何尝没有自己的事呢？我们总是忙于工作，却忽略了生活的意义。</p>\n<p>我喜欢摄影，总想着有空能拍拍属于北京的风景，去三里屯拍姑娘，去郊区野营拍星空，早起爬山拍日出，在景山公园的山顶拍落日……可到现在，我一样也没有拍过。有时候在想，我真的还喜欢着摄影吗？难道只是拍几张好看点的图片给人显摆显摆？不是，我理解它的意义不在于让别人了解你拍摄的东西。而在于自己欣赏你眼前的美景。这些看似很容易做到的事情，却成了奢望。</p>\n<p>在北京也当过几次东道主，忽悠最想见的朋友来北京，那种亲切感，很难用言语表达。每次的相逢的喜悦和离别的伤感都会让人觉得北京这个城市带给我们的东西。</p>\n<p>北京不仅是一座城，它承载了我太多的梦想，汗水，友谊，还有感情。</p>\n<h3 id=\"“青春不老的秘诀是和热爱的事儿待在一起”\"><a href=\"#“青春不老的秘诀是和热爱的事儿待在一起”\" class=\"headerlink\" title=\"“青春不老的秘诀是和热爱的事儿待在一起”\"></a>“青春不老的秘诀是和热爱的事儿待在一起”</h3><p>说起青春，我估计我的青春也所剩无几了，都已经被拉入晚婚晚育人群了。但是我的青春仍然未老，我仍为我喜欢的工作开启着百分百的热情，我深知我热爱这份工作。几遍每天付出几乎所有的时间，从来没有觉得疲倦过。这样的状态不知道还能持续多久，我想，我该为我自己的职业发展好好想想了。</p>\n<p>有时候，我发现自己是一个只有想法，很难付诸行动的人。似乎少了一些动力，将我的想法实现。比如说，想开发的apk很多，有些自认为还是很有商业价值，但是，总是没有坚持下去把它开发出来。到了现在工作了，就没有时间做这些事了</p>\n<h3 id=\"谁说我没有资格拥有梦想\"><a href=\"#谁说我没有资格拥有梦想\" class=\"headerlink\" title=\"谁说我没有资格拥有梦想\"></a>谁说我没有资格拥有梦想</h3><p>待续。。。</p>\n<h3 id=\"谈谈自己的规划\"><a href=\"#谈谈自己的规划\" class=\"headerlink\" title=\"谈谈自己的规划\"></a>谈谈自己的规划</h3><p>没想到写了很多，还是个烂尾的文章，本来打算写完的，但是半夜三点了，再写的话，明天的工作没法做了，所以还是要收个尾，等以后有空的时候，静下心好好给自己规划下未来，也写在这儿，让我的朋友们鞭策我，共同监督我。</p>\n<blockquote>\n<p>写于16年7月15日<br>纪念工作一周年</p>\n</blockquote>\n","excerpt":"","more":"<blockquote>\n<p>前记：不知道为何，最近写东西不管长短，习惯性的喜欢加个前记，这篇文章也免为其难了。我很少写非技术的文章，每当提起笔想写点关于某件事的深刻感受时，总会觉得难以落笔，这大概也是“技术宅”的一种通病吧，或许也是因为懒得去写，给自己找个借口罢了。回想起那个高中的自己，老师布置一篇小说作文，硬是把一本作文本写完了还没有的了结的写作水平大概也就我人生的巅峰了。废话少说，今天终于下定决心要写点什么了，主要也是为了纪念毕业一周年。把这一年的经历和感悟捋一遍。给自己一个新的开始。</p>\n</blockquote>\n<h3 id=\"毕业的离殇\"><a href=\"#毕业的离殇\" class=\"headerlink\" title=\"毕业的离殇\"></a>毕业的离殇</h3><p>我想从页首的那张图说起。恩，很俗气的一张照片，大概每一个毕业生都经历过扔帽子的场景吧。当把压在头上的帽子抛向天空的时候，似乎在向世界宣告着独立。终于卸掉了一身铠甲，凯旋而归了。我很想知道一起经历四年同窗的你们当时的感受。那些曾经朝夕相处了四年的老同学，老朋友你们还好吗？<br>@脑残，@小訾，@二哥，@叶玲，@凤姐，@小彦，@所有人，好久不见，也很少联系，但是我的回忆里还有你们的身影。<br><img src=\"jucan.JPG\" alt=\"聚餐\"></p>\n<p>在大学最幸运的事莫过于三件。</p>\n<p>一是认识了一帮逗逼哥们@华仔，@骚明，@老仲，@攀仔，@华超，我们哭过，闹过，一起醉过，一起疯过，一起去旅行过，一起为了期末的考试写过小纸条，一起经历过太多太多让人怀念的事儿…<br><img src=\"qiqihaer.jpg\" alt=\"旅行似乎从来没有凑齐过\"></p>\n<p>即便是现在我们经常有事没事微信上开个小视频“会议”，彼此调侃一番，问问都过得怎么样，每个人都为自己的理想努力着，这就够了；</p>\n<p>二是学了自己想学的东西，遇到了志同道合的@超哥，@志哥，@嘉伟，一起度过了不少闲暇的写代码时光，好让自己觉得没有白白浪费大学的美好时光；<br><img src=\"shiyanshi.jpg\" alt=\"曾经呆的时间最长的地方\"></p>\n<p>三是遇到了那个陪我度过大半个大学时光的她。虽然因为种种原因，没有走在一起，但是，那段时光会一直珍藏在心中。谈到大学的时光，每个人的回忆里都会有那么一段终身难忘的经历，我也一样。不管结果如何，感谢能在青春年华里给我那么一段难忘而又美好的记忆。</p>\n<p>回想起毕业的最后的那段时光，想想当时的自己，那段日子也许是我人生中最痛彻心扉的一段时光了。有太多的遗憾留在了校园。那几个烂醉痛哭的夜晚还是历历在目，已然记不清当初说过什么煽情的话语了，只记得嘶声裂肺的痛哭。</p>\n<p>很多人都羡慕我能找到自己喜欢的工作，其实，我并不是不喜欢化学，高中的时候，痴迷于化学。那一切都像是现在对于计算机的迷恋一样的让人沉醉。我毫不犹豫的选了高分子化学的专业。可后来，我被现实的教育体制打败了。那种激情慢慢被消磨下去。再到后来，我开始疯狂的迷恋上了编程。这可能和我的性格有关。我喜欢有挑战的事物，喜欢每个想干的事儿完成后的欣喜和满足感。这激励着我，一直没停的追逐着自己喜欢的东西。</p>\n<h3 id=\"“北京不仅是一座城”\"><a href=\"#“北京不仅是一座城”\" class=\"headerlink\" title=\"“北京不仅是一座城”\"></a>“北京不仅是一座城”</h3><p><img src=\"beijing.jpg\" alt=\"北京的夜景\"></p>\n<p>去年的今天，我来到了北京，这个让无数人向往而敬畏的地方。想想当时的自己，毫无畏惧，从来没有想过在北京怎么生活，也没有为自己的将来考虑得太深。有幸的是，现在的公司给了我一个学化学的人拥抱自己热爱的事儿的机会，我想这大概就是“青春不老的秘诀是和热爱的事儿待在一起”的意义吧。</p>\n<p>最近在看一本书：《何必等来生》。美得让人窒息的句子背后，我想燕子也曾经历过像我现在这样的感悟。来北京整整一年了，这里让我体会最深的就是在这个城市里每个人都在为生活拼搏的那种顽强的生命力。“北京给我们梦境和风雨，也孕育着友谊和爱情”，没人不因为高昂的房价而感到压抑也绝望，同时，在这个城市里，每个人充满斗志，似乎北京就是整个世界。</p>\n<p>很喜欢燕子的这段话：</p>\n<blockquote>\n<p>如果你愿意去北京的火车站蹲守，你会看见无数年轻又热血的生命，背着沉重的行李刚刚抵达，他们大口呼吸，攥紧拳头，充满斗志，觉得北京就是全世界，全世界最值得付出年华的地方就是北京。北京长满了最好看的梦想之花，那花儿曲曲折折也密密麻麻地开在川流不息的城市中的每一个犄角旮旯。那些迷幻的花朵，在每个毕业季的夏末秋初，变成天使一样的人形，向那些心里存着微光的人们漏出最复杂的笑容。轻轻的说，来吧，北京。</p>\n</blockquote>\n<p>这一年里，从刚来北京的员工宿舍的群居生活，到开始追求生活，一个人在北三环租了2500一个月房租的卧室过上自己所谓的“小资生活”。从一个职场新人到被更多的人认可。从一个轻浮的脾气有点倔的愤青还是变得有点成熟。这中间又有多少悲欢离合的故事。</p>\n<p>刚来北京的时候，我认识了现在的同事，@太白金星，@雷总，@涛涛，@小红，@小马哥，@隔壁老王，一起住了大半年的群居生活，似乎给人一种错觉，是不是还没有毕业？每天下班，回来扯上几句，总是让人觉得酣畅淋漓，高兴的不高兴的全抛到脑后了。大家都是非常拼命的工作。每天跑跑步，打打球，热热闹闹的吃火锅，看电影，这样的日子总会让人觉得很充实。后来大家各自租房了，就很少有机会见面了。</p>\n<p>在员工宿舍住的那段日子，有时候，下班很晚，一个人走在下班的路上，空旷的道路上漆黑一片，偶尔会有一辆汽车从你身边飞驰而过，打破那片平静。我时常在这样的环境下会听一些舒缓的歌，慢慢悠悠的走着，仿佛整个世界都变慢了。每天拖着疲倦的身躯回家的时候，总会有那么一丝的忧伤和孤单。好几次听汪峰的歌差点流泪了。抬头看看天空，小时候看到的满天银河却变成了笼罩在城市上空的乌烟瘴气般的死寂。</p>\n<p><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=210 src=\"http://music.163.com/outchain/player?type=0&id=422143332&auto=0&height=430\"></iframe><br>（遗憾的是最喜欢的《北京，北京》由于版权限制，不能在我的博客里播放了）</p>\n<blockquote>\n<p>《北京北京》</p>\n<p>当我走在这里的每一条街道<br>我的心似乎从来都不能平静<br>除了发动机的轰鸣和电气之音<br>我似乎听到了他烛骨般的心跳<br>我在这里欢笑我在这里哭泣<br>我在这里活着也在这死去<br>我在这里祈祷 我在这里迷惘<br>我在这里寻找 在这里失去<br>北京 北京<br>……</p>\n</blockquote>\n<p>再到后来，我一个人在北京北三环最繁华的地方租了不到15平米的小卧室，心里想，贵就贵点儿吧，只要不让自己孤单，能给自己舒适的环境就好。每天一个人蜗居在这小房子里，无时无刻体会着蜗居的意义。</p>\n<p>都说年轻的时候喜欢群体生活，我就是一个离不开群体的人。总是渴望着身边有那么几个形影不离的朋友，每天陪你奋斗，陪你聊天，陪你开心，陪你忧伤。但是，谁有何尝没有自己的事呢？我们总是忙于工作，却忽略了生活的意义。</p>\n<p>我喜欢摄影，总想着有空能拍拍属于北京的风景，去三里屯拍姑娘，去郊区野营拍星空，早起爬山拍日出，在景山公园的山顶拍落日……可到现在，我一样也没有拍过。有时候在想，我真的还喜欢着摄影吗？难道只是拍几张好看点的图片给人显摆显摆？不是，我理解它的意义不在于让别人了解你拍摄的东西。而在于自己欣赏你眼前的美景。这些看似很容易做到的事情，却成了奢望。</p>\n<p>在北京也当过几次东道主，忽悠最想见的朋友来北京，那种亲切感，很难用言语表达。每次的相逢的喜悦和离别的伤感都会让人觉得北京这个城市带给我们的东西。</p>\n<p>北京不仅是一座城，它承载了我太多的梦想，汗水，友谊，还有感情。</p>\n<h3 id=\"“青春不老的秘诀是和热爱的事儿待在一起”\"><a href=\"#“青春不老的秘诀是和热爱的事儿待在一起”\" class=\"headerlink\" title=\"“青春不老的秘诀是和热爱的事儿待在一起”\"></a>“青春不老的秘诀是和热爱的事儿待在一起”</h3><p>说起青春，我估计我的青春也所剩无几了，都已经被拉入晚婚晚育人群了。但是我的青春仍然未老，我仍为我喜欢的工作开启着百分百的热情，我深知我热爱这份工作。几遍每天付出几乎所有的时间，从来没有觉得疲倦过。这样的状态不知道还能持续多久，我想，我该为我自己的职业发展好好想想了。</p>\n<p>有时候，我发现自己是一个只有想法，很难付诸行动的人。似乎少了一些动力，将我的想法实现。比如说，想开发的apk很多，有些自认为还是很有商业价值，但是，总是没有坚持下去把它开发出来。到了现在工作了，就没有时间做这些事了</p>\n<h3 id=\"谁说我没有资格拥有梦想\"><a href=\"#谁说我没有资格拥有梦想\" class=\"headerlink\" title=\"谁说我没有资格拥有梦想\"></a>谁说我没有资格拥有梦想</h3><p>待续。。。</p>\n<h3 id=\"谈谈自己的规划\"><a href=\"#谈谈自己的规划\" class=\"headerlink\" title=\"谈谈自己的规划\"></a>谈谈自己的规划</h3><p>没想到写了很多，还是个烂尾的文章，本来打算写完的，但是半夜三点了，再写的话，明天的工作没法做了，所以还是要收个尾，等以后有空的时候，静下心好好给自己规划下未来，也写在这儿，让我的朋友们鞭策我，共同监督我。</p>\n<blockquote>\n<p>写于16年7月15日<br>纪念工作一周年</p>\n</blockquote>\n"},{"layout":"post","title":"UML序列图学习笔记","subtitle":"序列图主要用于按照交互发生的一系列顺序，显示对象之间的这些交互。","author":"JianGuo","header-img":"what-is-uml.jpg","date":"2016-07-12T11:50:29.000Z","_content":"\n## UML序列图学习笔记\n\n> 注：本文总结自：[UML 基础: 序列图](http://www.ibm.com/developerworks/cn/rational/rationaledge/content/feb05/bell/3101.html)，英文原文：[The sequence diagram](http://www.ibm.com/developerworks/rational/library/3101.html?S_TACT=105AGX52&S_CMP=cn-a-r), 本文会有针对自己理解的一些编撰。\n\n序列图主要用于按照交互发生的一系列顺序，显示对象之间的这些交互。很象类图，列图在记录一个未来系统的行为应该如何表现中，非常有用。在设计阶段，架构师和开发者能使用图，挖掘出系统对象间的交互，这样充实整个系统设计。\n\n序列图的主要用途之一，是把用例表达的需求，转化为进一步、更加正式层次的精细表达。用例常常被细化为一个或者更多的序列图。序列图除了在设计新系统方面的用途外，它们还能用来记录一个存在系统（称它为“遗产”）的对象现在如何交互。\n\n下面就来一一了解下组成序列图的相关元素。\n\n\n### 符号原件\n#### 框架\n框架元件用于作为许多其他的图元件的一个基础。可以作为图的图形化边界，为图的标签提供一致的位置。  \n![](http://www.ibm.com/developerworks/cn/rational/rationaledge/content/feb05/bell/3101_figure1.jpg)\n\n除了作为图的图形化边界以外，也有描述交互的重要的功能, 例如序列图，在序列图上一个序列接收和发送消息（又称交互），能通过连接消息和框架元件边界，建立模型。如下图：  \n![](http://www.ibm.com/developerworks/rational/library/content/RationalEdge/feb04/3101_figure2.jpg)\n\n当使用一个框架元件封闭一个图时，图的标签需要按照以下的格式:\n> 图类型 图名称\n\n### 基础\n序列图的主要目的是定义事件序列，产生一些希望的输出。重点不是消息本身，而是消息产生的顺序；不过，大多数序列图会表示一个系统的对象之间传递的什么消息，以及它们发生的顺序。图按照水平和垂直的维度传递信息：垂直维度从上而下表示消息/调用发生的时间序列，而且水平维度从左到右表示消息发送到的对象实例。\n\n#### 生命线\n生命线表示序列中，建模的角色或对象实例,如下图所示：    \n![](http://www.ibm.com/developerworks/rational/library/content/RationalEdge/feb04/3101_figure3.jpg)  \n\nUML 的生命线命名标准按照如下格式:  \n> 实体名 : 类名\n\n在上面的例子中，生命线表示类student的实体，实体名称是freshman（生命线名称带下划线）。**当使用下划线时，意味着序列图中的生命线代表一个类的特定实体，不是特定种类的实体（例如，角色）**,序列图的实例名称有下划线，而角色名称没有。  \n一个生命线不仅仅用来代表一个特定实体，也能用来表现一个匿名的或未命名的实体。当在一个序列图上，对一个未命名的实例建模时，生命线的命名采用和一个命名实例相同的命名方式，但是生命线实体名的位置留下空白，而不是提供一个实体的名字。如下图所示：  \n![](shili4.png)  \n同时，也可以只使用对象名来代表这个特定的实例。  \n![](shili5.png)  \n\n#### 消息\n为了可读性，序列图的第一个消息总是从顶端开始，并且一般位于图的左边。然后继发的消息加入图中，稍微比前面的消息低些。 消息一般分为同步消息（Synchronous Message），异步消息（Asynchronous Message）和返回消息（Return Message）.如下图所示：   \n![](shili6.jpg)  \n\n  * 同步消息=调用消息（Synchronous Message）  \n  消息的发送者把控制传递给消息的接收者，然后停止活动，等待消息的接收者放弃或者返回控制。用来表示同步的意义。\n\n  * 异步消息（Asynchronous Message）  \n  消息发送者通过消息把信号传递给消息的接收者，然后继续自己的活动，不等待接受者返回消息或者控制。异步消息的接收者和发送者是并发工作的。\n\n  * 返回消息（Return Message）  \n  返回消息表示从过程调用返回\n\n  * 自关联消息（Self-Message）  \n  表示方法的自身调用以及一个对象内的一个方法调用另外一个方法。\n","source":"_posts/UML_learning_note.md","raw":"---\nlayout: post\ntitle: UML序列图学习笔记\nsubtitle: 序列图主要用于按照交互发生的一系列顺序，显示对象之间的这些交互。\nauthor: JianGuo\nheader-img: what-is-uml.jpg\ntags: UML\ndate: 2016-07-12 19:50:29\n---\n\n## UML序列图学习笔记\n\n> 注：本文总结自：[UML 基础: 序列图](http://www.ibm.com/developerworks/cn/rational/rationaledge/content/feb05/bell/3101.html)，英文原文：[The sequence diagram](http://www.ibm.com/developerworks/rational/library/3101.html?S_TACT=105AGX52&S_CMP=cn-a-r), 本文会有针对自己理解的一些编撰。\n\n序列图主要用于按照交互发生的一系列顺序，显示对象之间的这些交互。很象类图，列图在记录一个未来系统的行为应该如何表现中，非常有用。在设计阶段，架构师和开发者能使用图，挖掘出系统对象间的交互，这样充实整个系统设计。\n\n序列图的主要用途之一，是把用例表达的需求，转化为进一步、更加正式层次的精细表达。用例常常被细化为一个或者更多的序列图。序列图除了在设计新系统方面的用途外，它们还能用来记录一个存在系统（称它为“遗产”）的对象现在如何交互。\n\n下面就来一一了解下组成序列图的相关元素。\n\n\n### 符号原件\n#### 框架\n框架元件用于作为许多其他的图元件的一个基础。可以作为图的图形化边界，为图的标签提供一致的位置。  \n![](http://www.ibm.com/developerworks/cn/rational/rationaledge/content/feb05/bell/3101_figure1.jpg)\n\n除了作为图的图形化边界以外，也有描述交互的重要的功能, 例如序列图，在序列图上一个序列接收和发送消息（又称交互），能通过连接消息和框架元件边界，建立模型。如下图：  \n![](http://www.ibm.com/developerworks/rational/library/content/RationalEdge/feb04/3101_figure2.jpg)\n\n当使用一个框架元件封闭一个图时，图的标签需要按照以下的格式:\n> 图类型 图名称\n\n### 基础\n序列图的主要目的是定义事件序列，产生一些希望的输出。重点不是消息本身，而是消息产生的顺序；不过，大多数序列图会表示一个系统的对象之间传递的什么消息，以及它们发生的顺序。图按照水平和垂直的维度传递信息：垂直维度从上而下表示消息/调用发生的时间序列，而且水平维度从左到右表示消息发送到的对象实例。\n\n#### 生命线\n生命线表示序列中，建模的角色或对象实例,如下图所示：    \n![](http://www.ibm.com/developerworks/rational/library/content/RationalEdge/feb04/3101_figure3.jpg)  \n\nUML 的生命线命名标准按照如下格式:  \n> 实体名 : 类名\n\n在上面的例子中，生命线表示类student的实体，实体名称是freshman（生命线名称带下划线）。**当使用下划线时，意味着序列图中的生命线代表一个类的特定实体，不是特定种类的实体（例如，角色）**,序列图的实例名称有下划线，而角色名称没有。  \n一个生命线不仅仅用来代表一个特定实体，也能用来表现一个匿名的或未命名的实体。当在一个序列图上，对一个未命名的实例建模时，生命线的命名采用和一个命名实例相同的命名方式，但是生命线实体名的位置留下空白，而不是提供一个实体的名字。如下图所示：  \n![](shili4.png)  \n同时，也可以只使用对象名来代表这个特定的实例。  \n![](shili5.png)  \n\n#### 消息\n为了可读性，序列图的第一个消息总是从顶端开始，并且一般位于图的左边。然后继发的消息加入图中，稍微比前面的消息低些。 消息一般分为同步消息（Synchronous Message），异步消息（Asynchronous Message）和返回消息（Return Message）.如下图所示：   \n![](shili6.jpg)  \n\n  * 同步消息=调用消息（Synchronous Message）  \n  消息的发送者把控制传递给消息的接收者，然后停止活动，等待消息的接收者放弃或者返回控制。用来表示同步的意义。\n\n  * 异步消息（Asynchronous Message）  \n  消息发送者通过消息把信号传递给消息的接收者，然后继续自己的活动，不等待接受者返回消息或者控制。异步消息的接收者和发送者是并发工作的。\n\n  * 返回消息（Return Message）  \n  返回消息表示从过程调用返回\n\n  * 自关联消息（Self-Message）  \n  表示方法的自身调用以及一个对象内的一个方法调用另外一个方法。\n","slug":"UML_learning_note","published":1,"updated":"2016-07-28T12:15:26.960Z","comments":1,"photos":[],"link":"","_id":"cirdlcvc8000b252nor6cul3n","content":"<h2 id=\"UML序列图学习笔记\"><a href=\"#UML序列图学习笔记\" class=\"headerlink\" title=\"UML序列图学习笔记\"></a>UML序列图学习笔记</h2><blockquote>\n<p>注：本文总结自：<a href=\"http://www.ibm.com/developerworks/cn/rational/rationaledge/content/feb05/bell/3101.html\" target=\"_blank\" rel=\"external\">UML 基础: 序列图</a>，英文原文：<a href=\"http://www.ibm.com/developerworks/rational/library/3101.html?S_TACT=105AGX52&amp;S_CMP=cn-a-r\" target=\"_blank\" rel=\"external\">The sequence diagram</a>, 本文会有针对自己理解的一些编撰。</p>\n</blockquote>\n<p>序列图主要用于按照交互发生的一系列顺序，显示对象之间的这些交互。很象类图，列图在记录一个未来系统的行为应该如何表现中，非常有用。在设计阶段，架构师和开发者能使用图，挖掘出系统对象间的交互，这样充实整个系统设计。</p>\n<p>序列图的主要用途之一，是把用例表达的需求，转化为进一步、更加正式层次的精细表达。用例常常被细化为一个或者更多的序列图。序列图除了在设计新系统方面的用途外，它们还能用来记录一个存在系统（称它为“遗产”）的对象现在如何交互。</p>\n<p>下面就来一一了解下组成序列图的相关元素。</p>\n<h3 id=\"符号原件\"><a href=\"#符号原件\" class=\"headerlink\" title=\"符号原件\"></a>符号原件</h3><h4 id=\"框架\"><a href=\"#框架\" class=\"headerlink\" title=\"框架\"></a>框架</h4><p>框架元件用于作为许多其他的图元件的一个基础。可以作为图的图形化边界，为图的标签提供一致的位置。<br><img src=\"http://www.ibm.com/developerworks/cn/rational/rationaledge/content/feb05/bell/3101_figure1.jpg\" alt=\"\"></p>\n<p>除了作为图的图形化边界以外，也有描述交互的重要的功能, 例如序列图，在序列图上一个序列接收和发送消息（又称交互），能通过连接消息和框架元件边界，建立模型。如下图：<br><img src=\"http://www.ibm.com/developerworks/rational/library/content/RationalEdge/feb04/3101_figure2.jpg\" alt=\"\"></p>\n<p>当使用一个框架元件封闭一个图时，图的标签需要按照以下的格式:</p>\n<blockquote>\n<p>图类型 图名称</p>\n</blockquote>\n<h3 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h3><p>序列图的主要目的是定义事件序列，产生一些希望的输出。重点不是消息本身，而是消息产生的顺序；不过，大多数序列图会表示一个系统的对象之间传递的什么消息，以及它们发生的顺序。图按照水平和垂直的维度传递信息：垂直维度从上而下表示消息/调用发生的时间序列，而且水平维度从左到右表示消息发送到的对象实例。</p>\n<h4 id=\"生命线\"><a href=\"#生命线\" class=\"headerlink\" title=\"生命线\"></a>生命线</h4><p>生命线表示序列中，建模的角色或对象实例,如下图所示：<br><img src=\"http://www.ibm.com/developerworks/rational/library/content/RationalEdge/feb04/3101_figure3.jpg\" alt=\"\">  </p>\n<p>UML 的生命线命名标准按照如下格式:  </p>\n<blockquote>\n<p>实体名 : 类名</p>\n</blockquote>\n<p>在上面的例子中，生命线表示类student的实体，实体名称是freshman（生命线名称带下划线）。<strong>当使用下划线时，意味着序列图中的生命线代表一个类的特定实体，不是特定种类的实体（例如，角色）</strong>,序列图的实例名称有下划线，而角色名称没有。<br>一个生命线不仅仅用来代表一个特定实体，也能用来表现一个匿名的或未命名的实体。当在一个序列图上，对一个未命名的实例建模时，生命线的命名采用和一个命名实例相同的命名方式，但是生命线实体名的位置留下空白，而不是提供一个实体的名字。如下图所示：<br><img src=\"shili4.png\" alt=\"\"><br>同时，也可以只使用对象名来代表这个特定的实例。<br><img src=\"shili5.png\" alt=\"\">  </p>\n<h4 id=\"消息\"><a href=\"#消息\" class=\"headerlink\" title=\"消息\"></a>消息</h4><p>为了可读性，序列图的第一个消息总是从顶端开始，并且一般位于图的左边。然后继发的消息加入图中，稍微比前面的消息低些。 消息一般分为同步消息（Synchronous Message），异步消息（Asynchronous Message）和返回消息（Return Message）.如下图所示：<br><img src=\"shili6.jpg\" alt=\"\">  </p>\n<ul>\n<li><p>同步消息=调用消息（Synchronous Message）<br>消息的发送者把控制传递给消息的接收者，然后停止活动，等待消息的接收者放弃或者返回控制。用来表示同步的意义。</p>\n</li>\n<li><p>异步消息（Asynchronous Message）<br>消息发送者通过消息把信号传递给消息的接收者，然后继续自己的活动，不等待接受者返回消息或者控制。异步消息的接收者和发送者是并发工作的。</p>\n</li>\n<li><p>返回消息（Return Message）<br>返回消息表示从过程调用返回</p>\n</li>\n<li><p>自关联消息（Self-Message）<br>表示方法的自身调用以及一个对象内的一个方法调用另外一个方法。</p>\n</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"UML序列图学习笔记\"><a href=\"#UML序列图学习笔记\" class=\"headerlink\" title=\"UML序列图学习笔记\"></a>UML序列图学习笔记</h2><blockquote>\n<p>注：本文总结自：<a href=\"http://www.ibm.com/developerworks/cn/rational/rationaledge/content/feb05/bell/3101.html\">UML 基础: 序列图</a>，英文原文：<a href=\"http://www.ibm.com/developerworks/rational/library/3101.html?S_TACT=105AGX52&amp;S_CMP=cn-a-r\">The sequence diagram</a>, 本文会有针对自己理解的一些编撰。</p>\n</blockquote>\n<p>序列图主要用于按照交互发生的一系列顺序，显示对象之间的这些交互。很象类图，列图在记录一个未来系统的行为应该如何表现中，非常有用。在设计阶段，架构师和开发者能使用图，挖掘出系统对象间的交互，这样充实整个系统设计。</p>\n<p>序列图的主要用途之一，是把用例表达的需求，转化为进一步、更加正式层次的精细表达。用例常常被细化为一个或者更多的序列图。序列图除了在设计新系统方面的用途外，它们还能用来记录一个存在系统（称它为“遗产”）的对象现在如何交互。</p>\n<p>下面就来一一了解下组成序列图的相关元素。</p>\n<h3 id=\"符号原件\"><a href=\"#符号原件\" class=\"headerlink\" title=\"符号原件\"></a>符号原件</h3><h4 id=\"框架\"><a href=\"#框架\" class=\"headerlink\" title=\"框架\"></a>框架</h4><p>框架元件用于作为许多其他的图元件的一个基础。可以作为图的图形化边界，为图的标签提供一致的位置。<br><img src=\"http://www.ibm.com/developerworks/cn/rational/rationaledge/content/feb05/bell/3101_figure1.jpg\" alt=\"\"></p>\n<p>除了作为图的图形化边界以外，也有描述交互的重要的功能, 例如序列图，在序列图上一个序列接收和发送消息（又称交互），能通过连接消息和框架元件边界，建立模型。如下图：<br><img src=\"http://www.ibm.com/developerworks/rational/library/content/RationalEdge/feb04/3101_figure2.jpg\" alt=\"\"></p>\n<p>当使用一个框架元件封闭一个图时，图的标签需要按照以下的格式:</p>\n<blockquote>\n<p>图类型 图名称</p>\n</blockquote>\n<h3 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h3><p>序列图的主要目的是定义事件序列，产生一些希望的输出。重点不是消息本身，而是消息产生的顺序；不过，大多数序列图会表示一个系统的对象之间传递的什么消息，以及它们发生的顺序。图按照水平和垂直的维度传递信息：垂直维度从上而下表示消息/调用发生的时间序列，而且水平维度从左到右表示消息发送到的对象实例。</p>\n<h4 id=\"生命线\"><a href=\"#生命线\" class=\"headerlink\" title=\"生命线\"></a>生命线</h4><p>生命线表示序列中，建模的角色或对象实例,如下图所示：<br><img src=\"http://www.ibm.com/developerworks/rational/library/content/RationalEdge/feb04/3101_figure3.jpg\" alt=\"\">  </p>\n<p>UML 的生命线命名标准按照如下格式:  </p>\n<blockquote>\n<p>实体名 : 类名</p>\n</blockquote>\n<p>在上面的例子中，生命线表示类student的实体，实体名称是freshman（生命线名称带下划线）。<strong>当使用下划线时，意味着序列图中的生命线代表一个类的特定实体，不是特定种类的实体（例如，角色）</strong>,序列图的实例名称有下划线，而角色名称没有。<br>一个生命线不仅仅用来代表一个特定实体，也能用来表现一个匿名的或未命名的实体。当在一个序列图上，对一个未命名的实例建模时，生命线的命名采用和一个命名实例相同的命名方式，但是生命线实体名的位置留下空白，而不是提供一个实体的名字。如下图所示：<br><img src=\"shili4.png\" alt=\"\"><br>同时，也可以只使用对象名来代表这个特定的实例。<br><img src=\"shili5.png\" alt=\"\">  </p>\n<h4 id=\"消息\"><a href=\"#消息\" class=\"headerlink\" title=\"消息\"></a>消息</h4><p>为了可读性，序列图的第一个消息总是从顶端开始，并且一般位于图的左边。然后继发的消息加入图中，稍微比前面的消息低些。 消息一般分为同步消息（Synchronous Message），异步消息（Asynchronous Message）和返回消息（Return Message）.如下图所示：<br><img src=\"shili6.jpg\" alt=\"\">  </p>\n<ul>\n<li><p>同步消息=调用消息（Synchronous Message）<br>消息的发送者把控制传递给消息的接收者，然后停止活动，等待消息的接收者放弃或者返回控制。用来表示同步的意义。</p>\n</li>\n<li><p>异步消息（Asynchronous Message）<br>消息发送者通过消息把信号传递给消息的接收者，然后继续自己的活动，不等待接受者返回消息或者控制。异步消息的接收者和发送者是并发工作的。</p>\n</li>\n<li><p>返回消息（Return Message）<br>返回消息表示从过程调用返回</p>\n</li>\n<li><p>自关联消息（Self-Message）<br>表示方法的自身调用以及一个对象内的一个方法调用另外一个方法。</p>\n</li>\n</ul>\n"},{"layout":"post","title":"java 中的注解","subtitle":"针对java中注解的学习笔记","date":"2016-08-02T12:22:04.000Z","author":"JianGuo Yang","header-img":null,"_content":"> 一直对java中的注解不是很了解，但是随处可见，前些天，一位朋友@徐文志程序猿在博客中写了关于PHP的注释，学习了很多，所以，也尝试着学习下java中的注解，并记录在这里，供以后复习，也便于大家共同学习。\n\n\n在开始之前，我墙裂给大家安利一种学习方式。思维导图，又称脑图，是能够将思维中抽象的逻辑关系转化为直观的关系图标的一种方式，在我们的学习中，可以将知识点通过思维导图梳理出来，非常有条理，还方便记忆，这篇文章中，我会尝试着用思维导图阐述我的学习过程。好了现在就开始干正事，切入正题吧。\n\n注解（Annotation）是java 5.0引入的新特性。它提供了一种结构化的类型检查的新途径。我们通过加入注解，能够避免很多问题，例如编写累赘的部署描述文件。与代码注释相比，它更注重与描述类的相关信息。\n# 基本的语法\n注解的语法还是比较简单的，除了多了@符号外，其他的和java的固有语法一致。\n在java SE5 中就提供了三种原生的注解：\n  * @Override 表示当前的方法继承自父类，并且复写了父类的方法，如果被注解的方法在父类中不存在，编译器就会抛出异常。在java中，这个注解是可选的。\n  * @Deprecated 表示当前的方法已经被废弃，在编译时会有警告提示。\n  * @SuppressWarings 表示主动忽略不恰当的编译器警告。\n  此外，java 还提供了可扩展的annotation API。\n  下面的例子说明了注解的使用：  \n\n\n  ```java\npublic class Testable {\n    public void execute(){\n      System.out.println(\"Executing...\");\n    }\n    @Test\n    void testExecute (){\n      execute();\n    }\n}\n  ```\n  **@Test** 注解本身不做任何的操作，但是，编译器在编译的时候，就必须找到关于该注解的定义，否则就会报错。下面的一小节将会介绍如何进行定义。\n\n# 注解的定义\n下面，我们就给出前文提到的@Test注解的定义：\n```java\nimport java.lang.annotation\n\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Test{}\n```\n这样，就定义了一个@Test的注解。我们可以看到，其实和接口的定义很像。不同的是，在定义注解时，我们需要一些[元注解](#什么是元注解)，如@Target，@Retention。其中：  \n* **@Target** 注解用来定义该注解的作用域，如作用于一个方法还是一个域。\n* **@Retention** 则定义了该注解在哪个级别可用，源代码（SOURCE）中、类文件（CLASS）中、运行时（RUNTIME）。\n这类注解由于没有元素，被称为 **标记注解（marker annotation）**， 通常情况下，注解还会加上一些元素用于表示某些值。这些值用于编译器在分析和处理该注解时的参考。可以为这些元素指定默认值。\n我们来看看元素的使用：  \n\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface UseCase{\n  public int id();\n  public String description() default \"no description\";\n}\n```\n这个@UserCase 注解就定义了两个元素，我们为description元素制定了默认值。如果使用该注解在注解某个方法时，没有给定描述字符，将会使用该默认值代替。下面我们接着看看如何使用该注解。\n\n# 注解的使用\n注解元素的使用过程中，是以键-值对的形式给出的。\n```java\npublic class PasswordUtils {\n  @UseCase(id= 1,description=\"Password must contain at least one numeric\")\n  public boolean validataPassword(String password) {\n    return(password.mathes(\"\\\\w*\\\\d\\\\w*\"))\n  }\n\n  @UseCase(id=2)\n  public String encryptPassword(String password) {\n    return new StringBuffer(password).reverse().toString();\n  }\n\n  @UseCase(id=3,description=\"New password can't equal previously password\")\n  public boolean checkForNewPassword(List<String> prePassWords, String password){\n    return !prePassWords.contains(password);\n  }\n\n}\n```\n\n# 什么是元注解\n我们知道，万物是有源头的，就像我们的大千世界都是由原子构成的。元注解就是注解的源头，用于注解其他的注解。这句话有点绕，其实就是在我们定义注解的时候，使用元注解来定义该注解的作用域，使用级别，是否允许继承该注解等相关属性。如下表：\n\n| 元注解          | 解释     |\n| :------------- | :------------- |\n| @Target        |   表示该注解可以用于什么地方     |\n| @Retention     |   表示在什么级别保存该注解信息     |\n| @Documented    |   将此注解包含在javaDoc中     |\n| @Inherited     |   允许子类继承父类的注解     |\n\n其中@Target的取值有七种：  \n\n| 值     | 解释     |\n| :------------- | :------------- |\n| CONSTRUCTOR       | 构造器的声明       |\n| FIELD       | 域声明（包括enum）       |\n| LOCAL_VARIABLE       | 局部变量的声明       |\n| METHOD       | 方法的声明       |\n| PACKAGE       | 包的声明       |\n| PARAMETER     | 参数的声明       |\n| TYPE       | 类，接口，或enum的声明       |\n\n接下来将会学习编写注解解释器程序通过反射用于实现注解对应的功能。  \n未完待续～\n","source":"_posts/annotation_learning.md","raw":"---\nlayout:     post\ntitle: java 中的注解\nsubtitle:   针对java中注解的学习笔记\ndate: 2016-08-02 20:22:04\nauthor:     \"JianGuo Yang\"\nheader-img: \ntags: Java\n---\n> 一直对java中的注解不是很了解，但是随处可见，前些天，一位朋友@徐文志程序猿在博客中写了关于PHP的注释，学习了很多，所以，也尝试着学习下java中的注解，并记录在这里，供以后复习，也便于大家共同学习。\n\n\n在开始之前，我墙裂给大家安利一种学习方式。思维导图，又称脑图，是能够将思维中抽象的逻辑关系转化为直观的关系图标的一种方式，在我们的学习中，可以将知识点通过思维导图梳理出来，非常有条理，还方便记忆，这篇文章中，我会尝试着用思维导图阐述我的学习过程。好了现在就开始干正事，切入正题吧。\n\n注解（Annotation）是java 5.0引入的新特性。它提供了一种结构化的类型检查的新途径。我们通过加入注解，能够避免很多问题，例如编写累赘的部署描述文件。与代码注释相比，它更注重与描述类的相关信息。\n# 基本的语法\n注解的语法还是比较简单的，除了多了@符号外，其他的和java的固有语法一致。\n在java SE5 中就提供了三种原生的注解：\n  * @Override 表示当前的方法继承自父类，并且复写了父类的方法，如果被注解的方法在父类中不存在，编译器就会抛出异常。在java中，这个注解是可选的。\n  * @Deprecated 表示当前的方法已经被废弃，在编译时会有警告提示。\n  * @SuppressWarings 表示主动忽略不恰当的编译器警告。\n  此外，java 还提供了可扩展的annotation API。\n  下面的例子说明了注解的使用：  \n\n\n  ```java\npublic class Testable {\n    public void execute(){\n      System.out.println(\"Executing...\");\n    }\n    @Test\n    void testExecute (){\n      execute();\n    }\n}\n  ```\n  **@Test** 注解本身不做任何的操作，但是，编译器在编译的时候，就必须找到关于该注解的定义，否则就会报错。下面的一小节将会介绍如何进行定义。\n\n# 注解的定义\n下面，我们就给出前文提到的@Test注解的定义：\n```java\nimport java.lang.annotation\n\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Test{}\n```\n这样，就定义了一个@Test的注解。我们可以看到，其实和接口的定义很像。不同的是，在定义注解时，我们需要一些[元注解](#什么是元注解)，如@Target，@Retention。其中：  \n* **@Target** 注解用来定义该注解的作用域，如作用于一个方法还是一个域。\n* **@Retention** 则定义了该注解在哪个级别可用，源代码（SOURCE）中、类文件（CLASS）中、运行时（RUNTIME）。\n这类注解由于没有元素，被称为 **标记注解（marker annotation）**， 通常情况下，注解还会加上一些元素用于表示某些值。这些值用于编译器在分析和处理该注解时的参考。可以为这些元素指定默认值。\n我们来看看元素的使用：  \n\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface UseCase{\n  public int id();\n  public String description() default \"no description\";\n}\n```\n这个@UserCase 注解就定义了两个元素，我们为description元素制定了默认值。如果使用该注解在注解某个方法时，没有给定描述字符，将会使用该默认值代替。下面我们接着看看如何使用该注解。\n\n# 注解的使用\n注解元素的使用过程中，是以键-值对的形式给出的。\n```java\npublic class PasswordUtils {\n  @UseCase(id= 1,description=\"Password must contain at least one numeric\")\n  public boolean validataPassword(String password) {\n    return(password.mathes(\"\\\\w*\\\\d\\\\w*\"))\n  }\n\n  @UseCase(id=2)\n  public String encryptPassword(String password) {\n    return new StringBuffer(password).reverse().toString();\n  }\n\n  @UseCase(id=3,description=\"New password can't equal previously password\")\n  public boolean checkForNewPassword(List<String> prePassWords, String password){\n    return !prePassWords.contains(password);\n  }\n\n}\n```\n\n# 什么是元注解\n我们知道，万物是有源头的，就像我们的大千世界都是由原子构成的。元注解就是注解的源头，用于注解其他的注解。这句话有点绕，其实就是在我们定义注解的时候，使用元注解来定义该注解的作用域，使用级别，是否允许继承该注解等相关属性。如下表：\n\n| 元注解          | 解释     |\n| :------------- | :------------- |\n| @Target        |   表示该注解可以用于什么地方     |\n| @Retention     |   表示在什么级别保存该注解信息     |\n| @Documented    |   将此注解包含在javaDoc中     |\n| @Inherited     |   允许子类继承父类的注解     |\n\n其中@Target的取值有七种：  \n\n| 值     | 解释     |\n| :------------- | :------------- |\n| CONSTRUCTOR       | 构造器的声明       |\n| FIELD       | 域声明（包括enum）       |\n| LOCAL_VARIABLE       | 局部变量的声明       |\n| METHOD       | 方法的声明       |\n| PACKAGE       | 包的声明       |\n| PARAMETER     | 参数的声明       |\n| TYPE       | 类，接口，或enum的声明       |\n\n接下来将会学习编写注解解释器程序通过反射用于实现注解对应的功能。  \n未完待续～\n","slug":"annotation_learning","published":1,"updated":"2016-08-02T14:59:50.191Z","comments":1,"photos":[],"link":"","_id":"cirdlcvcd000d252ndzax0c8n","content":"<blockquote>\n<p>一直对java中的注解不是很了解，但是随处可见，前些天，一位朋友@徐文志程序猿在博客中写了关于PHP的注释，学习了很多，所以，也尝试着学习下java中的注解，并记录在这里，供以后复习，也便于大家共同学习。</p>\n</blockquote>\n<p>在开始之前，我墙裂给大家安利一种学习方式。思维导图，又称脑图，是能够将思维中抽象的逻辑关系转化为直观的关系图标的一种方式，在我们的学习中，可以将知识点通过思维导图梳理出来，非常有条理，还方便记忆，这篇文章中，我会尝试着用思维导图阐述我的学习过程。好了现在就开始干正事，切入正题吧。</p>\n<p>注解（Annotation）是java 5.0引入的新特性。它提供了一种结构化的类型检查的新途径。我们通过加入注解，能够避免很多问题，例如编写累赘的部署描述文件。与代码注释相比，它更注重与描述类的相关信息。</p>\n<h1 id=\"基本的语法\"><a href=\"#基本的语法\" class=\"headerlink\" title=\"基本的语法\"></a>基本的语法</h1><p>注解的语法还是比较简单的，除了多了@符号外，其他的和java的固有语法一致。<br>在java SE5 中就提供了三种原生的注解：</p>\n<ul>\n<li>@Override 表示当前的方法继承自父类，并且复写了父类的方法，如果被注解的方法在父类中不存在，编译器就会抛出异常。在java中，这个注解是可选的。</li>\n<li>@Deprecated 表示当前的方法已经被废弃，在编译时会有警告提示。</li>\n<li>@SuppressWarings 表示主动忽略不恰当的编译器警告。<br>此外，java 还提供了可扩展的annotation API。<br>下面的例子说明了注解的使用：  </li>\n</ul>\n<pre><code class=\"java\">public class Testable {\n    public void execute(){\n      System.out.println(&quot;Executing...&quot;);\n    }\n    @Test\n    void testExecute (){\n      execute();\n    }\n}\n</code></pre>\n<p>  <strong>@Test</strong> 注解本身不做任何的操作，但是，编译器在编译的时候，就必须找到关于该注解的定义，否则就会报错。下面的一小节将会介绍如何进行定义。</p>\n<h1 id=\"注解的定义\"><a href=\"#注解的定义\" class=\"headerlink\" title=\"注解的定义\"></a>注解的定义</h1><p>下面，我们就给出前文提到的@Test注解的定义：</p>\n<pre><code class=\"java\">import java.lang.annotation\n\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Test{}\n</code></pre>\n<p>这样，就定义了一个@Test的注解。我们可以看到，其实和接口的定义很像。不同的是，在定义注解时，我们需要一些<a href=\"#什么是元注解\">元注解</a>，如@Target，@Retention。其中：  </p>\n<ul>\n<li><strong>@Target</strong> 注解用来定义该注解的作用域，如作用于一个方法还是一个域。</li>\n<li><strong>@Retention</strong> 则定义了该注解在哪个级别可用，源代码（SOURCE）中、类文件（CLASS）中、运行时（RUNTIME）。<br>这类注解由于没有元素，被称为 <strong>标记注解（marker annotation）</strong>， 通常情况下，注解还会加上一些元素用于表示某些值。这些值用于编译器在分析和处理该注解时的参考。可以为这些元素指定默认值。<br>我们来看看元素的使用：  </li>\n</ul>\n<pre><code class=\"java\">@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface UseCase{\n  public int id();\n  public String description() default &quot;no description&quot;;\n}\n</code></pre>\n<p>这个@UserCase 注解就定义了两个元素，我们为description元素制定了默认值。如果使用该注解在注解某个方法时，没有给定描述字符，将会使用该默认值代替。下面我们接着看看如何使用该注解。</p>\n<h1 id=\"注解的使用\"><a href=\"#注解的使用\" class=\"headerlink\" title=\"注解的使用\"></a>注解的使用</h1><p>注解元素的使用过程中，是以键-值对的形式给出的。</p>\n<pre><code class=\"java\">public class PasswordUtils {\n  @UseCase(id= 1,description=&quot;Password must contain at least one numeric&quot;)\n  public boolean validataPassword(String password) {\n    return(password.mathes(&quot;\\\\w*\\\\d\\\\w*&quot;))\n  }\n\n  @UseCase(id=2)\n  public String encryptPassword(String password) {\n    return new StringBuffer(password).reverse().toString();\n  }\n\n  @UseCase(id=3,description=&quot;New password can&#39;t equal previously password&quot;)\n  public boolean checkForNewPassword(List&lt;String&gt; prePassWords, String password){\n    return !prePassWords.contains(password);\n  }\n\n}\n</code></pre>\n<h1 id=\"什么是元注解\"><a href=\"#什么是元注解\" class=\"headerlink\" title=\"什么是元注解\"></a>什么是元注解</h1><p>我们知道，万物是有源头的，就像我们的大千世界都是由原子构成的。元注解就是注解的源头，用于注解其他的注解。这句话有点绕，其实就是在我们定义注解的时候，使用元注解来定义该注解的作用域，使用级别，是否允许继承该注解等相关属性。如下表：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">元注解</th>\n<th style=\"text-align:left\">解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">@Target</td>\n<td style=\"text-align:left\">表示该注解可以用于什么地方</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">@Retention</td>\n<td style=\"text-align:left\">表示在什么级别保存该注解信息</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">@Documented</td>\n<td style=\"text-align:left\">将此注解包含在javaDoc中</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">@Inherited</td>\n<td style=\"text-align:left\">允许子类继承父类的注解</td>\n</tr>\n</tbody>\n</table>\n<p>其中@Target的取值有七种：  </p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">值</th>\n<th style=\"text-align:left\">解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">CONSTRUCTOR</td>\n<td style=\"text-align:left\">构造器的声明</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FIELD</td>\n<td style=\"text-align:left\">域声明（包括enum）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">LOCAL_VARIABLE</td>\n<td style=\"text-align:left\">局部变量的声明</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">METHOD</td>\n<td style=\"text-align:left\">方法的声明</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">PACKAGE</td>\n<td style=\"text-align:left\">包的声明</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">PARAMETER</td>\n<td style=\"text-align:left\">参数的声明</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">TYPE</td>\n<td style=\"text-align:left\">类，接口，或enum的声明</td>\n</tr>\n</tbody>\n</table>\n<p>接下来将会学习编写注解解释器程序通过反射用于实现注解对应的功能。<br>未完待续～</p>\n","excerpt":"","more":"<blockquote>\n<p>一直对java中的注解不是很了解，但是随处可见，前些天，一位朋友@徐文志程序猿在博客中写了关于PHP的注释，学习了很多，所以，也尝试着学习下java中的注解，并记录在这里，供以后复习，也便于大家共同学习。</p>\n</blockquote>\n<p>在开始之前，我墙裂给大家安利一种学习方式。思维导图，又称脑图，是能够将思维中抽象的逻辑关系转化为直观的关系图标的一种方式，在我们的学习中，可以将知识点通过思维导图梳理出来，非常有条理，还方便记忆，这篇文章中，我会尝试着用思维导图阐述我的学习过程。好了现在就开始干正事，切入正题吧。</p>\n<p>注解（Annotation）是java 5.0引入的新特性。它提供了一种结构化的类型检查的新途径。我们通过加入注解，能够避免很多问题，例如编写累赘的部署描述文件。与代码注释相比，它更注重与描述类的相关信息。</p>\n<h1 id=\"基本的语法\"><a href=\"#基本的语法\" class=\"headerlink\" title=\"基本的语法\"></a>基本的语法</h1><p>注解的语法还是比较简单的，除了多了@符号外，其他的和java的固有语法一致。<br>在java SE5 中就提供了三种原生的注解：</p>\n<ul>\n<li>@Override 表示当前的方法继承自父类，并且复写了父类的方法，如果被注解的方法在父类中不存在，编译器就会抛出异常。在java中，这个注解是可选的。</li>\n<li>@Deprecated 表示当前的方法已经被废弃，在编译时会有警告提示。</li>\n<li>@SuppressWarings 表示主动忽略不恰当的编译器警告。<br>此外，java 还提供了可扩展的annotation API。<br>下面的例子说明了注解的使用：  </li>\n</ul>\n<pre><code class=\"java\">public class Testable {\n    public void execute(){\n      System.out.println(&quot;Executing...&quot;);\n    }\n    @Test\n    void testExecute (){\n      execute();\n    }\n}\n</code></pre>\n<p>  <strong>@Test</strong> 注解本身不做任何的操作，但是，编译器在编译的时候，就必须找到关于该注解的定义，否则就会报错。下面的一小节将会介绍如何进行定义。</p>\n<h1 id=\"注解的定义\"><a href=\"#注解的定义\" class=\"headerlink\" title=\"注解的定义\"></a>注解的定义</h1><p>下面，我们就给出前文提到的@Test注解的定义：</p>\n<pre><code class=\"java\">import java.lang.annotation\n\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Test{}\n</code></pre>\n<p>这样，就定义了一个@Test的注解。我们可以看到，其实和接口的定义很像。不同的是，在定义注解时，我们需要一些<a href=\"#什么是元注解\">元注解</a>，如@Target，@Retention。其中：  </p>\n<ul>\n<li><strong>@Target</strong> 注解用来定义该注解的作用域，如作用于一个方法还是一个域。</li>\n<li><strong>@Retention</strong> 则定义了该注解在哪个级别可用，源代码（SOURCE）中、类文件（CLASS）中、运行时（RUNTIME）。<br>这类注解由于没有元素，被称为 <strong>标记注解（marker annotation）</strong>， 通常情况下，注解还会加上一些元素用于表示某些值。这些值用于编译器在分析和处理该注解时的参考。可以为这些元素指定默认值。<br>我们来看看元素的使用：  </li>\n</ul>\n<pre><code class=\"java\">@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface UseCase{\n  public int id();\n  public String description() default &quot;no description&quot;;\n}\n</code></pre>\n<p>这个@UserCase 注解就定义了两个元素，我们为description元素制定了默认值。如果使用该注解在注解某个方法时，没有给定描述字符，将会使用该默认值代替。下面我们接着看看如何使用该注解。</p>\n<h1 id=\"注解的使用\"><a href=\"#注解的使用\" class=\"headerlink\" title=\"注解的使用\"></a>注解的使用</h1><p>注解元素的使用过程中，是以键-值对的形式给出的。</p>\n<pre><code class=\"java\">public class PasswordUtils {\n  @UseCase(id= 1,description=&quot;Password must contain at least one numeric&quot;)\n  public boolean validataPassword(String password) {\n    return(password.mathes(&quot;\\\\w*\\\\d\\\\w*&quot;))\n  }\n\n  @UseCase(id=2)\n  public String encryptPassword(String password) {\n    return new StringBuffer(password).reverse().toString();\n  }\n\n  @UseCase(id=3,description=&quot;New password can&#39;t equal previously password&quot;)\n  public boolean checkForNewPassword(List&lt;String&gt; prePassWords, String password){\n    return !prePassWords.contains(password);\n  }\n\n}\n</code></pre>\n<h1 id=\"什么是元注解\"><a href=\"#什么是元注解\" class=\"headerlink\" title=\"什么是元注解\"></a>什么是元注解</h1><p>我们知道，万物是有源头的，就像我们的大千世界都是由原子构成的。元注解就是注解的源头，用于注解其他的注解。这句话有点绕，其实就是在我们定义注解的时候，使用元注解来定义该注解的作用域，使用级别，是否允许继承该注解等相关属性。如下表：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">元注解</th>\n<th style=\"text-align:left\">解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">@Target</td>\n<td style=\"text-align:left\">表示该注解可以用于什么地方</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">@Retention</td>\n<td style=\"text-align:left\">表示在什么级别保存该注解信息</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">@Documented</td>\n<td style=\"text-align:left\">将此注解包含在javaDoc中</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">@Inherited</td>\n<td style=\"text-align:left\">允许子类继承父类的注解</td>\n</tr>\n</tbody>\n</table>\n<p>其中@Target的取值有七种：  </p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">值</th>\n<th style=\"text-align:left\">解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">CONSTRUCTOR</td>\n<td style=\"text-align:left\">构造器的声明</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FIELD</td>\n<td style=\"text-align:left\">域声明（包括enum）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">LOCAL_VARIABLE</td>\n<td style=\"text-align:left\">局部变量的声明</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">METHOD</td>\n<td style=\"text-align:left\">方法的声明</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">PACKAGE</td>\n<td style=\"text-align:left\">包的声明</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">PARAMETER</td>\n<td style=\"text-align:left\">参数的声明</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">TYPE</td>\n<td style=\"text-align:left\">类，接口，或enum的声明</td>\n</tr>\n</tbody>\n</table>\n<p>接下来将会学习编写注解解释器程序通过反射用于实现注解对应的功能。<br>未完待续～</p>\n"},{"layout":"post","title":"envsetup-sh的常用命令","subtitle":" Android开源项目编译中sh的常用命令","date":"2016-03-10T01:22:04.000Z","author":"JianGuo Yang","header-img":"post-bg-unix-linux.jpg","_content":"\n# envsetup-sh的常用命令\n\n** 摘要：** 这篇文档主要对android下的编译脚本文件 envsetup.sh 进行了简单的分析，并且从中总结了一些在开发过程中常用的命令，以便于开发者们提高开发效率。\n\n## 常用命令索引\n` croot `  - -到达android根目录；\n` cproj + 模块名 `  - -到达项目的根目录下；\n` gettop `  - -得到顶级目录路径；\n` findmakefile ` - -找到make文件。\n\n` m ` - -当前目录下编译执行，相当于在android目录下执行make\n` mm ` - -执行当前目录下最近的make文件\n` mmm `  - -在android目录下，执行某个文件夹下的make文件\n` mma ` - -编译当前目录下所有的模块和他们的依赖\n` mmma ` - -编译提供的目录下的所有模块和他们的依赖\n` make sdk ` - -编译SDK及其包含的一些工具 (adb, fastboot, 等等)。\n` make snod `  - -从当前编译出的二进制数据编译system.img文件 ，这条命令将重新生成镜像，消耗的时间很少，如果你修改了一些数据文件（如音乐、视频）等文件时比较有用。\n` make cts `  - -这条命令将编译CTS套机，编译出的结果放在out目录对应版的data/app目录下面。CTS测试时有用。\n` make services ` - -\n` make runtime ` - -\n` make droid ` - -make droid is the normal build.\n` make all ` - -make everything, whether it is included in the product definition or not\n` make clean ` - -remove all built files (prepare for a new build). Same as rm -rf out _make modules - shows a list of submodules that can be built (List of all LOCAL_MODULE definitions)\n` make installclean `  - -同上\n` make *` - -make a specific module (note that this is not the same as directory name. It is the LOCAL_MODULE definition in the Android.mk file)\n` make clean *`  - -clean a specific module\n` make bootimage ` - -编译创建一个新的 boot image\n` make bootimage `  - -TARGET_PREBUILT_KERNEL=/path/to/bzImage - create a new boot image with custom bzImage\n` make systemimage ` - -编译创建一个新的 system image\n\n## make命令\n\n不用多解释，编译整个项目，可以加模块名参数等。\n\n``` bash\nfunction make()\n{\n    local start_time=$(date +\"%s\")\n    $(get_make_command) \"$@\"\n    local ret=$?\n    local end_time=$(date +\"%s\")\n    local tdiff=$(($end_time-$start_time))\n    local hours=$(($tdiff / 3600 ))\n    local mins=$((($tdiff % 3600) / 60))\n    local secs=$(($tdiff % 60))\n    echo\n    if [ $ret -eq 0 ] ; then\n        echo -n -e \"#### make completed successfully \"\n    else\n        echo -n -e \"#### make failed to build some targets \"\n    fi\n    if [ $hours -gt 0 ] ; then\n        printf \"(%02g:%02g:%02g (hh:mm:ss))\" $hours $mins $secs\n    elif [ $mins -gt 0 ] ; then\n        printf \"(%02g:%02g (mm:ss))\" $mins $secs\n    elif [ $secs -gt 0 ] ; then\n        printf \"(%s seconds)\" $secs\n    fi\n    echo -e \" ####\"\n    echo\n    return $ret\n}\n\n```\n\n> **提示：**具体功能还需要分析。\n\n## 设置编译环境的java home\n```bash\n# Force JAVA_HOME to point to java 1.7 or java 1.6  if it isn't already set.\n#\n# Note that the MacOS path for java 1.7 includes a minor revision number (sigh).\n# For some reason, installing the JDK doesn't make it show up in the\n# JavaVM.framework/Versions/1.7/ folder.\nfunction set_java_home() {\n    # Clear the existing JAVA_HOME value if we set it ourselves, so that\n    # we can reset it later, depending on the version of java the build\n    # system needs.\n    #\n    # If we don't do this, the JAVA_HOME value set by the first call to\n    # build/envsetup.sh will persist forever.\n    if [ -n \"$ANDROID_SET_JAVA_HOME\" ]; then\n      export JAVA_HOME=\"\"\n    fi\n\n    if [ ! \"$JAVA_HOME\" ]; then\n      if [ -n \"$LEGACY_USE_JAVA6\" ]; then\n        case `uname -s` in\n            Darwin)\n                export JAVA_HOME=/System/Library/Frameworks/JavaVM.framework/Versions/1.6/Home\n                ;;\n            *)\n                export JAVA_HOME=/usr/lib/jvm/java-6-sun\n                ;;\n        esac\n      else\n        case `uname -s` in\n            Darwin)\n                export JAVA_HOME=$(/usr/libexec/java_home -v 1.7)\n                ;;\n            *)\n                export JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64\n                ;;\n        esac\n      fi\n\n      # Keep track of the fact that we set JAVA_HOME ourselves, so that\n      # we can change it on the next envsetup.sh, if required.\n      export ANDROID_SET_JAVA_HOME=true\n    fi\n}\n\n```\n\n## 到某个文件所在的目录下\n```bash\nfunction godir () {\n    if [[ -z \"$1\" ]]; then\n        echo \"Usage: godir <regex>\"\n        return\n    fi\n    T=$(gettop)\n    if [[ ! -f $T/filelist ]]; then\n        echo -n \"Creating index...\"\n        (\\cd $T; find . -wholename ./out -prune -o -wholename ./.repo -prune -o -type f > filelist)\n        echo \" Done\"\n        echo \"\"\n    fi\n    local lines\n    lines=($(\\grep \"$1\" $T/filelist | sed -e 's/\\/[^/]*$//' | sort | uniq))\n    if [[ ${#lines[@]} = 0 ]]; then\n        echo \"Not found\"\n        return\n    fi\n    local pathname\n    local choice\n    if [[ ${#lines[@]} > 1 ]]; then\n        while [[ -z \"$pathname\" ]]; do\n            local index=1\n            local line\n            for line in ${lines[@]}; do\n                printf \"%6s %s\\n\" \"[$index]\" $line\n                index=$(($index + 1))\n            done\n            echo\n            echo -n \"Select one: \"\n            unset choice\n            read choice\n            if [[ $choice -gt ${#lines[@]} || $choice -lt 1 ]]; then\n                echo \"Invalid choice\"\n                continue\n            fi\n            pathname=${lines[$(($choice-1))]}\n        done\n    else\n        pathname=${lines[0]}\n    fi\n    \\cd $T/$pathname\n}\n\n```\n\n\n## 具体参数查看runtest -h\n```bash\n# simple shortcut to the runtest command\nfunction runtest()\n{\n    T=$(gettop)\n    if [ ! \"$T\" ]; then\n        echo \"Couldn't locate the top of the tree.  Try setting TOP.\" >&2\n        return\n    fi\n    (\"$T\"/development/testrunner/runtest.py $@)\n}\n```\n\n## smoketest\n```bash\nfunction smoketest()\n{\n    if [ ! \"$ANDROID_PRODUCT_OUT\" ]; then\n        echo \"Couldn't locate output files.  Try running 'lunch' first.\" >&2\n        return\n    fi\n    T=$(gettop)\n    if [ ! \"$T\" ]; then\n        echo \"Couldn't locate the top of the tree.  Try setting TOP.\" >&2\n        return\n    fi\n\n    (\\cd \"$T\" && mmm tests/SmokeTest) &&\n      adb uninstall com.android.smoketest > /dev/null &&\n      adb uninstall com.android.smoketest.tests > /dev/null &&\n      adb install $ANDROID_PRODUCT_OUT/data/app/SmokeTestApp.apk &&\n      adb install $ANDROID_PRODUCT_OUT/data/app/SmokeTest.apk &&\n      adb shell am instrument -w com.android.smoketest.tests/android.test.InstrumentationTestRunner\n}\n\n```\n\n## 常用的安卓物理键模拟及viewserver\n```bash\n# 开启viewServer\nfunction startviewserver()\n{\n    local port=4939\n    if [ $# -gt 0 ]; then\n            port=$1\n    fi\n    adb shell service call window 1 i32 $port\n}\n# 停止viewServer\nfunction stopviewserver()\n{\n    adb shell service call window 2\n}\n# 查看viewServer状态\nfunction isviewserverstarted()\n{\n    adb shell service call window 3\n}\n# 相当于按下设备home键、back键、menu键\nfunction key_home()\nfunction key_back()\nfunction key_menu()\n```\n\n##获取手机中的bug日志\n```bash\nfunction getbugreports()\n{\n    local reports=(`adb shell ls /sdcard/bugreports | tr -d '\\r'`)\n\n    if [ ! \"$reports\" ]; then\n        echo \"Could not locate any bugreports.\"\n        return\n    fi\n\n    local report\n    for report in ${reports[@]}\n    do\n        echo \"/sdcard/bugreports/${report}\"\n        adb pull /sdcard/bugreports/${report} ${report}\n        gunzip ${report}\n    done\n}\n```\n\n\n## 得到sdcard的路径，屏幕截图路径和最后一张截图\n```bash\nfunction getsdcardpath()\nfunction getscreenshotpath()\nfunction getlastscreenshot()\n```\n\n\n## dump某一时刻的trace数据\n```bash\nfunction tracedmdump()\n{\n    T=$(gettop)\n    if [ ! \"$T\" ]; then\n        echo \"Couldn't locate the top of the tree.  Try setting TOP.\"\n        return\n    fi\n    local prebuiltdir=$(getprebuilt)\n    local arch=$(gettargetarch)\n    local KERNEL=$T/prebuilts/qemu-kernel/$arch/vmlinux-qemu\n\n    local TRACE=$1\n    if [ ! \"$TRACE\" ] ; then\n        echo \"usage:  tracedmdump  tracename\"\n        return\n    fi\n\n    if [ ! -r \"$KERNEL\" ] ; then\n        echo \"Error: cannot find kernel: '$KERNEL'\"\n        return\n    fi\n\n    local BASETRACE=$(basename $TRACE)\n    if [ \"$BASETRACE\" = \"$TRACE\" ] ; then\n        TRACE=$ANDROID_PRODUCT_OUT/traces/$TRACE\n    fi\n\n    echo \"post-processing traces...\"\n    rm -f $TRACE/qtrace.dexlist\n    post_trace $TRACE\n    if [ $? -ne 0 ]; then\n        echo \"***\"\n        echo \"*** Error: malformed trace.  Did you remember to exit the emulator?\"\n        echo \"***\"\n        return\n    fi\n    echo \"generating dexlist output...\"\n    /bin/ls $ANDROID_PRODUCT_OUT/system/framework/*.jar $ANDROID_PRODUCT_OUT/system/app/*.apk $ANDROID_PRODUCT_OUT/data/app/*.apk 2>/dev/null | xargs dexlist > $TRACE/qtrace.dexlist\n    echo \"generating dmtrace data...\"\n    q2dm -r $ANDROID_PRODUCT_OUT/symbols $TRACE $KERNEL $TRACE/dmtrace || return\n    echo \"generating html file...\"\n    dmtracedump -h $TRACE/dmtrace >| $TRACE/dmtrace.html || return\n    echo \"done, see $TRACE/dmtrace.html for details\"\n    echo \"or run:\"\n    echo \"    traceview $TRACE/dmtrace\"\n}\n```\n\n\n## 查询.gradle、.java 等文件中某个字符串在文件中的位置\n```bash\nfunction ggrep()\n{\n    find . -name .repo -prune -o -name .git -prune -o -name out -prune -o -type f -name \"*\\.gradle\" -print0 | xargs -0 grep --color -n \"$@\"\n}\nfunction jgrep()\n{\n    find . -name .repo -prune -o -name .git -prune -o -name out -prune -o -type f -name \"*\\.java\" -print0 | xargs -0 grep --color -n \"$@\"\n}\nfunction cgrep()\n{\n    find . -name .repo -prune -o -name .git -prune -o -name out -prune -o -type f \\( -name '*.c' -o -name '*.cc' -o -name '*.cpp' -o -name '*.h' \\) -print0 | xargs -0 grep --color -n \"$@\"\n}\nfunction resgrep()\n{\n    for dir in `find . -name .repo -prune -o -name .git -prune -o -name out -prune -o -name res -type d`; do find $dir -type f -name '*\\.xml' -print0 | xargs -0 grep --color -n \"$@\"; done;\n}\nfunction mangrep()\n{\n    find . -name .repo -prune -o -name .git -prune -o -path ./out -prune -o -type f -name 'AndroidManifest.xml' -print0 | xargs -0 grep --color -n \"$@\"\n}\nfunction sepgrep()\n{\n    find . -name .repo -prune -o -name .git -prune -o -path ./out -prune -o -name sepolicy -type d -print0 | xargs -0 grep --color -n -r --exclude-dir=\\.git \"$@\"\n}\n```\n\n\n## 其他\n```bash\n# 得到顶级目录路径\nfunction gettop\n# 找到make文件\nfunction findmakefile()\n# 当前目录下编译执行，相当于在android目录下执行make\nfunction m()\n# 执行当前目录下最近的make文件\nfunction mm()\n# 在android目录下，执行某个文件夹下的make文件\nfunction mmm()\n# Builds all of the modules in the current directory, and their dependencies.\nfunction mma()\n# Builds all of the modules in the supplied directories, and their dependencies.\nfunction mmma()\n```\n","source":"_posts/envsetup_common_command.md","raw":"---\nlayout:     post\ntitle: envsetup-sh的常用命令\nsubtitle:   \" Android开源项目编译中sh的常用命令\"\ndate: 2016-03-10 09:22:04\nauthor:     \"JianGuo Yang\"\nheader-img: \"post-bg-unix-linux.jpg\"\ntags: Android\n---\n\n# envsetup-sh的常用命令\n\n** 摘要：** 这篇文档主要对android下的编译脚本文件 envsetup.sh 进行了简单的分析，并且从中总结了一些在开发过程中常用的命令，以便于开发者们提高开发效率。\n\n## 常用命令索引\n` croot `  - -到达android根目录；\n` cproj + 模块名 `  - -到达项目的根目录下；\n` gettop `  - -得到顶级目录路径；\n` findmakefile ` - -找到make文件。\n\n` m ` - -当前目录下编译执行，相当于在android目录下执行make\n` mm ` - -执行当前目录下最近的make文件\n` mmm `  - -在android目录下，执行某个文件夹下的make文件\n` mma ` - -编译当前目录下所有的模块和他们的依赖\n` mmma ` - -编译提供的目录下的所有模块和他们的依赖\n` make sdk ` - -编译SDK及其包含的一些工具 (adb, fastboot, 等等)。\n` make snod `  - -从当前编译出的二进制数据编译system.img文件 ，这条命令将重新生成镜像，消耗的时间很少，如果你修改了一些数据文件（如音乐、视频）等文件时比较有用。\n` make cts `  - -这条命令将编译CTS套机，编译出的结果放在out目录对应版的data/app目录下面。CTS测试时有用。\n` make services ` - -\n` make runtime ` - -\n` make droid ` - -make droid is the normal build.\n` make all ` - -make everything, whether it is included in the product definition or not\n` make clean ` - -remove all built files (prepare for a new build). Same as rm -rf out _make modules - shows a list of submodules that can be built (List of all LOCAL_MODULE definitions)\n` make installclean `  - -同上\n` make *` - -make a specific module (note that this is not the same as directory name. It is the LOCAL_MODULE definition in the Android.mk file)\n` make clean *`  - -clean a specific module\n` make bootimage ` - -编译创建一个新的 boot image\n` make bootimage `  - -TARGET_PREBUILT_KERNEL=/path/to/bzImage - create a new boot image with custom bzImage\n` make systemimage ` - -编译创建一个新的 system image\n\n## make命令\n\n不用多解释，编译整个项目，可以加模块名参数等。\n\n``` bash\nfunction make()\n{\n    local start_time=$(date +\"%s\")\n    $(get_make_command) \"$@\"\n    local ret=$?\n    local end_time=$(date +\"%s\")\n    local tdiff=$(($end_time-$start_time))\n    local hours=$(($tdiff / 3600 ))\n    local mins=$((($tdiff % 3600) / 60))\n    local secs=$(($tdiff % 60))\n    echo\n    if [ $ret -eq 0 ] ; then\n        echo -n -e \"#### make completed successfully \"\n    else\n        echo -n -e \"#### make failed to build some targets \"\n    fi\n    if [ $hours -gt 0 ] ; then\n        printf \"(%02g:%02g:%02g (hh:mm:ss))\" $hours $mins $secs\n    elif [ $mins -gt 0 ] ; then\n        printf \"(%02g:%02g (mm:ss))\" $mins $secs\n    elif [ $secs -gt 0 ] ; then\n        printf \"(%s seconds)\" $secs\n    fi\n    echo -e \" ####\"\n    echo\n    return $ret\n}\n\n```\n\n> **提示：**具体功能还需要分析。\n\n## 设置编译环境的java home\n```bash\n# Force JAVA_HOME to point to java 1.7 or java 1.6  if it isn't already set.\n#\n# Note that the MacOS path for java 1.7 includes a minor revision number (sigh).\n# For some reason, installing the JDK doesn't make it show up in the\n# JavaVM.framework/Versions/1.7/ folder.\nfunction set_java_home() {\n    # Clear the existing JAVA_HOME value if we set it ourselves, so that\n    # we can reset it later, depending on the version of java the build\n    # system needs.\n    #\n    # If we don't do this, the JAVA_HOME value set by the first call to\n    # build/envsetup.sh will persist forever.\n    if [ -n \"$ANDROID_SET_JAVA_HOME\" ]; then\n      export JAVA_HOME=\"\"\n    fi\n\n    if [ ! \"$JAVA_HOME\" ]; then\n      if [ -n \"$LEGACY_USE_JAVA6\" ]; then\n        case `uname -s` in\n            Darwin)\n                export JAVA_HOME=/System/Library/Frameworks/JavaVM.framework/Versions/1.6/Home\n                ;;\n            *)\n                export JAVA_HOME=/usr/lib/jvm/java-6-sun\n                ;;\n        esac\n      else\n        case `uname -s` in\n            Darwin)\n                export JAVA_HOME=$(/usr/libexec/java_home -v 1.7)\n                ;;\n            *)\n                export JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64\n                ;;\n        esac\n      fi\n\n      # Keep track of the fact that we set JAVA_HOME ourselves, so that\n      # we can change it on the next envsetup.sh, if required.\n      export ANDROID_SET_JAVA_HOME=true\n    fi\n}\n\n```\n\n## 到某个文件所在的目录下\n```bash\nfunction godir () {\n    if [[ -z \"$1\" ]]; then\n        echo \"Usage: godir <regex>\"\n        return\n    fi\n    T=$(gettop)\n    if [[ ! -f $T/filelist ]]; then\n        echo -n \"Creating index...\"\n        (\\cd $T; find . -wholename ./out -prune -o -wholename ./.repo -prune -o -type f > filelist)\n        echo \" Done\"\n        echo \"\"\n    fi\n    local lines\n    lines=($(\\grep \"$1\" $T/filelist | sed -e 's/\\/[^/]*$//' | sort | uniq))\n    if [[ ${#lines[@]} = 0 ]]; then\n        echo \"Not found\"\n        return\n    fi\n    local pathname\n    local choice\n    if [[ ${#lines[@]} > 1 ]]; then\n        while [[ -z \"$pathname\" ]]; do\n            local index=1\n            local line\n            for line in ${lines[@]}; do\n                printf \"%6s %s\\n\" \"[$index]\" $line\n                index=$(($index + 1))\n            done\n            echo\n            echo -n \"Select one: \"\n            unset choice\n            read choice\n            if [[ $choice -gt ${#lines[@]} || $choice -lt 1 ]]; then\n                echo \"Invalid choice\"\n                continue\n            fi\n            pathname=${lines[$(($choice-1))]}\n        done\n    else\n        pathname=${lines[0]}\n    fi\n    \\cd $T/$pathname\n}\n\n```\n\n\n## 具体参数查看runtest -h\n```bash\n# simple shortcut to the runtest command\nfunction runtest()\n{\n    T=$(gettop)\n    if [ ! \"$T\" ]; then\n        echo \"Couldn't locate the top of the tree.  Try setting TOP.\" >&2\n        return\n    fi\n    (\"$T\"/development/testrunner/runtest.py $@)\n}\n```\n\n## smoketest\n```bash\nfunction smoketest()\n{\n    if [ ! \"$ANDROID_PRODUCT_OUT\" ]; then\n        echo \"Couldn't locate output files.  Try running 'lunch' first.\" >&2\n        return\n    fi\n    T=$(gettop)\n    if [ ! \"$T\" ]; then\n        echo \"Couldn't locate the top of the tree.  Try setting TOP.\" >&2\n        return\n    fi\n\n    (\\cd \"$T\" && mmm tests/SmokeTest) &&\n      adb uninstall com.android.smoketest > /dev/null &&\n      adb uninstall com.android.smoketest.tests > /dev/null &&\n      adb install $ANDROID_PRODUCT_OUT/data/app/SmokeTestApp.apk &&\n      adb install $ANDROID_PRODUCT_OUT/data/app/SmokeTest.apk &&\n      adb shell am instrument -w com.android.smoketest.tests/android.test.InstrumentationTestRunner\n}\n\n```\n\n## 常用的安卓物理键模拟及viewserver\n```bash\n# 开启viewServer\nfunction startviewserver()\n{\n    local port=4939\n    if [ $# -gt 0 ]; then\n            port=$1\n    fi\n    adb shell service call window 1 i32 $port\n}\n# 停止viewServer\nfunction stopviewserver()\n{\n    adb shell service call window 2\n}\n# 查看viewServer状态\nfunction isviewserverstarted()\n{\n    adb shell service call window 3\n}\n# 相当于按下设备home键、back键、menu键\nfunction key_home()\nfunction key_back()\nfunction key_menu()\n```\n\n##获取手机中的bug日志\n```bash\nfunction getbugreports()\n{\n    local reports=(`adb shell ls /sdcard/bugreports | tr -d '\\r'`)\n\n    if [ ! \"$reports\" ]; then\n        echo \"Could not locate any bugreports.\"\n        return\n    fi\n\n    local report\n    for report in ${reports[@]}\n    do\n        echo \"/sdcard/bugreports/${report}\"\n        adb pull /sdcard/bugreports/${report} ${report}\n        gunzip ${report}\n    done\n}\n```\n\n\n## 得到sdcard的路径，屏幕截图路径和最后一张截图\n```bash\nfunction getsdcardpath()\nfunction getscreenshotpath()\nfunction getlastscreenshot()\n```\n\n\n## dump某一时刻的trace数据\n```bash\nfunction tracedmdump()\n{\n    T=$(gettop)\n    if [ ! \"$T\" ]; then\n        echo \"Couldn't locate the top of the tree.  Try setting TOP.\"\n        return\n    fi\n    local prebuiltdir=$(getprebuilt)\n    local arch=$(gettargetarch)\n    local KERNEL=$T/prebuilts/qemu-kernel/$arch/vmlinux-qemu\n\n    local TRACE=$1\n    if [ ! \"$TRACE\" ] ; then\n        echo \"usage:  tracedmdump  tracename\"\n        return\n    fi\n\n    if [ ! -r \"$KERNEL\" ] ; then\n        echo \"Error: cannot find kernel: '$KERNEL'\"\n        return\n    fi\n\n    local BASETRACE=$(basename $TRACE)\n    if [ \"$BASETRACE\" = \"$TRACE\" ] ; then\n        TRACE=$ANDROID_PRODUCT_OUT/traces/$TRACE\n    fi\n\n    echo \"post-processing traces...\"\n    rm -f $TRACE/qtrace.dexlist\n    post_trace $TRACE\n    if [ $? -ne 0 ]; then\n        echo \"***\"\n        echo \"*** Error: malformed trace.  Did you remember to exit the emulator?\"\n        echo \"***\"\n        return\n    fi\n    echo \"generating dexlist output...\"\n    /bin/ls $ANDROID_PRODUCT_OUT/system/framework/*.jar $ANDROID_PRODUCT_OUT/system/app/*.apk $ANDROID_PRODUCT_OUT/data/app/*.apk 2>/dev/null | xargs dexlist > $TRACE/qtrace.dexlist\n    echo \"generating dmtrace data...\"\n    q2dm -r $ANDROID_PRODUCT_OUT/symbols $TRACE $KERNEL $TRACE/dmtrace || return\n    echo \"generating html file...\"\n    dmtracedump -h $TRACE/dmtrace >| $TRACE/dmtrace.html || return\n    echo \"done, see $TRACE/dmtrace.html for details\"\n    echo \"or run:\"\n    echo \"    traceview $TRACE/dmtrace\"\n}\n```\n\n\n## 查询.gradle、.java 等文件中某个字符串在文件中的位置\n```bash\nfunction ggrep()\n{\n    find . -name .repo -prune -o -name .git -prune -o -name out -prune -o -type f -name \"*\\.gradle\" -print0 | xargs -0 grep --color -n \"$@\"\n}\nfunction jgrep()\n{\n    find . -name .repo -prune -o -name .git -prune -o -name out -prune -o -type f -name \"*\\.java\" -print0 | xargs -0 grep --color -n \"$@\"\n}\nfunction cgrep()\n{\n    find . -name .repo -prune -o -name .git -prune -o -name out -prune -o -type f \\( -name '*.c' -o -name '*.cc' -o -name '*.cpp' -o -name '*.h' \\) -print0 | xargs -0 grep --color -n \"$@\"\n}\nfunction resgrep()\n{\n    for dir in `find . -name .repo -prune -o -name .git -prune -o -name out -prune -o -name res -type d`; do find $dir -type f -name '*\\.xml' -print0 | xargs -0 grep --color -n \"$@\"; done;\n}\nfunction mangrep()\n{\n    find . -name .repo -prune -o -name .git -prune -o -path ./out -prune -o -type f -name 'AndroidManifest.xml' -print0 | xargs -0 grep --color -n \"$@\"\n}\nfunction sepgrep()\n{\n    find . -name .repo -prune -o -name .git -prune -o -path ./out -prune -o -name sepolicy -type d -print0 | xargs -0 grep --color -n -r --exclude-dir=\\.git \"$@\"\n}\n```\n\n\n## 其他\n```bash\n# 得到顶级目录路径\nfunction gettop\n# 找到make文件\nfunction findmakefile()\n# 当前目录下编译执行，相当于在android目录下执行make\nfunction m()\n# 执行当前目录下最近的make文件\nfunction mm()\n# 在android目录下，执行某个文件夹下的make文件\nfunction mmm()\n# Builds all of the modules in the current directory, and their dependencies.\nfunction mma()\n# Builds all of the modules in the supplied directories, and their dependencies.\nfunction mmma()\n```\n","slug":"envsetup_common_command","published":1,"updated":"2016-07-28T12:15:26.980Z","comments":1,"photos":[],"link":"","_id":"cirdlcvch000e252n4mk211y2","content":"<h1 id=\"envsetup-sh的常用命令\"><a href=\"#envsetup-sh的常用命令\" class=\"headerlink\" title=\"envsetup-sh的常用命令\"></a>envsetup-sh的常用命令</h1><p><strong> 摘要：</strong> 这篇文档主要对android下的编译脚本文件 envsetup.sh 进行了简单的分析，并且从中总结了一些在开发过程中常用的命令，以便于开发者们提高开发效率。</p>\n<h2 id=\"常用命令索引\"><a href=\"#常用命令索引\" class=\"headerlink\" title=\"常用命令索引\"></a>常用命令索引</h2><p><code>croot</code>  - -到达android根目录；<br><code>cproj + 模块名</code>  - -到达项目的根目录下；<br><code>gettop</code>  - -得到顶级目录路径；<br><code>findmakefile</code> - -找到make文件。</p>\n<p><code>m</code> - -当前目录下编译执行，相当于在android目录下执行make<br><code>mm</code> - -执行当前目录下最近的make文件<br><code>mmm</code>  - -在android目录下，执行某个文件夹下的make文件<br><code>mma</code> - -编译当前目录下所有的模块和他们的依赖<br><code>mmma</code> - -编译提供的目录下的所有模块和他们的依赖<br><code>make sdk</code> - -编译SDK及其包含的一些工具 (adb, fastboot, 等等)。<br><code>make snod</code>  - -从当前编译出的二进制数据编译system.img文件 ，这条命令将重新生成镜像，消耗的时间很少，如果你修改了一些数据文件（如音乐、视频）等文件时比较有用。<br><code>make cts</code>  - -这条命令将编译CTS套机，编译出的结果放在out目录对应版的data/app目录下面。CTS测试时有用。<br><code>make services</code> - -<br><code>make runtime</code> - -<br><code>make droid</code> - -make droid is the normal build.<br><code>make all</code> - -make everything, whether it is included in the product definition or not<br><code>make clean</code> - -remove all built files (prepare for a new build). Same as rm -rf out _make modules - shows a list of submodules that can be built (List of all LOCAL_MODULE definitions)<br><code>make installclean</code>  - -同上<br><code>make *</code> - -make a specific module (note that this is not the same as directory name. It is the LOCAL_MODULE definition in the Android.mk file)<br><code>make clean *</code>  - -clean a specific module<br><code>make bootimage</code> - -编译创建一个新的 boot image<br><code>make bootimage</code>  - -TARGET_PREBUILT_KERNEL=/path/to/bzImage - create a new boot image with custom bzImage<br><code>make systemimage</code> - -编译创建一个新的 system image</p>\n<h2 id=\"make命令\"><a href=\"#make命令\" class=\"headerlink\" title=\"make命令\"></a>make命令</h2><p>不用多解释，编译整个项目，可以加模块名参数等。</p>\n<pre><code class=\"bash\">function make()\n{\n    local start_time=$(date +&quot;%s&quot;)\n    $(get_make_command) &quot;$@&quot;\n    local ret=$?\n    local end_time=$(date +&quot;%s&quot;)\n    local tdiff=$(($end_time-$start_time))\n    local hours=$(($tdiff / 3600 ))\n    local mins=$((($tdiff % 3600) / 60))\n    local secs=$(($tdiff % 60))\n    echo\n    if [ $ret -eq 0 ] ; then\n        echo -n -e &quot;#### make completed successfully &quot;\n    else\n        echo -n -e &quot;#### make failed to build some targets &quot;\n    fi\n    if [ $hours -gt 0 ] ; then\n        printf &quot;(%02g:%02g:%02g (hh:mm:ss))&quot; $hours $mins $secs\n    elif [ $mins -gt 0 ] ; then\n        printf &quot;(%02g:%02g (mm:ss))&quot; $mins $secs\n    elif [ $secs -gt 0 ] ; then\n        printf &quot;(%s seconds)&quot; $secs\n    fi\n    echo -e &quot; ####&quot;\n    echo\n    return $ret\n}\n</code></pre>\n<blockquote>\n<p><strong>提示：</strong>具体功能还需要分析。</p>\n</blockquote>\n<h2 id=\"设置编译环境的java-home\"><a href=\"#设置编译环境的java-home\" class=\"headerlink\" title=\"设置编译环境的java home\"></a>设置编译环境的java home</h2><pre><code class=\"bash\"># Force JAVA_HOME to point to java 1.7 or java 1.6  if it isn&#39;t already set.\n#\n# Note that the MacOS path for java 1.7 includes a minor revision number (sigh).\n# For some reason, installing the JDK doesn&#39;t make it show up in the\n# JavaVM.framework/Versions/1.7/ folder.\nfunction set_java_home() {\n    # Clear the existing JAVA_HOME value if we set it ourselves, so that\n    # we can reset it later, depending on the version of java the build\n    # system needs.\n    #\n    # If we don&#39;t do this, the JAVA_HOME value set by the first call to\n    # build/envsetup.sh will persist forever.\n    if [ -n &quot;$ANDROID_SET_JAVA_HOME&quot; ]; then\n      export JAVA_HOME=&quot;&quot;\n    fi\n\n    if [ ! &quot;$JAVA_HOME&quot; ]; then\n      if [ -n &quot;$LEGACY_USE_JAVA6&quot; ]; then\n        case `uname -s` in\n            Darwin)\n                export JAVA_HOME=/System/Library/Frameworks/JavaVM.framework/Versions/1.6/Home\n                ;;\n            *)\n                export JAVA_HOME=/usr/lib/jvm/java-6-sun\n                ;;\n        esac\n      else\n        case `uname -s` in\n            Darwin)\n                export JAVA_HOME=$(/usr/libexec/java_home -v 1.7)\n                ;;\n            *)\n                export JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64\n                ;;\n        esac\n      fi\n\n      # Keep track of the fact that we set JAVA_HOME ourselves, so that\n      # we can change it on the next envsetup.sh, if required.\n      export ANDROID_SET_JAVA_HOME=true\n    fi\n}\n</code></pre>\n<h2 id=\"到某个文件所在的目录下\"><a href=\"#到某个文件所在的目录下\" class=\"headerlink\" title=\"到某个文件所在的目录下\"></a>到某个文件所在的目录下</h2><pre><code class=\"bash\">function godir () {\n    if [[ -z &quot;$1&quot; ]]; then\n        echo &quot;Usage: godir &lt;regex&gt;&quot;\n        return\n    fi\n    T=$(gettop)\n    if [[ ! -f $T/filelist ]]; then\n        echo -n &quot;Creating index...&quot;\n        (\\cd $T; find . -wholename ./out -prune -o -wholename ./.repo -prune -o -type f &gt; filelist)\n        echo &quot; Done&quot;\n        echo &quot;&quot;\n    fi\n    local lines\n    lines=($(\\grep &quot;$1&quot; $T/filelist | sed -e &#39;s/\\/[^/]*$//&#39; | sort | uniq))\n    if [[ ${#lines[@]} = 0 ]]; then\n        echo &quot;Not found&quot;\n        return\n    fi\n    local pathname\n    local choice\n    if [[ ${#lines[@]} &gt; 1 ]]; then\n        while [[ -z &quot;$pathname&quot; ]]; do\n            local index=1\n            local line\n            for line in ${lines[@]}; do\n                printf &quot;%6s %s\\n&quot; &quot;[$index]&quot; $line\n                index=$(($index + 1))\n            done\n            echo\n            echo -n &quot;Select one: &quot;\n            unset choice\n            read choice\n            if [[ $choice -gt ${#lines[@]} || $choice -lt 1 ]]; then\n                echo &quot;Invalid choice&quot;\n                continue\n            fi\n            pathname=${lines[$(($choice-1))]}\n        done\n    else\n        pathname=${lines[0]}\n    fi\n    \\cd $T/$pathname\n}\n</code></pre>\n<h2 id=\"具体参数查看runtest-h\"><a href=\"#具体参数查看runtest-h\" class=\"headerlink\" title=\"具体参数查看runtest -h\"></a>具体参数查看runtest -h</h2><pre><code class=\"bash\"># simple shortcut to the runtest command\nfunction runtest()\n{\n    T=$(gettop)\n    if [ ! &quot;$T&quot; ]; then\n        echo &quot;Couldn&#39;t locate the top of the tree.  Try setting TOP.&quot; &gt;&amp;2\n        return\n    fi\n    (&quot;$T&quot;/development/testrunner/runtest.py $@)\n}\n</code></pre>\n<h2 id=\"smoketest\"><a href=\"#smoketest\" class=\"headerlink\" title=\"smoketest\"></a>smoketest</h2><pre><code class=\"bash\">function smoketest()\n{\n    if [ ! &quot;$ANDROID_PRODUCT_OUT&quot; ]; then\n        echo &quot;Couldn&#39;t locate output files.  Try running &#39;lunch&#39; first.&quot; &gt;&amp;2\n        return\n    fi\n    T=$(gettop)\n    if [ ! &quot;$T&quot; ]; then\n        echo &quot;Couldn&#39;t locate the top of the tree.  Try setting TOP.&quot; &gt;&amp;2\n        return\n    fi\n\n    (\\cd &quot;$T&quot; &amp;&amp; mmm tests/SmokeTest) &amp;&amp;\n      adb uninstall com.android.smoketest &gt; /dev/null &amp;&amp;\n      adb uninstall com.android.smoketest.tests &gt; /dev/null &amp;&amp;\n      adb install $ANDROID_PRODUCT_OUT/data/app/SmokeTestApp.apk &amp;&amp;\n      adb install $ANDROID_PRODUCT_OUT/data/app/SmokeTest.apk &amp;&amp;\n      adb shell am instrument -w com.android.smoketest.tests/android.test.InstrumentationTestRunner\n}\n</code></pre>\n<h2 id=\"常用的安卓物理键模拟及viewserver\"><a href=\"#常用的安卓物理键模拟及viewserver\" class=\"headerlink\" title=\"常用的安卓物理键模拟及viewserver\"></a>常用的安卓物理键模拟及viewserver</h2><pre><code class=\"bash\"># 开启viewServer\nfunction startviewserver()\n{\n    local port=4939\n    if [ $# -gt 0 ]; then\n            port=$1\n    fi\n    adb shell service call window 1 i32 $port\n}\n# 停止viewServer\nfunction stopviewserver()\n{\n    adb shell service call window 2\n}\n# 查看viewServer状态\nfunction isviewserverstarted()\n{\n    adb shell service call window 3\n}\n# 相当于按下设备home键、back键、menu键\nfunction key_home()\nfunction key_back()\nfunction key_menu()\n</code></pre>\n<p>##获取手机中的bug日志</p>\n<pre><code class=\"bash\">function getbugreports()\n{\n    local reports=(`adb shell ls /sdcard/bugreports | tr -d &#39;\\r&#39;`)\n\n    if [ ! &quot;$reports&quot; ]; then\n        echo &quot;Could not locate any bugreports.&quot;\n        return\n    fi\n\n    local report\n    for report in ${reports[@]}\n    do\n        echo &quot;/sdcard/bugreports/${report}&quot;\n        adb pull /sdcard/bugreports/${report} ${report}\n        gunzip ${report}\n    done\n}\n</code></pre>\n<h2 id=\"得到sdcard的路径，屏幕截图路径和最后一张截图\"><a href=\"#得到sdcard的路径，屏幕截图路径和最后一张截图\" class=\"headerlink\" title=\"得到sdcard的路径，屏幕截图路径和最后一张截图\"></a>得到sdcard的路径，屏幕截图路径和最后一张截图</h2><pre><code class=\"bash\">function getsdcardpath()\nfunction getscreenshotpath()\nfunction getlastscreenshot()\n</code></pre>\n<h2 id=\"dump某一时刻的trace数据\"><a href=\"#dump某一时刻的trace数据\" class=\"headerlink\" title=\"dump某一时刻的trace数据\"></a>dump某一时刻的trace数据</h2><pre><code class=\"bash\">function tracedmdump()\n{\n    T=$(gettop)\n    if [ ! &quot;$T&quot; ]; then\n        echo &quot;Couldn&#39;t locate the top of the tree.  Try setting TOP.&quot;\n        return\n    fi\n    local prebuiltdir=$(getprebuilt)\n    local arch=$(gettargetarch)\n    local KERNEL=$T/prebuilts/qemu-kernel/$arch/vmlinux-qemu\n\n    local TRACE=$1\n    if [ ! &quot;$TRACE&quot; ] ; then\n        echo &quot;usage:  tracedmdump  tracename&quot;\n        return\n    fi\n\n    if [ ! -r &quot;$KERNEL&quot; ] ; then\n        echo &quot;Error: cannot find kernel: &#39;$KERNEL&#39;&quot;\n        return\n    fi\n\n    local BASETRACE=$(basename $TRACE)\n    if [ &quot;$BASETRACE&quot; = &quot;$TRACE&quot; ] ; then\n        TRACE=$ANDROID_PRODUCT_OUT/traces/$TRACE\n    fi\n\n    echo &quot;post-processing traces...&quot;\n    rm -f $TRACE/qtrace.dexlist\n    post_trace $TRACE\n    if [ $? -ne 0 ]; then\n        echo &quot;***&quot;\n        echo &quot;*** Error: malformed trace.  Did you remember to exit the emulator?&quot;\n        echo &quot;***&quot;\n        return\n    fi\n    echo &quot;generating dexlist output...&quot;\n    /bin/ls $ANDROID_PRODUCT_OUT/system/framework/*.jar $ANDROID_PRODUCT_OUT/system/app/*.apk $ANDROID_PRODUCT_OUT/data/app/*.apk 2&gt;/dev/null | xargs dexlist &gt; $TRACE/qtrace.dexlist\n    echo &quot;generating dmtrace data...&quot;\n    q2dm -r $ANDROID_PRODUCT_OUT/symbols $TRACE $KERNEL $TRACE/dmtrace || return\n    echo &quot;generating html file...&quot;\n    dmtracedump -h $TRACE/dmtrace &gt;| $TRACE/dmtrace.html || return\n    echo &quot;done, see $TRACE/dmtrace.html for details&quot;\n    echo &quot;or run:&quot;\n    echo &quot;    traceview $TRACE/dmtrace&quot;\n}\n</code></pre>\n<h2 id=\"查询-gradle、-java-等文件中某个字符串在文件中的位置\"><a href=\"#查询-gradle、-java-等文件中某个字符串在文件中的位置\" class=\"headerlink\" title=\"查询.gradle、.java 等文件中某个字符串在文件中的位置\"></a>查询.gradle、.java 等文件中某个字符串在文件中的位置</h2><pre><code class=\"bash\">function ggrep()\n{\n    find . -name .repo -prune -o -name .git -prune -o -name out -prune -o -type f -name &quot;*\\.gradle&quot; -print0 | xargs -0 grep --color -n &quot;$@&quot;\n}\nfunction jgrep()\n{\n    find . -name .repo -prune -o -name .git -prune -o -name out -prune -o -type f -name &quot;*\\.java&quot; -print0 | xargs -0 grep --color -n &quot;$@&quot;\n}\nfunction cgrep()\n{\n    find . -name .repo -prune -o -name .git -prune -o -name out -prune -o -type f \\( -name &#39;*.c&#39; -o -name &#39;*.cc&#39; -o -name &#39;*.cpp&#39; -o -name &#39;*.h&#39; \\) -print0 | xargs -0 grep --color -n &quot;$@&quot;\n}\nfunction resgrep()\n{\n    for dir in `find . -name .repo -prune -o -name .git -prune -o -name out -prune -o -name res -type d`; do find $dir -type f -name &#39;*\\.xml&#39; -print0 | xargs -0 grep --color -n &quot;$@&quot;; done;\n}\nfunction mangrep()\n{\n    find . -name .repo -prune -o -name .git -prune -o -path ./out -prune -o -type f -name &#39;AndroidManifest.xml&#39; -print0 | xargs -0 grep --color -n &quot;$@&quot;\n}\nfunction sepgrep()\n{\n    find . -name .repo -prune -o -name .git -prune -o -path ./out -prune -o -name sepolicy -type d -print0 | xargs -0 grep --color -n -r --exclude-dir=\\.git &quot;$@&quot;\n}\n</code></pre>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><pre><code class=\"bash\"># 得到顶级目录路径\nfunction gettop\n# 找到make文件\nfunction findmakefile()\n# 当前目录下编译执行，相当于在android目录下执行make\nfunction m()\n# 执行当前目录下最近的make文件\nfunction mm()\n# 在android目录下，执行某个文件夹下的make文件\nfunction mmm()\n# Builds all of the modules in the current directory, and their dependencies.\nfunction mma()\n# Builds all of the modules in the supplied directories, and their dependencies.\nfunction mmma()\n</code></pre>\n","excerpt":"","more":"<h1 id=\"envsetup-sh的常用命令\"><a href=\"#envsetup-sh的常用命令\" class=\"headerlink\" title=\"envsetup-sh的常用命令\"></a>envsetup-sh的常用命令</h1><p><strong> 摘要：</strong> 这篇文档主要对android下的编译脚本文件 envsetup.sh 进行了简单的分析，并且从中总结了一些在开发过程中常用的命令，以便于开发者们提高开发效率。</p>\n<h2 id=\"常用命令索引\"><a href=\"#常用命令索引\" class=\"headerlink\" title=\"常用命令索引\"></a>常用命令索引</h2><p><code>croot</code>  - -到达android根目录；<br><code>cproj + 模块名</code>  - -到达项目的根目录下；<br><code>gettop</code>  - -得到顶级目录路径；<br><code>findmakefile</code> - -找到make文件。</p>\n<p><code>m</code> - -当前目录下编译执行，相当于在android目录下执行make<br><code>mm</code> - -执行当前目录下最近的make文件<br><code>mmm</code>  - -在android目录下，执行某个文件夹下的make文件<br><code>mma</code> - -编译当前目录下所有的模块和他们的依赖<br><code>mmma</code> - -编译提供的目录下的所有模块和他们的依赖<br><code>make sdk</code> - -编译SDK及其包含的一些工具 (adb, fastboot, 等等)。<br><code>make snod</code>  - -从当前编译出的二进制数据编译system.img文件 ，这条命令将重新生成镜像，消耗的时间很少，如果你修改了一些数据文件（如音乐、视频）等文件时比较有用。<br><code>make cts</code>  - -这条命令将编译CTS套机，编译出的结果放在out目录对应版的data/app目录下面。CTS测试时有用。<br><code>make services</code> - -<br><code>make runtime</code> - -<br><code>make droid</code> - -make droid is the normal build.<br><code>make all</code> - -make everything, whether it is included in the product definition or not<br><code>make clean</code> - -remove all built files (prepare for a new build). Same as rm -rf out _make modules - shows a list of submodules that can be built (List of all LOCAL_MODULE definitions)<br><code>make installclean</code>  - -同上<br><code>make *</code> - -make a specific module (note that this is not the same as directory name. It is the LOCAL_MODULE definition in the Android.mk file)<br><code>make clean *</code>  - -clean a specific module<br><code>make bootimage</code> - -编译创建一个新的 boot image<br><code>make bootimage</code>  - -TARGET_PREBUILT_KERNEL=/path/to/bzImage - create a new boot image with custom bzImage<br><code>make systemimage</code> - -编译创建一个新的 system image</p>\n<h2 id=\"make命令\"><a href=\"#make命令\" class=\"headerlink\" title=\"make命令\"></a>make命令</h2><p>不用多解释，编译整个项目，可以加模块名参数等。</p>\n<pre><code class=\"bash\">function make()\n{\n    local start_time=$(date +&quot;%s&quot;)\n    $(get_make_command) &quot;$@&quot;\n    local ret=$?\n    local end_time=$(date +&quot;%s&quot;)\n    local tdiff=$(($end_time-$start_time))\n    local hours=$(($tdiff / 3600 ))\n    local mins=$((($tdiff % 3600) / 60))\n    local secs=$(($tdiff % 60))\n    echo\n    if [ $ret -eq 0 ] ; then\n        echo -n -e &quot;#### make completed successfully &quot;\n    else\n        echo -n -e &quot;#### make failed to build some targets &quot;\n    fi\n    if [ $hours -gt 0 ] ; then\n        printf &quot;(%02g:%02g:%02g (hh:mm:ss))&quot; $hours $mins $secs\n    elif [ $mins -gt 0 ] ; then\n        printf &quot;(%02g:%02g (mm:ss))&quot; $mins $secs\n    elif [ $secs -gt 0 ] ; then\n        printf &quot;(%s seconds)&quot; $secs\n    fi\n    echo -e &quot; ####&quot;\n    echo\n    return $ret\n}\n</code></pre>\n<blockquote>\n<p><strong>提示：</strong>具体功能还需要分析。</p>\n</blockquote>\n<h2 id=\"设置编译环境的java-home\"><a href=\"#设置编译环境的java-home\" class=\"headerlink\" title=\"设置编译环境的java home\"></a>设置编译环境的java home</h2><pre><code class=\"bash\"># Force JAVA_HOME to point to java 1.7 or java 1.6  if it isn&#39;t already set.\n#\n# Note that the MacOS path for java 1.7 includes a minor revision number (sigh).\n# For some reason, installing the JDK doesn&#39;t make it show up in the\n# JavaVM.framework/Versions/1.7/ folder.\nfunction set_java_home() {\n    # Clear the existing JAVA_HOME value if we set it ourselves, so that\n    # we can reset it later, depending on the version of java the build\n    # system needs.\n    #\n    # If we don&#39;t do this, the JAVA_HOME value set by the first call to\n    # build/envsetup.sh will persist forever.\n    if [ -n &quot;$ANDROID_SET_JAVA_HOME&quot; ]; then\n      export JAVA_HOME=&quot;&quot;\n    fi\n\n    if [ ! &quot;$JAVA_HOME&quot; ]; then\n      if [ -n &quot;$LEGACY_USE_JAVA6&quot; ]; then\n        case `uname -s` in\n            Darwin)\n                export JAVA_HOME=/System/Library/Frameworks/JavaVM.framework/Versions/1.6/Home\n                ;;\n            *)\n                export JAVA_HOME=/usr/lib/jvm/java-6-sun\n                ;;\n        esac\n      else\n        case `uname -s` in\n            Darwin)\n                export JAVA_HOME=$(/usr/libexec/java_home -v 1.7)\n                ;;\n            *)\n                export JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64\n                ;;\n        esac\n      fi\n\n      # Keep track of the fact that we set JAVA_HOME ourselves, so that\n      # we can change it on the next envsetup.sh, if required.\n      export ANDROID_SET_JAVA_HOME=true\n    fi\n}\n</code></pre>\n<h2 id=\"到某个文件所在的目录下\"><a href=\"#到某个文件所在的目录下\" class=\"headerlink\" title=\"到某个文件所在的目录下\"></a>到某个文件所在的目录下</h2><pre><code class=\"bash\">function godir () {\n    if [[ -z &quot;$1&quot; ]]; then\n        echo &quot;Usage: godir &lt;regex&gt;&quot;\n        return\n    fi\n    T=$(gettop)\n    if [[ ! -f $T/filelist ]]; then\n        echo -n &quot;Creating index...&quot;\n        (\\cd $T; find . -wholename ./out -prune -o -wholename ./.repo -prune -o -type f &gt; filelist)\n        echo &quot; Done&quot;\n        echo &quot;&quot;\n    fi\n    local lines\n    lines=($(\\grep &quot;$1&quot; $T/filelist | sed -e &#39;s/\\/[^/]*$//&#39; | sort | uniq))\n    if [[ ${#lines[@]} = 0 ]]; then\n        echo &quot;Not found&quot;\n        return\n    fi\n    local pathname\n    local choice\n    if [[ ${#lines[@]} &gt; 1 ]]; then\n        while [[ -z &quot;$pathname&quot; ]]; do\n            local index=1\n            local line\n            for line in ${lines[@]}; do\n                printf &quot;%6s %s\\n&quot; &quot;[$index]&quot; $line\n                index=$(($index + 1))\n            done\n            echo\n            echo -n &quot;Select one: &quot;\n            unset choice\n            read choice\n            if [[ $choice -gt ${#lines[@]} || $choice -lt 1 ]]; then\n                echo &quot;Invalid choice&quot;\n                continue\n            fi\n            pathname=${lines[$(($choice-1))]}\n        done\n    else\n        pathname=${lines[0]}\n    fi\n    \\cd $T/$pathname\n}\n</code></pre>\n<h2 id=\"具体参数查看runtest-h\"><a href=\"#具体参数查看runtest-h\" class=\"headerlink\" title=\"具体参数查看runtest -h\"></a>具体参数查看runtest -h</h2><pre><code class=\"bash\"># simple shortcut to the runtest command\nfunction runtest()\n{\n    T=$(gettop)\n    if [ ! &quot;$T&quot; ]; then\n        echo &quot;Couldn&#39;t locate the top of the tree.  Try setting TOP.&quot; &gt;&amp;2\n        return\n    fi\n    (&quot;$T&quot;/development/testrunner/runtest.py $@)\n}\n</code></pre>\n<h2 id=\"smoketest\"><a href=\"#smoketest\" class=\"headerlink\" title=\"smoketest\"></a>smoketest</h2><pre><code class=\"bash\">function smoketest()\n{\n    if [ ! &quot;$ANDROID_PRODUCT_OUT&quot; ]; then\n        echo &quot;Couldn&#39;t locate output files.  Try running &#39;lunch&#39; first.&quot; &gt;&amp;2\n        return\n    fi\n    T=$(gettop)\n    if [ ! &quot;$T&quot; ]; then\n        echo &quot;Couldn&#39;t locate the top of the tree.  Try setting TOP.&quot; &gt;&amp;2\n        return\n    fi\n\n    (\\cd &quot;$T&quot; &amp;&amp; mmm tests/SmokeTest) &amp;&amp;\n      adb uninstall com.android.smoketest &gt; /dev/null &amp;&amp;\n      adb uninstall com.android.smoketest.tests &gt; /dev/null &amp;&amp;\n      adb install $ANDROID_PRODUCT_OUT/data/app/SmokeTestApp.apk &amp;&amp;\n      adb install $ANDROID_PRODUCT_OUT/data/app/SmokeTest.apk &amp;&amp;\n      adb shell am instrument -w com.android.smoketest.tests/android.test.InstrumentationTestRunner\n}\n</code></pre>\n<h2 id=\"常用的安卓物理键模拟及viewserver\"><a href=\"#常用的安卓物理键模拟及viewserver\" class=\"headerlink\" title=\"常用的安卓物理键模拟及viewserver\"></a>常用的安卓物理键模拟及viewserver</h2><pre><code class=\"bash\"># 开启viewServer\nfunction startviewserver()\n{\n    local port=4939\n    if [ $# -gt 0 ]; then\n            port=$1\n    fi\n    adb shell service call window 1 i32 $port\n}\n# 停止viewServer\nfunction stopviewserver()\n{\n    adb shell service call window 2\n}\n# 查看viewServer状态\nfunction isviewserverstarted()\n{\n    adb shell service call window 3\n}\n# 相当于按下设备home键、back键、menu键\nfunction key_home()\nfunction key_back()\nfunction key_menu()\n</code></pre>\n<p>##获取手机中的bug日志</p>\n<pre><code class=\"bash\">function getbugreports()\n{\n    local reports=(`adb shell ls /sdcard/bugreports | tr -d &#39;\\r&#39;`)\n\n    if [ ! &quot;$reports&quot; ]; then\n        echo &quot;Could not locate any bugreports.&quot;\n        return\n    fi\n\n    local report\n    for report in ${reports[@]}\n    do\n        echo &quot;/sdcard/bugreports/${report}&quot;\n        adb pull /sdcard/bugreports/${report} ${report}\n        gunzip ${report}\n    done\n}\n</code></pre>\n<h2 id=\"得到sdcard的路径，屏幕截图路径和最后一张截图\"><a href=\"#得到sdcard的路径，屏幕截图路径和最后一张截图\" class=\"headerlink\" title=\"得到sdcard的路径，屏幕截图路径和最后一张截图\"></a>得到sdcard的路径，屏幕截图路径和最后一张截图</h2><pre><code class=\"bash\">function getsdcardpath()\nfunction getscreenshotpath()\nfunction getlastscreenshot()\n</code></pre>\n<h2 id=\"dump某一时刻的trace数据\"><a href=\"#dump某一时刻的trace数据\" class=\"headerlink\" title=\"dump某一时刻的trace数据\"></a>dump某一时刻的trace数据</h2><pre><code class=\"bash\">function tracedmdump()\n{\n    T=$(gettop)\n    if [ ! &quot;$T&quot; ]; then\n        echo &quot;Couldn&#39;t locate the top of the tree.  Try setting TOP.&quot;\n        return\n    fi\n    local prebuiltdir=$(getprebuilt)\n    local arch=$(gettargetarch)\n    local KERNEL=$T/prebuilts/qemu-kernel/$arch/vmlinux-qemu\n\n    local TRACE=$1\n    if [ ! &quot;$TRACE&quot; ] ; then\n        echo &quot;usage:  tracedmdump  tracename&quot;\n        return\n    fi\n\n    if [ ! -r &quot;$KERNEL&quot; ] ; then\n        echo &quot;Error: cannot find kernel: &#39;$KERNEL&#39;&quot;\n        return\n    fi\n\n    local BASETRACE=$(basename $TRACE)\n    if [ &quot;$BASETRACE&quot; = &quot;$TRACE&quot; ] ; then\n        TRACE=$ANDROID_PRODUCT_OUT/traces/$TRACE\n    fi\n\n    echo &quot;post-processing traces...&quot;\n    rm -f $TRACE/qtrace.dexlist\n    post_trace $TRACE\n    if [ $? -ne 0 ]; then\n        echo &quot;***&quot;\n        echo &quot;*** Error: malformed trace.  Did you remember to exit the emulator?&quot;\n        echo &quot;***&quot;\n        return\n    fi\n    echo &quot;generating dexlist output...&quot;\n    /bin/ls $ANDROID_PRODUCT_OUT/system/framework/*.jar $ANDROID_PRODUCT_OUT/system/app/*.apk $ANDROID_PRODUCT_OUT/data/app/*.apk 2&gt;/dev/null | xargs dexlist &gt; $TRACE/qtrace.dexlist\n    echo &quot;generating dmtrace data...&quot;\n    q2dm -r $ANDROID_PRODUCT_OUT/symbols $TRACE $KERNEL $TRACE/dmtrace || return\n    echo &quot;generating html file...&quot;\n    dmtracedump -h $TRACE/dmtrace &gt;| $TRACE/dmtrace.html || return\n    echo &quot;done, see $TRACE/dmtrace.html for details&quot;\n    echo &quot;or run:&quot;\n    echo &quot;    traceview $TRACE/dmtrace&quot;\n}\n</code></pre>\n<h2 id=\"查询-gradle、-java-等文件中某个字符串在文件中的位置\"><a href=\"#查询-gradle、-java-等文件中某个字符串在文件中的位置\" class=\"headerlink\" title=\"查询.gradle、.java 等文件中某个字符串在文件中的位置\"></a>查询.gradle、.java 等文件中某个字符串在文件中的位置</h2><pre><code class=\"bash\">function ggrep()\n{\n    find . -name .repo -prune -o -name .git -prune -o -name out -prune -o -type f -name &quot;*\\.gradle&quot; -print0 | xargs -0 grep --color -n &quot;$@&quot;\n}\nfunction jgrep()\n{\n    find . -name .repo -prune -o -name .git -prune -o -name out -prune -o -type f -name &quot;*\\.java&quot; -print0 | xargs -0 grep --color -n &quot;$@&quot;\n}\nfunction cgrep()\n{\n    find . -name .repo -prune -o -name .git -prune -o -name out -prune -o -type f \\( -name &#39;*.c&#39; -o -name &#39;*.cc&#39; -o -name &#39;*.cpp&#39; -o -name &#39;*.h&#39; \\) -print0 | xargs -0 grep --color -n &quot;$@&quot;\n}\nfunction resgrep()\n{\n    for dir in `find . -name .repo -prune -o -name .git -prune -o -name out -prune -o -name res -type d`; do find $dir -type f -name &#39;*\\.xml&#39; -print0 | xargs -0 grep --color -n &quot;$@&quot;; done;\n}\nfunction mangrep()\n{\n    find . -name .repo -prune -o -name .git -prune -o -path ./out -prune -o -type f -name &#39;AndroidManifest.xml&#39; -print0 | xargs -0 grep --color -n &quot;$@&quot;\n}\nfunction sepgrep()\n{\n    find . -name .repo -prune -o -name .git -prune -o -path ./out -prune -o -name sepolicy -type d -print0 | xargs -0 grep --color -n -r --exclude-dir=\\.git &quot;$@&quot;\n}\n</code></pre>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><pre><code class=\"bash\"># 得到顶级目录路径\nfunction gettop\n# 找到make文件\nfunction findmakefile()\n# 当前目录下编译执行，相当于在android目录下执行make\nfunction m()\n# 执行当前目录下最近的make文件\nfunction mm()\n# 在android目录下，执行某个文件夹下的make文件\nfunction mmm()\n# Builds all of the modules in the current directory, and their dependencies.\nfunction mma()\n# Builds all of the modules in the supplied directories, and their dependencies.\nfunction mmma()\n</code></pre>\n"},{"layout":"post","title":"《何必等来生》第三章读书笔记","subtitle":"每个人对云南的印象是不一样的，我心中的云南是惬意的，充满诗情画意的云南","author":"JianGuo","header-img":"dali.jpg","date":"2016-07-17T19:28:29.000Z","_content":"\n> 云南是个不缺歌声的地方，人们累了唱歌，困了唱歌，伤心了唱歌，开心了也唱歌，陌生人唱着唱着就成了朋友，不熟悉的地方唱着唱着就成了故乡。  \n—— 燕子\n\n# 云南印象\n我对云南的印象是小时候从电视里看到的西双版纳的美丽的热带景观里树立的。再到后来，因为一部电影喜欢上了大理古城，喜欢上了丽江，喜欢上了香格里拉，我喜欢这些地方并不是因为电影情节那样的所谓的艳遇，流浪或者暧昧，而是因为那种悠闲而又惬意的田园风光。\n\n![云南印象](yunnanyinxiang.jpg)\n我憧憬着天的湛蓝，水的清澈，人的纯真，憧憬着这里的一切。在云南，下关风，上关花，苍山雪，洱海月。多么有诗情画意的地方，总是带给人无限的喜悦和向往。大学毕业那年，我做好了安排准备了一场毕业旅行。目的地就是大理，充满着文艺气息的地方。但最后还是因为种种原因没有去成。这样的愿望就被一直搁浅在了心中，我想等下一次实现的时候，应该是和心爱的人一起去见证那里的一切吧。\n\n# 旅行的意义\n![旅行途中](lvxing.jpg)\n我有过几次旅行。曾有独自一人背着相机到一个陌生的城市探索它的美丽和未知；也有曾和朋友欢声笑语的度过“人在囧途”的不堪；有感叹自然鬼斧神工的创造力，也有深思历史长河的每一刻都是什么样子。它们带给我的除了心神愉悦，还有思考和感悟。每一次旅行总会带给自己不同的体验。独自一人时的孤单，成群结队时的谈笑风声，骑着单车时的无忧无虑，带着心爱的人时一起旅行时的流连忘返。  \n\n> 你有什么样的心情，就能看到什么样的风景。\n\n依稀记得有次和室友去牡丹江，因为没有钱，连门票都舍不得买，就逃票进威虎山被查出来的尴尬和无奈。所以即使风景再美，看风景的心情全无。事后我在想，那么年轻人，都追求着穷游，那穷游的意义在哪里？到了想去的地方，却因为没有钱住着最差的旅店，在景区门口晃一圈，这样未免会给自己留下遗憾。这不是真正的旅行。甚至于在我的心中，那些穿梭于人山人海的走马观花都是徒劳的，只会让自己心神疲惫。\n![威虎山城](weihushan.JPG)\n\n\n有时候旅行的真正意义不在于去什么地方，而是你带着怎样的心情去旅行。就像燕子说的，不论在哪里，其实“从来都藏了好多不轻易拿出来的美景，只等有心人”。真正的旅行，对于我来说，它带给我更多的大概是在途中给你思考，给你心灵的震撼，甚至洗礼，使我看到以往没有看到的东西，领略到以往未曾领略的人生哲理。\n\n# 时光荏苒\n> 这世上真正属于你的东西是你的时光，无论任何风景人物对话都只是陪衬，只有你自己可以决定以什么情绪参与。\n\n我想趁着还年轻，趁着还有大好时光，去那些自己未曾去过的，向往的地方，来一场真正的旅行。\n\n16年7月20日记\n","source":"_posts/yunnan_in_my_heart.md","raw":"---\nlayout: post\ntitle: 《何必等来生》第三章读书笔记\nsubtitle: 每个人对云南的印象是不一样的，我心中的云南是惬意的，充满诗情画意的云南\nauthor: JianGuo\nheader-img: dali.jpg\ntags: 感悟\ndate: 2016-07-18 03:28:29\n---\n\n> 云南是个不缺歌声的地方，人们累了唱歌，困了唱歌，伤心了唱歌，开心了也唱歌，陌生人唱着唱着就成了朋友，不熟悉的地方唱着唱着就成了故乡。  \n—— 燕子\n\n# 云南印象\n我对云南的印象是小时候从电视里看到的西双版纳的美丽的热带景观里树立的。再到后来，因为一部电影喜欢上了大理古城，喜欢上了丽江，喜欢上了香格里拉，我喜欢这些地方并不是因为电影情节那样的所谓的艳遇，流浪或者暧昧，而是因为那种悠闲而又惬意的田园风光。\n\n![云南印象](yunnanyinxiang.jpg)\n我憧憬着天的湛蓝，水的清澈，人的纯真，憧憬着这里的一切。在云南，下关风，上关花，苍山雪，洱海月。多么有诗情画意的地方，总是带给人无限的喜悦和向往。大学毕业那年，我做好了安排准备了一场毕业旅行。目的地就是大理，充满着文艺气息的地方。但最后还是因为种种原因没有去成。这样的愿望就被一直搁浅在了心中，我想等下一次实现的时候，应该是和心爱的人一起去见证那里的一切吧。\n\n# 旅行的意义\n![旅行途中](lvxing.jpg)\n我有过几次旅行。曾有独自一人背着相机到一个陌生的城市探索它的美丽和未知；也有曾和朋友欢声笑语的度过“人在囧途”的不堪；有感叹自然鬼斧神工的创造力，也有深思历史长河的每一刻都是什么样子。它们带给我的除了心神愉悦，还有思考和感悟。每一次旅行总会带给自己不同的体验。独自一人时的孤单，成群结队时的谈笑风声，骑着单车时的无忧无虑，带着心爱的人时一起旅行时的流连忘返。  \n\n> 你有什么样的心情，就能看到什么样的风景。\n\n依稀记得有次和室友去牡丹江，因为没有钱，连门票都舍不得买，就逃票进威虎山被查出来的尴尬和无奈。所以即使风景再美，看风景的心情全无。事后我在想，那么年轻人，都追求着穷游，那穷游的意义在哪里？到了想去的地方，却因为没有钱住着最差的旅店，在景区门口晃一圈，这样未免会给自己留下遗憾。这不是真正的旅行。甚至于在我的心中，那些穿梭于人山人海的走马观花都是徒劳的，只会让自己心神疲惫。\n![威虎山城](weihushan.JPG)\n\n\n有时候旅行的真正意义不在于去什么地方，而是你带着怎样的心情去旅行。就像燕子说的，不论在哪里，其实“从来都藏了好多不轻易拿出来的美景，只等有心人”。真正的旅行，对于我来说，它带给我更多的大概是在途中给你思考，给你心灵的震撼，甚至洗礼，使我看到以往没有看到的东西，领略到以往未曾领略的人生哲理。\n\n# 时光荏苒\n> 这世上真正属于你的东西是你的时光，无论任何风景人物对话都只是陪衬，只有你自己可以决定以什么情绪参与。\n\n我想趁着还年轻，趁着还有大好时光，去那些自己未曾去过的，向往的地方，来一场真正的旅行。\n\n16年7月20日记\n","slug":"yunnan_in_my_heart","published":1,"updated":"2016-07-28T12:15:26.984Z","comments":1,"photos":[],"link":"","_id":"cirdlcvcl000h252nqi1bk5f0","content":"<blockquote>\n<p>云南是个不缺歌声的地方，人们累了唱歌，困了唱歌，伤心了唱歌，开心了也唱歌，陌生人唱着唱着就成了朋友，不熟悉的地方唱着唱着就成了故乡。<br>—— 燕子</p>\n</blockquote>\n<h1 id=\"云南印象\"><a href=\"#云南印象\" class=\"headerlink\" title=\"云南印象\"></a>云南印象</h1><p>我对云南的印象是小时候从电视里看到的西双版纳的美丽的热带景观里树立的。再到后来，因为一部电影喜欢上了大理古城，喜欢上了丽江，喜欢上了香格里拉，我喜欢这些地方并不是因为电影情节那样的所谓的艳遇，流浪或者暧昧，而是因为那种悠闲而又惬意的田园风光。</p>\n<p><img src=\"yunnanyinxiang.jpg\" alt=\"云南印象\"><br>我憧憬着天的湛蓝，水的清澈，人的纯真，憧憬着这里的一切。在云南，下关风，上关花，苍山雪，洱海月。多么有诗情画意的地方，总是带给人无限的喜悦和向往。大学毕业那年，我做好了安排准备了一场毕业旅行。目的地就是大理，充满着文艺气息的地方。但最后还是因为种种原因没有去成。这样的愿望就被一直搁浅在了心中，我想等下一次实现的时候，应该是和心爱的人一起去见证那里的一切吧。</p>\n<h1 id=\"旅行的意义\"><a href=\"#旅行的意义\" class=\"headerlink\" title=\"旅行的意义\"></a>旅行的意义</h1><p><img src=\"lvxing.jpg\" alt=\"旅行途中\"><br>我有过几次旅行。曾有独自一人背着相机到一个陌生的城市探索它的美丽和未知；也有曾和朋友欢声笑语的度过“人在囧途”的不堪；有感叹自然鬼斧神工的创造力，也有深思历史长河的每一刻都是什么样子。它们带给我的除了心神愉悦，还有思考和感悟。每一次旅行总会带给自己不同的体验。独自一人时的孤单，成群结队时的谈笑风声，骑着单车时的无忧无虑，带着心爱的人时一起旅行时的流连忘返。  </p>\n<blockquote>\n<p>你有什么样的心情，就能看到什么样的风景。</p>\n</blockquote>\n<p>依稀记得有次和室友去牡丹江，因为没有钱，连门票都舍不得买，就逃票进威虎山被查出来的尴尬和无奈。所以即使风景再美，看风景的心情全无。事后我在想，那么年轻人，都追求着穷游，那穷游的意义在哪里？到了想去的地方，却因为没有钱住着最差的旅店，在景区门口晃一圈，这样未免会给自己留下遗憾。这不是真正的旅行。甚至于在我的心中，那些穿梭于人山人海的走马观花都是徒劳的，只会让自己心神疲惫。<br><img src=\"weihushan.JPG\" alt=\"威虎山城\"></p>\n<p>有时候旅行的真正意义不在于去什么地方，而是你带着怎样的心情去旅行。就像燕子说的，不论在哪里，其实“从来都藏了好多不轻易拿出来的美景，只等有心人”。真正的旅行，对于我来说，它带给我更多的大概是在途中给你思考，给你心灵的震撼，甚至洗礼，使我看到以往没有看到的东西，领略到以往未曾领略的人生哲理。</p>\n<h1 id=\"时光荏苒\"><a href=\"#时光荏苒\" class=\"headerlink\" title=\"时光荏苒\"></a>时光荏苒</h1><blockquote>\n<p>这世上真正属于你的东西是你的时光，无论任何风景人物对话都只是陪衬，只有你自己可以决定以什么情绪参与。</p>\n</blockquote>\n<p>我想趁着还年轻，趁着还有大好时光，去那些自己未曾去过的，向往的地方，来一场真正的旅行。</p>\n<p>16年7月20日记</p>\n","excerpt":"","more":"<blockquote>\n<p>云南是个不缺歌声的地方，人们累了唱歌，困了唱歌，伤心了唱歌，开心了也唱歌，陌生人唱着唱着就成了朋友，不熟悉的地方唱着唱着就成了故乡。<br>—— 燕子</p>\n</blockquote>\n<h1 id=\"云南印象\"><a href=\"#云南印象\" class=\"headerlink\" title=\"云南印象\"></a>云南印象</h1><p>我对云南的印象是小时候从电视里看到的西双版纳的美丽的热带景观里树立的。再到后来，因为一部电影喜欢上了大理古城，喜欢上了丽江，喜欢上了香格里拉，我喜欢这些地方并不是因为电影情节那样的所谓的艳遇，流浪或者暧昧，而是因为那种悠闲而又惬意的田园风光。</p>\n<p><img src=\"yunnanyinxiang.jpg\" alt=\"云南印象\"><br>我憧憬着天的湛蓝，水的清澈，人的纯真，憧憬着这里的一切。在云南，下关风，上关花，苍山雪，洱海月。多么有诗情画意的地方，总是带给人无限的喜悦和向往。大学毕业那年，我做好了安排准备了一场毕业旅行。目的地就是大理，充满着文艺气息的地方。但最后还是因为种种原因没有去成。这样的愿望就被一直搁浅在了心中，我想等下一次实现的时候，应该是和心爱的人一起去见证那里的一切吧。</p>\n<h1 id=\"旅行的意义\"><a href=\"#旅行的意义\" class=\"headerlink\" title=\"旅行的意义\"></a>旅行的意义</h1><p><img src=\"lvxing.jpg\" alt=\"旅行途中\"><br>我有过几次旅行。曾有独自一人背着相机到一个陌生的城市探索它的美丽和未知；也有曾和朋友欢声笑语的度过“人在囧途”的不堪；有感叹自然鬼斧神工的创造力，也有深思历史长河的每一刻都是什么样子。它们带给我的除了心神愉悦，还有思考和感悟。每一次旅行总会带给自己不同的体验。独自一人时的孤单，成群结队时的谈笑风声，骑着单车时的无忧无虑，带着心爱的人时一起旅行时的流连忘返。  </p>\n<blockquote>\n<p>你有什么样的心情，就能看到什么样的风景。</p>\n</blockquote>\n<p>依稀记得有次和室友去牡丹江，因为没有钱，连门票都舍不得买，就逃票进威虎山被查出来的尴尬和无奈。所以即使风景再美，看风景的心情全无。事后我在想，那么年轻人，都追求着穷游，那穷游的意义在哪里？到了想去的地方，却因为没有钱住着最差的旅店，在景区门口晃一圈，这样未免会给自己留下遗憾。这不是真正的旅行。甚至于在我的心中，那些穿梭于人山人海的走马观花都是徒劳的，只会让自己心神疲惫。<br><img src=\"weihushan.JPG\" alt=\"威虎山城\"></p>\n<p>有时候旅行的真正意义不在于去什么地方，而是你带着怎样的心情去旅行。就像燕子说的，不论在哪里，其实“从来都藏了好多不轻易拿出来的美景，只等有心人”。真正的旅行，对于我来说，它带给我更多的大概是在途中给你思考，给你心灵的震撼，甚至洗礼，使我看到以往没有看到的东西，领略到以往未曾领略的人生哲理。</p>\n<h1 id=\"时光荏苒\"><a href=\"#时光荏苒\" class=\"headerlink\" title=\"时光荏苒\"></a>时光荏苒</h1><blockquote>\n<p>这世上真正属于你的东西是你的时光，无论任何风景人物对话都只是陪衬，只有你自己可以决定以什么情绪参与。</p>\n</blockquote>\n<p>我想趁着还年轻，趁着还有大好时光，去那些自己未曾去过的，向往的地方，来一场真正的旅行。</p>\n<p>16年7月20日记</p>\n"}],"PostAsset":[{"_id":"source/_posts/AndroidStudio_VS_eclipse/migration_guide_auto_scroll_from_source.png","slug":"migration_guide_auto_scroll_from_source.png","post":"cirdlcvbv0002252nbjxcii1a","modified":1,"renderable":0},{"_id":"source/_posts/AndroidStudio_shortcut_key/40-returntoeditor.gif","slug":"40-returntoeditor.gif","post":"cirdlcvbn0001252na1hgzz0z","modified":1,"renderable":0},{"_id":"source/_posts/AndroidStudio_shortcut_key/20-unwrap.gif","slug":"20-unwrap.gif","post":"cirdlcvbn0001252na1hgzz0z","modified":1,"renderable":0},{"_id":"source/_posts/AndroidStudio_shortcut_key/04-callinghierarchy.gif","slug":"04-callinghierarchy.gif","post":"cirdlcvbn0001252na1hgzz0z","modified":1,"renderable":0},{"_id":"source/_posts/AndroidStudio_shortcut_key/07-bookmarks.gif","slug":"07-bookmarks.gif","post":"cirdlcvbn0001252na1hgzz0z","modified":1,"renderable":0},{"_id":"source/_posts/AndroidStudio_shortcut_key/27-evaluateexpression.gif","slug":"27-evaluateexpression.gif","post":"cirdlcvbn0001252na1hgzz0z","modified":1,"renderable":0},{"_id":"source/_posts/AndroidStudio_shortcut_key/42-hideallwindows.gif","slug":"42-hideallwindows.gif","post":"cirdlcvbn0001252na1hgzz0z","modified":1,"renderable":0},{"_id":"source/_posts/AndroidStudio_shortcut_key/46-switcher.gif","slug":"46-switcher.gif","post":"cirdlcvbn0001252na1hgzz0z","modified":1,"renderable":0},{"_id":"source/_posts/AndroidStudio_shortcut_key/53-extractmethod.gif","slug":"53-extractmethod.gif","post":"cirdlcvbn0001252na1hgzz0z","modified":1,"renderable":0},{"_id":"source/_posts/AndroidStudio_shortcut_key/56-pullupdown.gif","slug":"56-pullupdown.gif","post":"cirdlcvbn0001252na1hgzz0z","modified":1,"renderable":0},{"_id":"source/_posts/AndroidStudio_shortcut_key/31-analyzedataflow.gif","slug":"31-analyzedataflow.gif","post":"cirdlcvbn0001252na1hgzz0z","modified":1,"renderable":0},{"_id":"source/_posts/AndroidStudio_VS_eclipse/migration_guide_debugger_1.png","slug":"migration_guide_debugger_1.png","post":"cirdlcvbv0002252nbjxcii1a","modified":1,"renderable":0},{"_id":"source/_posts/yunnan_in_my_heart/dali.jpg","slug":"dali.jpg","post":"cirdlcvcl000h252nqi1bk5f0","modified":1,"renderable":0},{"_id":"source/_posts/envsetup_common_command/post-bg-unix-linux.jpg","post":"cirdlcvch000e252n4mk211y2","slug":"post-bg-unix-linux.jpg","modified":1,"renderable":1},{"_id":"source/_posts/AndroidStudySource/android-study-source-bg.png","slug":"android-study-source-bg.png","post":"cirdlcvc00005252n0ef0rm7e","modified":1,"renderable":0},{"_id":"source/_posts/AndroidStudySource/android-study-source-bg1.jpeg","slug":"android-study-source-bg1.jpeg","post":"cirdlcvc00005252n0ef0rm7e","modified":1,"renderable":0},{"_id":"source/_posts/Markdown_user_guide/guide-to-markdown-web-writing.png","post":"cirdlcvc10007252n4a9b3izd","slug":"guide-to-markdown-web-writing.png","modified":1,"renderable":1},{"_id":"source/_posts/Markdown_user_guide/markdown-guide-1.jpg","post":"cirdlcvc10007252n4a9b3izd","slug":"markdown-guide-1.jpg","modified":1,"renderable":1},{"_id":"source/_posts/AndroidStudio_VS_eclipse/post-bg-2015.jpg","slug":"post-bg-2015.jpg","post":"cirdlcvbv0002252nbjxcii1a","modified":1,"renderable":0},{"_id":"source/_posts/UML_learning_note/shili4.png","post":"cirdlcvc8000b252nor6cul3n","slug":"shili4.png","modified":1,"renderable":1},{"_id":"source/_posts/UML_learning_note/shili5.png","post":"cirdlcvc8000b252nor6cul3n","slug":"shili5.png","modified":1,"renderable":1},{"_id":"source/_posts/UML_learning_note/shili6.jpg","post":"cirdlcvc8000b252nor6cul3n","slug":"shili6.jpg","modified":1,"renderable":1},{"_id":"source/_posts/UML_learning_note/what-is-uml.jpg","post":"cirdlcvc8000b252nor6cul3n","slug":"what-is-uml.jpg","modified":1,"renderable":1},{"_id":"source/_posts/yunnan_in_my_heart/lvxing.jpg","slug":"lvxing.jpg","post":"cirdlcvcl000h252nqi1bk5f0","modified":1,"renderable":0},{"_id":"source/_posts/yunnan_in_my_heart/weihushan.JPG","slug":"weihushan.JPG","post":"cirdlcvcl000h252nqi1bk5f0","modified":1,"renderable":0},{"_id":"source/_posts/yunnan_in_my_heart/yunnanyinxiang.jpg","slug":"yunnanyinxiang.jpg","post":"cirdlcvcl000h252nqi1bk5f0","modified":1,"renderable":0},{"_id":"source/_posts/To_Commemorate_The_First_Anniversary_Of_Graduation/beijing.jpg","slug":"beijing.jpg","post":"cirdlcvc20009252nwtdi7q5g","modified":1,"renderable":0},{"_id":"source/_posts/To_Commemorate_The_First_Anniversary_Of_Graduation/graduation.jpg","slug":"graduation.jpg","post":"cirdlcvc20009252nwtdi7q5g","modified":1,"renderable":0},{"_id":"source/_posts/To_Commemorate_The_First_Anniversary_Of_Graduation/jucan.JPG","slug":"jucan.JPG","post":"cirdlcvc20009252nwtdi7q5g","modified":1,"renderable":0},{"_id":"source/_posts/To_Commemorate_The_First_Anniversary_Of_Graduation/qiqihaer.jpg","slug":"qiqihaer.jpg","post":"cirdlcvc20009252nwtdi7q5g","modified":1,"renderable":0},{"_id":"source/_posts/To_Commemorate_The_First_Anniversary_Of_Graduation/shiyanshi.jpg","slug":"shiyanshi.jpg","post":"cirdlcvc20009252nwtdi7q5g","modified":1,"renderable":0},{"_id":"source/_posts/AndroidStudio_shortcut_key/01-highlight.gif","post":"cirdlcvbn0001252na1hgzz0z","slug":"01-highlight.gif","modified":1,"renderable":1},{"_id":"source/_posts/AndroidStudio_shortcut_key/02-move_between_methods.gif","post":"cirdlcvbn0001252na1hgzz0z","slug":"02-move_between_methods.gif","modified":1,"renderable":1},{"_id":"source/_posts/AndroidStudio_shortcut_key/03-filestructure.gif","post":"cirdlcvbn0001252na1hgzz0z","slug":"03-filestructure.gif","modified":1,"renderable":1},{"_id":"source/_posts/AndroidStudio_shortcut_key/05-quickdefinition.gif","post":"cirdlcvbn0001252na1hgzz0z","slug":"05-quickdefinition.gif","modified":1,"renderable":1},{"_id":"source/_posts/AndroidStudio_shortcut_key/06-codefolding.gif","post":"cirdlcvbn0001252na1hgzz0z","slug":"06-codefolding.gif","modified":1,"renderable":1},{"_id":"source/_posts/AndroidStudio_shortcut_key/08-findaction.gif","post":"cirdlcvbn0001252na1hgzz0z","slug":"08-findaction.gif","modified":1,"renderable":1},{"_id":"source/_posts/AndroidStudio_shortcut_key/09-movelines.gif","post":"cirdlcvbn0001252na1hgzz0z","slug":"09-movelines.gif","modified":1,"renderable":1},{"_id":"source/_posts/AndroidStudio_shortcut_key/10-deleteline.gif","post":"cirdlcvbn0001252na1hgzz0z","slug":"10-deleteline.gif","modified":1,"renderable":1},{"_id":"source/_posts/AndroidStudio_shortcut_key/11-duplicate_lines.gif","post":"cirdlcvbn0001252na1hgzz0z","slug":"11-duplicate_lines.gif","modified":1,"renderable":1},{"_id":"source/_posts/AndroidStudio_shortcut_key/12-expand_shrink_selection.gif","post":"cirdlcvbn0001252na1hgzz0z","slug":"12-expand_shrink_selection.gif","modified":1,"renderable":1},{"_id":"source/_posts/AndroidStudio_shortcut_key/13-surround_with.gif","post":"cirdlcvbn0001252na1hgzz0z","slug":"13-surround_with.gif","modified":1,"renderable":1},{"_id":"source/_posts/AndroidStudio_shortcut_key/14-recents.gif","post":"cirdlcvbn0001252na1hgzz0z","slug":"14-recents.gif","modified":1,"renderable":1},{"_id":"source/_posts/AndroidStudio_shortcut_key/15-live_templates.gif","post":"cirdlcvbn0001252na1hgzz0z","slug":"15-live_templates.gif","modified":1,"renderable":1},{"_id":"source/_posts/AndroidStudio_shortcut_key/15-movemethods.gif","post":"cirdlcvbn0001252na1hgzz0z","slug":"15-movemethods.gif","modified":1,"renderable":1},{"_id":"source/_posts/AndroidStudio_shortcut_key/16-completestatement.gif","post":"cirdlcvbn0001252na1hgzz0z","slug":"16-completestatement.gif","modified":1,"renderable":1},{"_id":"source/_posts/AndroidStudio_shortcut_key/17-navigate-previous-changes.gif","post":"cirdlcvbn0001252na1hgzz0z","slug":"17-navigate-previous-changes.gif","modified":1,"renderable":1},{"_id":"source/_posts/AndroidStudio_shortcut_key/18-joinlines.gif","post":"cirdlcvbn0001252na1hgzz0z","slug":"18-joinlines.gif","modified":1,"renderable":1},{"_id":"source/_posts/AndroidStudio_shortcut_key/19-select-in.gif","post":"cirdlcvbn0001252na1hgzz0z","slug":"19-select-in.gif","modified":1,"renderable":1},{"_id":"source/_posts/AndroidStudio_shortcut_key/21-togglebreakpoints.gif","post":"cirdlcvbn0001252na1hgzz0z","slug":"21-togglebreakpoints.gif","modified":1,"renderable":1},{"_id":"source/_posts/AndroidStudio_shortcut_key/22-conditionalbreakpoint.gif","post":"cirdlcvbn0001252na1hgzz0z","slug":"22-conditionalbreakpoint.gif","modified":1,"renderable":1},{"_id":"source/_posts/AndroidStudio_shortcut_key/23-loggingbreakpoints.gif","slug":"23-loggingbreakpoints.gif","post":"cirdlcvbn0001252na1hgzz0z","modified":1,"renderable":0},{"_id":"source/_posts/AndroidStudio_shortcut_key/24-temporarybreakpoints.gif","post":"cirdlcvbn0001252na1hgzz0z","slug":"24-temporarybreakpoints.gif","modified":1,"renderable":1},{"_id":"source/_posts/AndroidStudio_shortcut_key/25-disablebreakpoint.gif","post":"cirdlcvbn0001252na1hgzz0z","slug":"25-disablebreakpoint.gif","modified":1,"renderable":1},{"_id":"source/_posts/AndroidStudio_shortcut_key/28-mouse_evaluate_expression.gif","post":"cirdlcvbn0001252na1hgzz0z","slug":"28-mouse_evaluate_expression.gif","modified":1,"renderable":1},{"_id":"source/_posts/AndroidStudio_shortcut_key/29-markobject.gif","slug":"29-markobject.gif","post":"cirdlcvbn0001252na1hgzz0z","modified":1,"renderable":0},{"_id":"source/_posts/AndroidStudio_shortcut_key/30-analyzestacktrace.gif","slug":"30-analyzestacktrace.gif","post":"cirdlcvbn0001252na1hgzz0z","modified":1,"renderable":0},{"_id":"source/_posts/AndroidStudio_shortcut_key/32-multiselection.gif","post":"cirdlcvbn0001252na1hgzz0z","slug":"32-multiselection.gif","modified":1,"renderable":1},{"_id":"source/_posts/AndroidStudio_shortcut_key/33-columnselection.gif","post":"cirdlcvbn0001252na1hgzz0z","slug":"33-columnselection.gif","modified":1,"renderable":1},{"_id":"source/_posts/AndroidStudio_shortcut_key/33-postfixcompletion.gif","post":"cirdlcvbn0001252na1hgzz0z","slug":"33-postfixcompletion.gif","modified":1,"renderable":1},{"_id":"source/_posts/AndroidStudio_shortcut_key/34-comparewithclipboard.gif","post":"cirdlcvbn0001252na1hgzz0z","slug":"34-comparewithclipboard.gif","modified":1,"renderable":1},{"_id":"source/_posts/AndroidStudio_shortcut_key/35-stoprocess.gif","post":"cirdlcvbn0001252na1hgzz0z","slug":"35-stoprocess.gif","modified":1,"renderable":1},{"_id":"source/_posts/AndroidStudio_shortcut_key/36-executionpoint.gif","post":"cirdlcvbn0001252na1hgzz0z","slug":"36-executionpoint.gif","modified":1,"renderable":1},{"_id":"source/_posts/AndroidStudio_shortcut_key/37-vcspopup.gif","post":"cirdlcvbn0001252na1hgzz0z","slug":"37-vcspopup.gif","modified":1,"renderable":1},{"_id":"source/_posts/AndroidStudio_shortcut_key/38-comparewithbranch.gif","slug":"38-comparewithbranch.gif","post":"cirdlcvbn0001252na1hgzz0z","modified":1,"renderable":0},{"_id":"source/_posts/AndroidStudio_shortcut_key/39-navigatetoparent.gif","post":"cirdlcvbn0001252na1hgzz0z","slug":"39-navigatetoparent.gif","modified":1,"renderable":1},{"_id":"source/_posts/AndroidStudio_shortcut_key/41-lasttoolwindow.gif","post":"cirdlcvbn0001252na1hgzz0z","slug":"41-lasttoolwindow.gif","modified":1,"renderable":1},{"_id":"source/_posts/AndroidStudio_shortcut_key/43-openpanelbynumber.gif","slug":"43-openpanelbynumber.gif","post":"cirdlcvbn0001252na1hgzz0z","modified":1,"renderable":0},{"_id":"source/_posts/AndroidStudio_shortcut_key/44-parameterinfo.gif","post":"cirdlcvbn0001252na1hgzz0z","slug":"44-parameterinfo.gif","modified":1,"renderable":1},{"_id":"source/_posts/AndroidStudio_shortcut_key/45-codecompletionentertab.gif","post":"cirdlcvbn0001252na1hgzz0z","slug":"45-codecompletionentertab.gif","modified":1,"renderable":1},{"_id":"source/_posts/AndroidStudio_shortcut_key/47-contextinfo.gif","post":"cirdlcvbn0001252na1hgzz0z","slug":"47-contextinfo.gif","modified":1,"renderable":1},{"_id":"source/_posts/AndroidStudio_shortcut_key/48-refactorthis.png","post":"cirdlcvbn0001252na1hgzz0z","slug":"48-refactorthis.png","modified":1,"renderable":1},{"_id":"source/_posts/AndroidStudio_shortcut_key/49-recentlyedited.gif","post":"cirdlcvbn0001252na1hgzz0z","slug":"49-recentlyedited.gif","modified":1,"renderable":1},{"_id":"source/_posts/AndroidStudio_shortcut_key/51-extractvariable.gif","post":"cirdlcvbn0001252na1hgzz0z","slug":"51-extractvariable.gif","modified":1,"renderable":1},{"_id":"source/_posts/AndroidStudio_shortcut_key/52-extractparam.gif","post":"cirdlcvbn0001252na1hgzz0z","slug":"52-extractparam.gif","modified":1,"renderable":1},{"_id":"source/_posts/AndroidStudio_shortcut_key/54-inline.gif","post":"cirdlcvbn0001252na1hgzz0z","slug":"54-inline.gif","modified":1,"renderable":1},{"_id":"source/_posts/AndroidStudio_shortcut_key/55-rename.gif","post":"cirdlcvbn0001252na1hgzz0z","slug":"55-rename.gif","modified":1,"renderable":1},{"_id":"source/_posts/AndroidStudio_shortcut_key/migration_guide_save_settings.png","post":"cirdlcvbn0001252na1hgzz0z","slug":"migration_guide_save_settings.png","modified":1,"renderable":1},{"_id":"source/_posts/AndroidStudio_shortcut_key/post-bg-androidstudio.jpg","post":"cirdlcvbn0001252na1hgzz0z","slug":"post-bg-androidstudio.jpg","modified":1,"renderable":1},{"_id":"source/_posts/AndroidStudio_shortcut_key/studio-debug-settings-icon.png","post":"cirdlcvbn0001252na1hgzz0z","slug":"studio-debug-settings-icon.png","modified":1,"renderable":1},{"_id":"source/_posts/AndroidStudio_shortcut_key/summary1.png","post":"cirdlcvbn0001252na1hgzz0z","slug":"summary1.png","modified":1,"renderable":1},{"_id":"source/_posts/AndroidStudio_shortcut_key/summary_2.png","post":"cirdlcvbn0001252na1hgzz0z","slug":"summary_2.png","modified":1,"renderable":1}],"PostCategory":[],"PostTag":[{"post_id":"cirdlcvbn0001252na1hgzz0z","tag_id":"cirdlcvbx0003252nzsapuglz","_id":"cirdlcvc20008252njvvs83j3"},{"post_id":"cirdlcvbv0002252nbjxcii1a","tag_id":"cirdlcvbx0003252nzsapuglz","_id":"cirdlcvcc000c252nn9hb4ba6"},{"post_id":"cirdlcvbz0004252na1tcr5uq","tag_id":"cirdlcvc5000a252nr8vw33ly","_id":"cirdlcvck000g252nymxsic6p"},{"post_id":"cirdlcvc00005252n0ef0rm7e","tag_id":"cirdlcvci000f252npha89fru","_id":"cirdlcvcu000j252nn4da3kxj"},{"post_id":"cirdlcvc10007252n4a9b3izd","tag_id":"cirdlcvcu000i252n08blpapb","_id":"cirdlcvcu000l252n4qp9tl5i"},{"post_id":"cirdlcvc20009252nwtdi7q5g","tag_id":"cirdlcvcu000k252nnocx2q76","_id":"cirdlcvcv000n252n78cm5efh"},{"post_id":"cirdlcvc8000b252nor6cul3n","tag_id":"cirdlcvcv000m252nbyu0whpp","_id":"cirdlcvcv000p252nfs6hjxox"},{"post_id":"cirdlcvcd000d252ndzax0c8n","tag_id":"cirdlcvcv000o252npxkcprpo","_id":"cirdlcvcw000r252nvli27apj"},{"post_id":"cirdlcvch000e252n4mk211y2","tag_id":"cirdlcvci000f252npha89fru","_id":"cirdlcvcx000t252nsrq6xl32"},{"post_id":"cirdlcvcl000h252nqi1bk5f0","tag_id":"cirdlcvcu000k252nnocx2q76","_id":"cirdlcvcx000u252nt5usm2kv"}],"Tag":[{"name":"AndroidStudio","_id":"cirdlcvbx0003252nzsapuglz"},{"name":"开源项目","_id":"cirdlcvc5000a252nr8vw33ly"},{"name":"Android","_id":"cirdlcvci000f252npha89fru"},{"name":"Markdown","_id":"cirdlcvcu000i252n08blpapb"},{"name":"感悟","_id":"cirdlcvcu000k252nnocx2q76"},{"name":"UML","_id":"cirdlcvcv000m252nbyu0whpp"},{"name":"Java","_id":"cirdlcvcv000o252npxkcprpo"}]}}